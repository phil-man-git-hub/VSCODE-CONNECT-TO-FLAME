{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"HOWTO_GENERATE_API_REPORTS/","text":"How to Generate Flame API Reports This guide explains how to systematically crawl the running Autodesk Flame Python API to generate detailed JSON reports of all available modules, classes, functions, and properties. Target Audience: Developers and AI Agents (Gemini). Prerequisites Autodesk Flame must be running. The Flame Listener must be deployed and active in the current project. Check: You should see Flame listener listening on 127.0.0.1:5555 in the Flame shell/logs. Deploy: If not running, use python scripts/deploy_to_flame_project.py --copy --scripts-dir <PATH_TO_PROJECT_PYTHON_SETUPS> and restart Flame. Step-by-Step Guide 1. Run the Collector Script Open a terminal in the repository root and run: python scripts/collect_flame_api.py --include-all --include-all : Forces the script to inspect every discovered symbol (classes, functions, singletons) instead of just the core Py* classes. 2. Locate the Output The script creates a timestamped directory for each run: reports/api_dump/YYYY-MM-DD_HH-MM-SS/ Inside you will find: * index.json : A summary of all crawled items. * <SymbolName>.json : Detailed introspection for each object (e.g., PyBatch.json , execute_command.json ). 3. Generate Type Stubs (Optional but Recommended) To update the IDE autocompletion and type checking files, run: python scripts/generate_stubs_from_reports.py --latest This will update stubs/flame.pyi with the signatures and docstrings extracted from the latest crawl. 4. Compare Versions (Optional) To see what changed between Flame versions (e.g., pr235 vs pr236 ): 1. Run the collector on the old version. 2. Run the collector on the new version. 3. Compare the two timestamped directories using diff or a visual diff tool. Instructions for AI Agents (Gemini) If you are an AI assistant tasked with updating the API definitions or checking for version compatibility, follow this protocol: Verify Connection: Run python scripts/verify_listener.py to confirm the bridge is active. Execute Crawl: Run python scripts/collect_flame_api.py --include-all . Ingest Results: Read the generated reports/api_dump/<latest_timestamp>/index.json to understand the scope. Read specific <Symbol>.json files to update your internal knowledge or generate type stubs ( .pyi ). Troubleshooting Connection Refused: The listener is not running in Flame. Check flame.project.json or your deployment paths. Timeout: The API might be busy. The script waits 10s per request. Ensure Flame is not blocked by a modal dialog.","title":"How to Generate Flame API Reports"},{"location":"HOWTO_GENERATE_API_REPORTS/#how-to-generate-flame-api-reports","text":"This guide explains how to systematically crawl the running Autodesk Flame Python API to generate detailed JSON reports of all available modules, classes, functions, and properties. Target Audience: Developers and AI Agents (Gemini).","title":"How to Generate Flame API Reports"},{"location":"HOWTO_GENERATE_API_REPORTS/#prerequisites","text":"Autodesk Flame must be running. The Flame Listener must be deployed and active in the current project. Check: You should see Flame listener listening on 127.0.0.1:5555 in the Flame shell/logs. Deploy: If not running, use python scripts/deploy_to_flame_project.py --copy --scripts-dir <PATH_TO_PROJECT_PYTHON_SETUPS> and restart Flame.","title":"Prerequisites"},{"location":"HOWTO_GENERATE_API_REPORTS/#step-by-step-guide","text":"","title":"Step-by-Step Guide"},{"location":"HOWTO_GENERATE_API_REPORTS/#1-run-the-collector-script","text":"Open a terminal in the repository root and run: python scripts/collect_flame_api.py --include-all --include-all : Forces the script to inspect every discovered symbol (classes, functions, singletons) instead of just the core Py* classes.","title":"1. Run the Collector Script"},{"location":"HOWTO_GENERATE_API_REPORTS/#2-locate-the-output","text":"The script creates a timestamped directory for each run: reports/api_dump/YYYY-MM-DD_HH-MM-SS/ Inside you will find: * index.json : A summary of all crawled items. * <SymbolName>.json : Detailed introspection for each object (e.g., PyBatch.json , execute_command.json ).","title":"2. Locate the Output"},{"location":"HOWTO_GENERATE_API_REPORTS/#3-generate-type-stubs-optional-but-recommended","text":"To update the IDE autocompletion and type checking files, run: python scripts/generate_stubs_from_reports.py --latest This will update stubs/flame.pyi with the signatures and docstrings extracted from the latest crawl.","title":"3. Generate Type Stubs (Optional but Recommended)"},{"location":"HOWTO_GENERATE_API_REPORTS/#4-compare-versions-optional","text":"To see what changed between Flame versions (e.g., pr235 vs pr236 ): 1. Run the collector on the old version. 2. Run the collector on the new version. 3. Compare the two timestamped directories using diff or a visual diff tool.","title":"4. Compare Versions (Optional)"},{"location":"HOWTO_GENERATE_API_REPORTS/#instructions-for-ai-agents-gemini","text":"If you are an AI assistant tasked with updating the API definitions or checking for version compatibility, follow this protocol: Verify Connection: Run python scripts/verify_listener.py to confirm the bridge is active. Execute Crawl: Run python scripts/collect_flame_api.py --include-all . Ingest Results: Read the generated reports/api_dump/<latest_timestamp>/index.json to understand the scope. Read specific <Symbol>.json files to update your internal knowledge or generate type stubs ( .pyi ).","title":"Instructions for AI Agents (Gemini)"},{"location":"HOWTO_GENERATE_API_REPORTS/#troubleshooting","text":"Connection Refused: The listener is not running in Flame. Check flame.project.json or your deployment paths. Timeout: The API might be busy. The script waits 10s per request. Ensure Flame is not blocked by a modal dialog.","title":"Troubleshooting"},{"location":"TODO/","text":"TODO \u2014 short term (high priority) Install debugpy into Flame and verify attach Add scripts/install_debugpy.py that can locate Flame's Python or accept a path and run pip install debugpy . Deploy debugpy and restart Flame, then run Flame: Start debug server and attach from VS Code to confirm. Document UI freeze caveats and recommend non-blocking workflows for debugging. Harden listener Add timeouts and cancellation for long-running scripts. Add better error responses and logging. Tests & CI Add automated tests for ping , execute , and token auth (mock + optional real-Flame tests guarded by env var). Add GitHub Actions workflow to run unit tests and linting. UX & polish Add extension snippets and ship .pyi stubs in extension/stubs/ . Add file-sync/auto-reload helper (optional feature). Prepare extension packaging and Marketplace publish flow. TODO \u2014 lower priority / future Add a debug mode for the listener that captures stack traces and execution metrics. Explore a safer main-thread execution API or request Flame upstream add a command port API.","title":"TODO \u2014 short term (high priority)"},{"location":"TODO/#todo-short-term-high-priority","text":"Install debugpy into Flame and verify attach Add scripts/install_debugpy.py that can locate Flame's Python or accept a path and run pip install debugpy . Deploy debugpy and restart Flame, then run Flame: Start debug server and attach from VS Code to confirm. Document UI freeze caveats and recommend non-blocking workflows for debugging. Harden listener Add timeouts and cancellation for long-running scripts. Add better error responses and logging. Tests & CI Add automated tests for ping , execute , and token auth (mock + optional real-Flame tests guarded by env var). Add GitHub Actions workflow to run unit tests and linting. UX & polish Add extension snippets and ship .pyi stubs in extension/stubs/ . Add file-sync/auto-reload helper (optional feature). Prepare extension packaging and Marketplace publish flow.","title":"TODO \u2014 short term (high priority)"},{"location":"TODO/#todo-lower-priority-future","text":"Add a debug mode for the listener that captures stack traces and execution metrics. Explore a safer main-thread execution API or request Flame upstream add a command port API.","title":"TODO \u2014 lower priority / future"},{"location":"architecture/","text":"Architecture This project uses a small three\u2011component architecture: Flame listener (inside Flame) \u2014 executes Python code on the Flame main thread and returns stdout/stderr/exceptions. VS Code extension \u2014 sends code to the listener, shows output, manages connection and stubs. Stub generator \u2014 generates .pyi files so VS Code can provide autocomplete and type information. Threading and execution model All calls to the Flame API must be run on Flame's main/UI thread. The listener should receive code and schedule its execution using flame.execute_on_main_thread() (or equivalent) to avoid UI races. Security and lifecycle Bind to localhost or use Unix domain sockets. Default to local-only access. Use a token-based handshake or restrict to OS-level local sockets for access control. Start the listener via Flame's Python startup mechanism so it is available whenever Flame runs. Testing Provide a mock_flame_server.py for local development and CI testing to allow extension development without an actual Flame instance.","title":"Architecture"},{"location":"architecture/#architecture","text":"This project uses a small three\u2011component architecture: Flame listener (inside Flame) \u2014 executes Python code on the Flame main thread and returns stdout/stderr/exceptions. VS Code extension \u2014 sends code to the listener, shows output, manages connection and stubs. Stub generator \u2014 generates .pyi files so VS Code can provide autocomplete and type information. Threading and execution model All calls to the Flame API must be run on Flame's main/UI thread. The listener should receive code and schedule its execution using flame.execute_on_main_thread() (or equivalent) to avoid UI races. Security and lifecycle Bind to localhost or use Unix domain sockets. Default to local-only access. Use a token-based handshake or restrict to OS-level local sockets for access control. Start the listener via Flame's Python startup mechanism so it is available whenever Flame runs. Testing Provide a mock_flame_server.py for local development and CI testing to allow extension development without an actual Flame instance.","title":"Architecture"},{"location":"deploy/","text":"Deploying the listener into a Flame project This document describes how to deploy the repository's listener and helpers into a Flame project so they run when Flame starts. Configure flame.project.json at the repo root with an appropriate scriptsDir pointing to your project's setups/python/ directory. Example: { \"projectId\": \"888_flame_code\", \"flameProjectPath\": \"/Volumes/Samsung-T3-1TB/Autodesk/flame/projects/888_flame_code_2027_romeo\", \"scriptsDir\": \"/Volumes/Samsung-T3-1TB/Autodesk/flame/projects/888_flame_code_2027_romeo/setups/python/\" } (Optional) Create a .flame.secrets.json in the repo root containing your listener token: { \"token\": \"your-flame-token\" } This file is ignored by git by default. For CI and automation, prefer environment variable FLAME_TOKEN . Run the deploy helper: python scripts/deploy_to_flame_project.py --copy This copies flame_listener.py , generate_stubs.py , and startup_flame_listener.py into your project's setups/python/ directory and (optionally) copies .flame.secrets.json . Launch Flame for the project: /opt/Autodesk/flame_2027.pr235/bin/startApplication -J \"888_flame_code_2027_romeo\" -W \"romeo\" Watch Flame's stdout for the listener startup message (the startup hook prints Flame listener startup hook started in background thread ). The listener will check the token on incoming requests and reject requests with invalid tokens. Run the extension's Flame: Connect command in VS Code (it will set the token automatically if FLAME_TOKEN or .flame.secrets.json is present in your workspace). Then use Flame: Run in Flame to send code. Notes The listener must be started by Flame's Python startup process \u2014 the startup_flame_listener.py hook will start the listener in a background thread. If you prefer to manually install files, copy the three files above into your project's setups/python/ directory and ensure the .flame.secrets.json token is present. Debugging / Next steps \ud83d\udd27 The deployed listener currently attempts to start debugpy on demand, but debugpy is not installed inside Flame by default. To enable debugging, install debugpy into Flame's Python environment (or stage debugpy into the project's setups/python/ ) and then use Flame: Start debug server from the extension to start the attachable debug server. Warning: Breakpoints and long-running pauses can freeze Flame's UI because Flame runs an embedded single-threaded Python interpreter. Test non-blocking/debug patterns first and document caveats. See docs/TODO.md for the installation and verification tasks.","title":"Deploying the listener into a Flame project"},{"location":"deploy/#deploying-the-listener-into-a-flame-project","text":"This document describes how to deploy the repository's listener and helpers into a Flame project so they run when Flame starts. Configure flame.project.json at the repo root with an appropriate scriptsDir pointing to your project's setups/python/ directory. Example: { \"projectId\": \"888_flame_code\", \"flameProjectPath\": \"/Volumes/Samsung-T3-1TB/Autodesk/flame/projects/888_flame_code_2027_romeo\", \"scriptsDir\": \"/Volumes/Samsung-T3-1TB/Autodesk/flame/projects/888_flame_code_2027_romeo/setups/python/\" } (Optional) Create a .flame.secrets.json in the repo root containing your listener token: { \"token\": \"your-flame-token\" } This file is ignored by git by default. For CI and automation, prefer environment variable FLAME_TOKEN . Run the deploy helper: python scripts/deploy_to_flame_project.py --copy This copies flame_listener.py , generate_stubs.py , and startup_flame_listener.py into your project's setups/python/ directory and (optionally) copies .flame.secrets.json . Launch Flame for the project: /opt/Autodesk/flame_2027.pr235/bin/startApplication -J \"888_flame_code_2027_romeo\" -W \"romeo\" Watch Flame's stdout for the listener startup message (the startup hook prints Flame listener startup hook started in background thread ). The listener will check the token on incoming requests and reject requests with invalid tokens. Run the extension's Flame: Connect command in VS Code (it will set the token automatically if FLAME_TOKEN or .flame.secrets.json is present in your workspace). Then use Flame: Run in Flame to send code. Notes The listener must be started by Flame's Python startup process \u2014 the startup_flame_listener.py hook will start the listener in a background thread. If you prefer to manually install files, copy the three files above into your project's setups/python/ directory and ensure the .flame.secrets.json token is present.","title":"Deploying the listener into a Flame project"},{"location":"deploy/#debugging-next-steps","text":"The deployed listener currently attempts to start debugpy on demand, but debugpy is not installed inside Flame by default. To enable debugging, install debugpy into Flame's Python environment (or stage debugpy into the project's setups/python/ ) and then use Flame: Start debug server from the extension to start the attachable debug server. Warning: Breakpoints and long-running pauses can freeze Flame's UI because Flame runs an embedded single-threaded Python interpreter. Test non-blocking/debug patterns first and document caveats. See docs/TODO.md for the installation and verification tasks.","title":"Debugging / Next steps \ud83d\udd27"},{"location":"extension_dev/","text":"Extension development \u2014 quick start Follow these steps to run and debug the Flame VS Code extension locally. Run in Extension Development Host (fast) Open this repository in VS Code. Open the extension/ folder in the Explorer. Press F5 (Run \u2192 Start Debugging) to launch the Extension Development Host. In the host window, open the Command Palette and run: Flame: Connect to connect to a listener (or use the mock server in tests/ ), Flame: Start debug server to request Flame start a debug server, Flame: Run in Flame to send the current file/selection to Flame. Development virtual environment We recommend using a system Python virtual environment for running tests and development tools so your environment is stable across Flame preview upgrades. Quick setup: # Create a system venv in repo root using system python3 python3 -m venv .venv # Activate source .venv/bin/activate # Install dev deps python -m pip install --upgrade pip setuptools wheel python -m pip install -r requirements.txt Or run the helper script: scripts/setup_dev_env.sh [python3] VS Code: select the interpreter from the Command Palette or rely on the workspace setting python.defaultInterpreterPath which points to ${workspaceFolder}/.venv/bin/python . If you want me to create the .venv now I can (I'll use system python3 unless you prefer otherwise). Flame package dependencies & notes The repository includes a set of runtime packages commonly used with Flame which we install into the dev venv for testing: PySide6 , OpenImageIO , OpenTimelineIO , OpenColorIO . Import names can differ from the pip package names (for example, opentimelineio is the import for OpenTimelineIO). In our smoke test OpenColorIO was not importable under OpenColorIO or opencolorio but is available as the PyOpenColorIO package (import as PyOpenColorIO ). The PyPI package name is opencolorio and docs are at https://opencolorio.readthedocs.io/en/latest/quick_start/installation.html. Prefer Flame-provided libraries when available. These packages include native/binary wheels that are tied to the Python ABI and macOS platform. If you upgrade Python (or change OS/architecture) you may need to reinstall or rebuild wheels. Verify imports in your dev venv with the included helper: source .venv/bin/activate python scripts/smoke_imports.py Environment variables - FLAME_LISTENER_LOG \u2014 path to append structured listener logs (defaults to /tmp/flame_listener.log ). - FLAME_LISTENER_RECV_TIMEOUT \u2014 socket recv timeout in seconds for each client connection (defaults to 5.0 ). Collecting debug info - Use scripts/collect_flame_debug_logs.py to collect a small bundle (ps, lsof, listener ping, a short breakpoint test, and head/tail of listener log) into /tmp for easier triage. To verify behavior inside a running Flame instance, use Flame: Run in Flame to execute a short script that prints import/version info, or run a small end-to-end test against the real Flame runtime. Example script: examples/inspect_flame_env.py prints the detected import names and versions for the common Flame runtime packages. Run it locally in your dev venv ( python examples/inspect_flame_env.py ) or send it to Flame with Flame: Run in Flame . Automated smoke test: tests/test_imports.py will attempt the same imports and will skip if packages are not available in the environment (so CI can opt-in by installing the binary deps). - When Flame's Python ABI or installation changes, recreate your venv ( rm -rf .venv && python3 -m venv .venv && scripts/setup_dev_env.sh ) before running dependent tests. Build & package Install deps: npm ci (run in extension/ or use the provided task Install extension deps ). Build: npm run compile (task: Build extension ). Package: npx vsce package (task: Package extension ) to produce a .vsix . Test the debug flow locally with the mock server Run the mock server once: python tests/mock_flame_server.py (it accepts one request and exits). Use tests/test_start_debug.py to verify the start_debug_server command is handled by the mock server. Useful files .vscode/launch.json \u2014 run the extension or attach to Flame (port 5678) examples/debug_test.py \u2014 example script that starts debugpy and waits for an attach tests/mock_flame_server.py \u2014 small single-request mock of Flame listener If you want, I can run the build and package steps now and run the test for start_debug_server .","title":"Extension development \u2014 quick start"},{"location":"extension_dev/#extension-development-quick-start","text":"Follow these steps to run and debug the Flame VS Code extension locally.","title":"Extension development \u2014 quick start"},{"location":"extension_dev/#run-in-extension-development-host-fast","text":"Open this repository in VS Code. Open the extension/ folder in the Explorer. Press F5 (Run \u2192 Start Debugging) to launch the Extension Development Host. In the host window, open the Command Palette and run: Flame: Connect to connect to a listener (or use the mock server in tests/ ), Flame: Start debug server to request Flame start a debug server, Flame: Run in Flame to send the current file/selection to Flame.","title":"Run in Extension Development Host (fast)"},{"location":"extension_dev/#development-virtual-environment","text":"We recommend using a system Python virtual environment for running tests and development tools so your environment is stable across Flame preview upgrades. Quick setup: # Create a system venv in repo root using system python3 python3 -m venv .venv # Activate source .venv/bin/activate # Install dev deps python -m pip install --upgrade pip setuptools wheel python -m pip install -r requirements.txt Or run the helper script: scripts/setup_dev_env.sh [python3] VS Code: select the interpreter from the Command Palette or rely on the workspace setting python.defaultInterpreterPath which points to ${workspaceFolder}/.venv/bin/python . If you want me to create the .venv now I can (I'll use system python3 unless you prefer otherwise).","title":"Development virtual environment"},{"location":"extension_dev/#flame-package-dependencies-notes","text":"The repository includes a set of runtime packages commonly used with Flame which we install into the dev venv for testing: PySide6 , OpenImageIO , OpenTimelineIO , OpenColorIO . Import names can differ from the pip package names (for example, opentimelineio is the import for OpenTimelineIO). In our smoke test OpenColorIO was not importable under OpenColorIO or opencolorio but is available as the PyOpenColorIO package (import as PyOpenColorIO ). The PyPI package name is opencolorio and docs are at https://opencolorio.readthedocs.io/en/latest/quick_start/installation.html. Prefer Flame-provided libraries when available. These packages include native/binary wheels that are tied to the Python ABI and macOS platform. If you upgrade Python (or change OS/architecture) you may need to reinstall or rebuild wheels. Verify imports in your dev venv with the included helper: source .venv/bin/activate python scripts/smoke_imports.py Environment variables - FLAME_LISTENER_LOG \u2014 path to append structured listener logs (defaults to /tmp/flame_listener.log ). - FLAME_LISTENER_RECV_TIMEOUT \u2014 socket recv timeout in seconds for each client connection (defaults to 5.0 ). Collecting debug info - Use scripts/collect_flame_debug_logs.py to collect a small bundle (ps, lsof, listener ping, a short breakpoint test, and head/tail of listener log) into /tmp for easier triage. To verify behavior inside a running Flame instance, use Flame: Run in Flame to execute a short script that prints import/version info, or run a small end-to-end test against the real Flame runtime. Example script: examples/inspect_flame_env.py prints the detected import names and versions for the common Flame runtime packages. Run it locally in your dev venv ( python examples/inspect_flame_env.py ) or send it to Flame with Flame: Run in Flame . Automated smoke test: tests/test_imports.py will attempt the same imports and will skip if packages are not available in the environment (so CI can opt-in by installing the binary deps). - When Flame's Python ABI or installation changes, recreate your venv ( rm -rf .venv && python3 -m venv .venv && scripts/setup_dev_env.sh ) before running dependent tests.","title":"Flame package dependencies &amp; notes"},{"location":"extension_dev/#build-package","text":"Install deps: npm ci (run in extension/ or use the provided task Install extension deps ). Build: npm run compile (task: Build extension ). Package: npx vsce package (task: Package extension ) to produce a .vsix .","title":"Build &amp; package"},{"location":"extension_dev/#test-the-debug-flow-locally-with-the-mock-server","text":"Run the mock server once: python tests/mock_flame_server.py (it accepts one request and exits). Use tests/test_start_debug.py to verify the start_debug_server command is handled by the mock server.","title":"Test the debug flow locally with the mock server"},{"location":"extension_dev/#useful-files","text":".vscode/launch.json \u2014 run the extension or attach to Flame (port 5678) examples/debug_test.py \u2014 example script that starts debugpy and waits for an attach tests/mock_flame_server.py \u2014 small single-request mock of Flame listener If you want, I can run the build and package steps now and run the test for start_debug_server .","title":"Useful files"},{"location":"protocol/","text":"Communication Protocol Transport TCP socket (localhost) \u2014 easiest for cross-platform dev. Optional: Unix domain socket for local-only secure communication. Message format Client \u2192 Listener (JSON): { \"command\": \"execute\", \"id\": \"uuid-or-counter\", \"token\": \"optional-auth-token\", \"code\": \"print('hello from VS Code')\" } Listener \u2192 Client (JSON response): { \"id\": \"same-id\", \"stdout\": \"Hello\\n\", \"stderr\": \"\", \"exception\": null } Commands execute \u2014 run the provided code; return stdout/stderr and any exception details. ping \u2014 health check. open_file (optional) \u2014 request Flame to open or load a file. Notes All responses must include the request id to allow in-flight matching and timeouts. Keep messages compact; only serialize structured data in JSON. Use base64 for binary payloads if needed.","title":"Communication Protocol"},{"location":"protocol/#communication-protocol","text":"Transport TCP socket (localhost) \u2014 easiest for cross-platform dev. Optional: Unix domain socket for local-only secure communication. Message format Client \u2192 Listener (JSON): { \"command\": \"execute\", \"id\": \"uuid-or-counter\", \"token\": \"optional-auth-token\", \"code\": \"print('hello from VS Code')\" } Listener \u2192 Client (JSON response): { \"id\": \"same-id\", \"stdout\": \"Hello\\n\", \"stderr\": \"\", \"exception\": null } Commands execute \u2014 run the provided code; return stdout/stderr and any exception details. ping \u2014 health check. open_file (optional) \u2014 request Flame to open or load a file. Notes All responses must include the request id to allow in-flight matching and timeouts. Keep messages compact; only serialize structured data in JSON. Use base64 for binary payloads if needed.","title":"Communication Protocol"},{"location":"stubs/","text":"Flame API Stubs VS Code cannot inspect Flame's embedded Python interpreter at design time. To provide IntelliSense, autocompletion, and hover documentation, we ship high-quality .pyi stub files. Generation Pipeline We use a two-phase automated pipeline to ensure the stubs are always accurate and up-to-date with your current Flame version. 1. JSON Report Collection The first step is to crawl the running Flame API using scripts/collect_flame_api.py . This script uses deep introspection to capture: - Class hierarchies and inheritance. - Method signatures and parameter default values. - Property descriptions and docstrings. - Global managers (singletons) and utility functions. 2. Stub Generation Once the JSON reports are gathered, scripts/generate_stubs_from_reports.py parses the reports and generates a consolidated stubs/flame.pyi file. This script is highly specialized for Flame's Boost.Python implementation, extracting signatures directly from docstrings when standard introspection is blocked by the C++ bridge. How to Update Stubs If you upgrade Flame or want to ensure your stubs are fresh: # 1. Gather latest API data from a running Flame instance python scripts/collect_flame_api.py --include-all # 2. Generate the .pyi file from the reports python scripts/generate_stubs_from_reports.py --latest Using Stubs in VS Code The flame-vscode extension automatically configures the environment to use these stubs. If you are developing scripts locally without the extension, add the stubs/ directory to your python.analysis.extraPaths setting.","title":"Flame API Stubs"},{"location":"stubs/#flame-api-stubs","text":"VS Code cannot inspect Flame's embedded Python interpreter at design time. To provide IntelliSense, autocompletion, and hover documentation, we ship high-quality .pyi stub files.","title":"Flame API Stubs"},{"location":"stubs/#generation-pipeline","text":"We use a two-phase automated pipeline to ensure the stubs are always accurate and up-to-date with your current Flame version.","title":"Generation Pipeline"},{"location":"stubs/#1-json-report-collection","text":"The first step is to crawl the running Flame API using scripts/collect_flame_api.py . This script uses deep introspection to capture: - Class hierarchies and inheritance. - Method signatures and parameter default values. - Property descriptions and docstrings. - Global managers (singletons) and utility functions.","title":"1. JSON Report Collection"},{"location":"stubs/#2-stub-generation","text":"Once the JSON reports are gathered, scripts/generate_stubs_from_reports.py parses the reports and generates a consolidated stubs/flame.pyi file. This script is highly specialized for Flame's Boost.Python implementation, extracting signatures directly from docstrings when standard introspection is blocked by the C++ bridge.","title":"2. Stub Generation"},{"location":"stubs/#how-to-update-stubs","text":"If you upgrade Flame or want to ensure your stubs are fresh: # 1. Gather latest API data from a running Flame instance python scripts/collect_flame_api.py --include-all # 2. Generate the .pyi file from the reports python scripts/generate_stubs_from_reports.py --latest","title":"How to Update Stubs"},{"location":"stubs/#using-stubs-in-vs-code","text":"The flame-vscode extension automatically configures the environment to use these stubs. If you are developing scripts locally without the extension, add the stubs/ directory to your python.analysis.extraPaths setting.","title":"Using Stubs in VS Code"},{"location":"vision/","text":"Vision The VSCode-Connect-to-Flame project aims to bring modern, developer-friendly workflows to Autodesk Flame Python development. By bridging the gap between Flame's closed environment and Visual Studio Code, we enable a rapid iteration loop, deep IntelliSense, and integrated debugging. Core Goals Remote Execution: Execute code directly from VS Code inside a running Flame instance. Deep IntelliSense: Provide accurate autocompletion and documentation for the Flame API via high-quality type stubs. Integrated Debugging: Enable line-by-line debugging of Flame scripts using debugpy . Automated Documentation: Maintain a comprehensive API reference that updates automatically with new Flame releases. Architecture Overview The system consists of three primary components: Flame Listener (inside Flame): A Python service that listens for incoming code, executes it safely on the main UI thread , and returns results. VS Code Extension: A user-facing bridge that sends code selections or files to the listener and displays output in a dedicated panel. API Intelligence Pipeline: A suite of scripts that crawl the Flame API to generate detailed JSON reports, which are then used to produce Markdown documentation and .pyi type stubs. graph TD subgraph VS_Code [VS Code] Ext[Extension] Stubs[Type Stubs .pyi] end subgraph Flame [Autodesk Flame] List[Flame Listener] API[Flame Python API] end Ext -- TCP/JSON --> List List -- Main Thread --> API API -- Results --> List List -- JSON --> Ext MVP Acceptance Criteria [x] Run in Flame: Execute code in Flame or a mock server. [x] Output Capture: View stdout , stderr , and exceptions in VS Code. [x] Main Thread Safety: Automatic dispatch of API calls to the UI thread. [x] Rich IntelliSense: Over 2,400 lines of documented stubs. [ ] Remote Debugging: Full integration with debugpy (In Progress). Development Philosophy Decoupled Intelligence: All API knowledge is gathered via automated introspection, ensuring accuracy across different Flame versions. Safety First: Strict enforcement of main-thread execution to prevent host application crashes. Pragmatic Tooling: Focus on providing the most impactful features (Execution & IntelliSense) first.","title":"Vision"},{"location":"vision/#vision","text":"The VSCode-Connect-to-Flame project aims to bring modern, developer-friendly workflows to Autodesk Flame Python development. By bridging the gap between Flame's closed environment and Visual Studio Code, we enable a rapid iteration loop, deep IntelliSense, and integrated debugging.","title":"Vision"},{"location":"vision/#core-goals","text":"Remote Execution: Execute code directly from VS Code inside a running Flame instance. Deep IntelliSense: Provide accurate autocompletion and documentation for the Flame API via high-quality type stubs. Integrated Debugging: Enable line-by-line debugging of Flame scripts using debugpy . Automated Documentation: Maintain a comprehensive API reference that updates automatically with new Flame releases.","title":"Core Goals"},{"location":"vision/#architecture-overview","text":"The system consists of three primary components: Flame Listener (inside Flame): A Python service that listens for incoming code, executes it safely on the main UI thread , and returns results. VS Code Extension: A user-facing bridge that sends code selections or files to the listener and displays output in a dedicated panel. API Intelligence Pipeline: A suite of scripts that crawl the Flame API to generate detailed JSON reports, which are then used to produce Markdown documentation and .pyi type stubs. graph TD subgraph VS_Code [VS Code] Ext[Extension] Stubs[Type Stubs .pyi] end subgraph Flame [Autodesk Flame] List[Flame Listener] API[Flame Python API] end Ext -- TCP/JSON --> List List -- Main Thread --> API API -- Results --> List List -- JSON --> Ext","title":"Architecture Overview"},{"location":"vision/#mvp-acceptance-criteria","text":"[x] Run in Flame: Execute code in Flame or a mock server. [x] Output Capture: View stdout , stderr , and exceptions in VS Code. [x] Main Thread Safety: Automatic dispatch of API calls to the UI thread. [x] Rich IntelliSense: Over 2,400 lines of documented stubs. [ ] Remote Debugging: Full integration with debugpy (In Progress).","title":"MVP Acceptance Criteria"},{"location":"vision/#development-philosophy","text":"Decoupled Intelligence: All API knowledge is gathered via automated introspection, ensuring accuracy across different Flame versions. Safety First: Strict enforcement of main-thread execution to prevent host application crashes. Pragmatic Tooling: Focus on providing the most impactful features (Execution & IntelliSense) first.","title":"Development Philosophy"},{"location":"api/","text":"Flame Python API Reference Welcome to the automatically generated API reference for Autodesk Flame. Core Modules Classes : Detailed reference for all Flame Python classes (e.g., PyClip , PyBatch ). Functions : Global utility functions (e.g., execute_command , import_clips ). Global Objects : Singleton instances available in the global scope (e.g., project , timeline ). How this was generated This documentation was generated by introspecting a running instance of Autodesk Flame 2027. See How to Generate API Reports for details.","title":"Flame Python API Reference"},{"location":"api/#flame-python-api-reference","text":"Welcome to the automatically generated API reference for Autodesk Flame.","title":"Flame Python API Reference"},{"location":"api/#core-modules","text":"Classes : Detailed reference for all Flame Python classes (e.g., PyClip , PyBatch ). Functions : Global utility functions (e.g., execute_command , import_clips ). Global Objects : Singleton instances available in the global scope (e.g., project , timeline ).","title":"Core Modules"},{"location":"api/#how-this-was-generated","text":"This documentation was generated by introspecting a running instance of Autodesk Flame 2027. See How to Generate API Reports for details.","title":"How this was generated"},{"location":"api/TODO/","text":"API Documentation TODO This TODO tracks the work items for building a comprehensive Flame Python API knowledge base. [x] API-0001 (partial): Create the overall plan and infrastructure for per-symbol docs (scripts + basic output) [x] API-0002: Add symbol cross-links from flame.md and index.json (initial links present) [x] API-0003 (partial): Add class methods capture (collector captures methods) [x] API-0004 (partial): Implement safe probing ( --probe-safe implemented, opt-in) [x] API-0005 (partial): Improve stubs/*.pyi with signatures (done for many symbols) [x] API-0006: Add stub parsing tests (planned) [x] API-0007: Add example hooks (startup/menu/asset-sync) and smoke tests \u2705 [x] API-0008: Add snippets for Project/Timeline/Clip and smoke tests \u2705 [x] API-0009: Add mkdocs + CI publishing (CI workflow added; deploy on push) \u2705 [x] API-0016: Remove generated site/ from the repository and publish site from CI (site is now untracked; .github/workflows/docs.yml publishes the site) \u2705 [x] API-0010: Generate per-symbol Markdown pages: docs/api/classes/<Class>.md , docs/api/functions/<fn>.md (Completed Jan 2026). Implemented collect_flame_api.py for systematic crawling. Implemented generate_api_docs.py for JSON-to-Markdown conversion. [ ] API-0011: Add instance attribute probes via allowlist and document safety [ ] API-0012: Improve stub return-type population from probe results [ ] API-0013: Add mkdocs nav entries for symbol directories and symbol index pages [ ] API-0014: Add CI job to optionally run --probe-safe and store results as artifacts [ ] API-0015: Add a probe dashboard and flagged warnings page Notes: - Items marked \"partial\" mean scaffold/implementation exists but further work is needed.","title":"API Documentation TODO"},{"location":"api/TODO/#api-documentation-todo","text":"This TODO tracks the work items for building a comprehensive Flame Python API knowledge base. [x] API-0001 (partial): Create the overall plan and infrastructure for per-symbol docs (scripts + basic output) [x] API-0002: Add symbol cross-links from flame.md and index.json (initial links present) [x] API-0003 (partial): Add class methods capture (collector captures methods) [x] API-0004 (partial): Implement safe probing ( --probe-safe implemented, opt-in) [x] API-0005 (partial): Improve stubs/*.pyi with signatures (done for many symbols) [x] API-0006: Add stub parsing tests (planned) [x] API-0007: Add example hooks (startup/menu/asset-sync) and smoke tests \u2705 [x] API-0008: Add snippets for Project/Timeline/Clip and smoke tests \u2705 [x] API-0009: Add mkdocs + CI publishing (CI workflow added; deploy on push) \u2705 [x] API-0016: Remove generated site/ from the repository and publish site from CI (site is now untracked; .github/workflows/docs.yml publishes the site) \u2705 [x] API-0010: Generate per-symbol Markdown pages: docs/api/classes/<Class>.md , docs/api/functions/<fn>.md (Completed Jan 2026). Implemented collect_flame_api.py for systematic crawling. Implemented generate_api_docs.py for JSON-to-Markdown conversion. [ ] API-0011: Add instance attribute probes via allowlist and document safety [ ] API-0012: Improve stub return-type population from probe results [ ] API-0013: Add mkdocs nav entries for symbol directories and symbol index pages [ ] API-0014: Add CI job to optionally run --probe-safe and store results as artifacts [ ] API-0015: Add a probe dashboard and flagged warnings page Notes: - Items marked \"partial\" mean scaffold/implementation exists but further work is needed.","title":"API Documentation TODO"},{"location":"api/batch/","text":"Object: batch Type : PyBatch Description Class derived from PyFlameObject. This class represents a Batch Group.","title":"Object: batch"},{"location":"api/batch/#object-batch","text":"Type : PyBatch","title":"Object: batch"},{"location":"api/batch/#description","text":"Class derived from PyFlameObject. This class represents a Batch Group.","title":"Description"},{"location":"api/browser/","text":"Object: browser Type : PyBrowser Description This class represents the file browser.","title":"Object: browser"},{"location":"api/browser/#object-browser","text":"Type : PyBrowser","title":"Object: browser"},{"location":"api/browser/#description","text":"This class represents the file browser.","title":"Description"},{"location":"api/clear_graphics_memory/","text":"Object: clear_graphics_memory Type : function Description clear_graphics_memory() -> None : Free as much graphics memory as possible. Note that clearing the undo buffer beforehand can increase the amount of releasable graphics memory.","title":"Object: clear_graphics_memory"},{"location":"api/clear_graphics_memory/#object-clear_graphics_memory","text":"Type : function","title":"Object: clear_graphics_memory"},{"location":"api/clear_graphics_memory/#description","text":"clear_graphics_memory() -> None : Free as much graphics memory as possible. Note that clearing the undo buffer beforehand can increase the amount of releasable graphics memory.","title":"Description"},{"location":"api/clear_unreferenced_cache/","text":"Object: clear_unreferenced_cache Type : function Description clear_unreferenced_cache([ (bool)all_projects=False]) -> None : Clear cached media that is no longer referenced by any clip in eitherthe current project or any other project. all_projects -- If True, will also clear unreferenced cached media from all other accessible projects. Default is False, which will only clear unreferenced cached media from the current project.","title":"Object: clear_unreferenced_cache"},{"location":"api/clear_unreferenced_cache/#object-clear_unreferenced_cache","text":"Type : function","title":"Object: clear_unreferenced_cache"},{"location":"api/clear_unreferenced_cache/#description","text":"clear_unreferenced_cache([ (bool)all_projects=False]) -> None : Clear cached media that is no longer referenced by any clip in eitherthe current project or any other project. all_projects -- If True, will also clear unreferenced cached media from all other accessible projects. Default is False, which will only clear unreferenced cached media from the current project.","title":"Description"},{"location":"api/delete/","text":"Object: delete Type : function Description delete( (PyFlameObject)object [, (bool)confirm=True]) -> bool : Delete the target object.","title":"Object: delete"},{"location":"api/delete/#object-delete","text":"Type : function","title":"Object: delete"},{"location":"api/delete/#description","text":"delete( (PyFlameObject)object [, (bool)confirm=True]) -> bool : Delete the target object.","title":"Description"},{"location":"api/duplicate/","text":"Object: duplicate Type : function Description duplicate( (PyFlameObject)object [, (bool)keep_node_connections=False]) -> object : Duplicate the target object.","title":"Object: duplicate"},{"location":"api/duplicate/#object-duplicate","text":"Type : function","title":"Object: duplicate"},{"location":"api/duplicate/#description","text":"duplicate( (PyFlameObject)object [, (bool)keep_node_connections=False]) -> object : Duplicate the target object.","title":"Description"},{"location":"api/duplicate_many/","text":"Object: duplicate_many Type : function Description duplicate_many( (list)object_list [, (bool)keep_node_connections=False]) -> list : Duplicate the target objects.","title":"Object: duplicate_many"},{"location":"api/duplicate_many/#object-duplicate_many","text":"Type : function","title":"Object: duplicate_many"},{"location":"api/duplicate_many/#description","text":"duplicate_many( (list)object_list [, (bool)keep_node_connections=False]) -> list : Duplicate the target objects.","title":"Description"},{"location":"api/execute_command/","text":"Object: execute_command Type : function Description execute_command( (str)command [, (bool)blocking=True [, (bool)shell=False [, (bool)capture_stdout=False [, (bool)capture_stderr=False]]]]) -> tuple : Execute command line through the Autodesk Flame Multi-Purpose Daemon. This way of starting new processes is better since any native python subprocess command (os.system, subprocess, Popen, etc) will call fork() which will duplicate the process memory before calling exec(). This can be costly especially for a process like Flame. command -- Command line to execute. blocking -- If True, will not return until the command line has completed. shell -- Should the command be executed in a sh shell. WARNING Using shell=True can be a security hazard. capture_stdout -- If True, stdout of the command will be captured and returned instead of forwarded to the application stdout. Requires blocking=True capture_stderr -- If True, stdout of the command will be captured and returned instead of forwarded to the application stderr. Requires blocking=True Note: Environment variables will not be forwarded to the executed command.","title":"Object: execute_command"},{"location":"api/execute_command/#object-execute_command","text":"Type : function","title":"Object: execute_command"},{"location":"api/execute_command/#description","text":"execute_command( (str)command [, (bool)blocking=True [, (bool)shell=False [, (bool)capture_stdout=False [, (bool)capture_stderr=False]]]]) -> tuple : Execute command line through the Autodesk Flame Multi-Purpose Daemon. This way of starting new processes is better since any native python subprocess command (os.system, subprocess, Popen, etc) will call fork() which will duplicate the process memory before calling exec(). This can be costly especially for a process like Flame. command -- Command line to execute. blocking -- If True, will not return until the command line has completed. shell -- Should the command be executed in a sh shell. WARNING Using shell=True can be a security hazard. capture_stdout -- If True, stdout of the command will be captured and returned instead of forwarded to the application stdout. Requires blocking=True capture_stderr -- If True, stdout of the command will be captured and returned instead of forwarded to the application stderr. Requires blocking=True Note: Environment variables will not be forwarded to the executed command.","title":"Description"},{"location":"api/execute_shortcut/","text":"Object: execute_shortcut Type : function Description execute_shortcut( (str)description [, (bool)update_list=True]) -> bool : Execute the Flame shortcut. description -- The description in the Keyboard Shortcut editor.","title":"Object: execute_shortcut"},{"location":"api/execute_shortcut/#object-execute_shortcut","text":"Type : function","title":"Object: execute_shortcut"},{"location":"api/execute_shortcut/#description","text":"execute_shortcut( (str)description [, (bool)update_list=True]) -> bool : Execute the Flame shortcut. description -- The description in the Keyboard Shortcut editor.","title":"Description"},{"location":"api/exit/","text":"Object: exit Type : function Description exit() -> None : Exit the application.","title":"Object: exit"},{"location":"api/exit/#object-exit","text":"Type : function","title":"Object: exit"},{"location":"api/exit/#description","text":"exit() -> None : Exit the application.","title":"Description"},{"location":"api/find_by_name/","text":"Object: find_by_name Type : function Description find_by_name( (str)name [, (object)parent=None]) -> list : Find a Flame object in the Media Panel by name.","title":"Object: find_by_name"},{"location":"api/find_by_name/#object-find_by_name","text":"Type : function","title":"Object: find_by_name"},{"location":"api/find_by_name/#description","text":"find_by_name( (str)name [, (object)parent=None]) -> list : Find a Flame object in the Media Panel by name.","title":"Description"},{"location":"api/find_by_uid/","text":"Object: find_by_uid Type : function Description find_by_uid( (str)uid) -> object : Find a Flame object in the Media Panel by UID.","title":"Object: find_by_uid"},{"location":"api/find_by_uid/#object-find_by_uid","text":"Type : function","title":"Object: find_by_uid"},{"location":"api/find_by_uid/#description","text":"find_by_uid( (str)uid) -> object : Find a Flame object in the Media Panel by UID.","title":"Description"},{"location":"api/find_by_wiretap_node_id/","text":"Object: find_by_wiretap_node_id Type : function Description find_by_wiretap_node_id( (str)node_id) -> object : Find a Flame object in the Media Panel by Wiretap Node ID.","title":"Object: find_by_wiretap_node_id"},{"location":"api/find_by_wiretap_node_id/#object-find_by_wiretap_node_id","text":"Type : function","title":"Object: find_by_wiretap_node_id"},{"location":"api/find_by_wiretap_node_id/#description","text":"find_by_wiretap_node_id( (str)node_id) -> object : Find a Flame object in the Media Panel by Wiretap Node ID.","title":"Description"},{"location":"api/flush_graphics_memory/","text":"Object: flush_graphics_memory Type : function Description flush_graphics_memory() -> None : Free as much graphics memory as possible. Note that clearing the undo buffer beforehand can increase the amount of releasable graphics memory. (Deprecated: use clear_graphics_memory instead)","title":"Object: flush_graphics_memory"},{"location":"api/flush_graphics_memory/#object-flush_graphics_memory","text":"Type : function","title":"Object: flush_graphics_memory"},{"location":"api/flush_graphics_memory/#description","text":"flush_graphics_memory() -> None : Free as much graphics memory as possible. Note that clearing the undo buffer beforehand can increase the amount of releasable graphics memory. (Deprecated: use clear_graphics_memory instead)","title":"Description"},{"location":"api/get_current_tab/","text":"Object: get_current_tab Type : function Description get_current_tab() -> str : Get the current tab name.","title":"Object: get_current_tab"},{"location":"api/get_current_tab/#object-get_current_tab","text":"Type : function","title":"Object: get_current_tab"},{"location":"api/get_current_tab/#description","text":"get_current_tab() -> str : Get the current tab name.","title":"Description"},{"location":"api/get_home_directory/","text":"Object: get_home_directory Type : function Description get_home_directory() -> str : Get the application home directory.","title":"Object: get_home_directory"},{"location":"api/get_home_directory/#object-get_home_directory","text":"Type : function","title":"Object: get_home_directory"},{"location":"api/get_home_directory/#description","text":"get_home_directory() -> str : Get the application home directory.","title":"Description"},{"location":"api/get_init_cfg_path/","text":"Object: get_init_cfg_path Type : function Description get_init_cfg_path() -> str : Get the application init configuration file.","title":"Object: get_init_cfg_path"},{"location":"api/get_init_cfg_path/#object-get_init_cfg_path","text":"Type : function","title":"Object: get_init_cfg_path"},{"location":"api/get_init_cfg_path/#description","text":"get_init_cfg_path() -> str : Get the application init configuration file.","title":"Description"},{"location":"api/get_version/","text":"Object: get_version Type : function Description get_version() -> str : Get the application version.","title":"Object: get_version"},{"location":"api/get_version/#object-get_version","text":"Type : function","title":"Object: get_version"},{"location":"api/get_version/#description","text":"get_version() -> str : Get the application version.","title":"Description"},{"location":"api/get_version_major/","text":"Object: get_version_major Type : function Description get_version_major() -> str : Get the application major version.","title":"Object: get_version_major"},{"location":"api/get_version_major/#object-get_version_major","text":"Type : function","title":"Object: get_version_major"},{"location":"api/get_version_major/#description","text":"get_version_major() -> str : Get the application major version.","title":"Description"},{"location":"api/get_version_minor/","text":"Object: get_version_minor Type : function Description get_version_minor() -> str : Get the application minor version.","title":"Object: get_version_minor"},{"location":"api/get_version_minor/#object-get_version_minor","text":"Type : function","title":"Object: get_version_minor"},{"location":"api/get_version_minor/#description","text":"get_version_minor() -> str : Get the application minor version.","title":"Description"},{"location":"api/get_version_patch/","text":"Object: get_version_patch Type : function Description get_version_patch() -> str : Get the application patch version.","title":"Object: get_version_patch"},{"location":"api/get_version_patch/#object-get_version_patch","text":"Type : function","title":"Object: get_version_patch"},{"location":"api/get_version_patch/#description","text":"get_version_patch() -> str : Get the application patch version.","title":"Description"},{"location":"api/get_version_stamp/","text":"Object: get_version_stamp Type : function Description get_version_stamp() -> str : Get the application version stamp.","title":"Object: get_version_stamp"},{"location":"api/get_version_stamp/#object-get_version_stamp","text":"Type : function","title":"Object: get_version_stamp"},{"location":"api/get_version_stamp/#description","text":"get_version_stamp() -> str : Get the application version stamp.","title":"Description"},{"location":"api/go_to/","text":"Object: go_to Type : function Description go_to( (str)tab) -> bool : Deprecated / use set_current_tab() instead.","title":"Object: go_to"},{"location":"api/go_to/#object-go_to","text":"Type : function","title":"Object: go_to"},{"location":"api/go_to/#description","text":"go_to( (str)tab) -> bool : Deprecated / use set_current_tab() instead.","title":"Description"},{"location":"api/import_clips/","text":"Object: import_clips Type : function Description import_clips( (object)path [, (object)destination=None]) -> list : Import one or many clips from a path. Keyword arguments: path -- The path to the media can be: - A path to a single media file. - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). - A folder containing media files. - A pattern to media files (ie \"/dir/{name}_v{version}.{frame}.{extension}\"). - A list of paths. destination -- Flame object containing a clip like a reel or a folder object.","title":"Object: import_clips"},{"location":"api/import_clips/#object-import_clips","text":"Type : function","title":"Object: import_clips"},{"location":"api/import_clips/#description","text":"import_clips( (object)path [, (object)destination=None]) -> list : Import one or many clips from a path. Keyword arguments: path -- The path to the media can be: - A path to a single media file. - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). - A folder containing media files. - A pattern to media files (ie \"/dir/{name}_v{version}.{frame}.{extension}\"). - A list of paths. destination -- Flame object containing a clip like a reel or a folder object.","title":"Description"},{"location":"api/media_panel/","text":"Object: media_panel Type : PyMediaPanel Description This class represents the media panel.","title":"Object: media_panel"},{"location":"api/media_panel/#object-media_panel","text":"Type : PyMediaPanel","title":"Object: media_panel"},{"location":"api/media_panel/#description","text":"This class represents the media panel.","title":"Description"},{"location":"api/mediahub/","text":"Object: mediahub Type : PyMediaHub Description This class represents the MediaHub.","title":"Object: mediahub"},{"location":"api/mediahub/#object-mediahub","text":"Type : PyMediaHub","title":"Object: mediahub"},{"location":"api/mediahub/#description","text":"This class represents the MediaHub.","title":"Description"},{"location":"api/messages/","text":"Object: messages Type : PyMessages Description Module handling message bar in application UI.","title":"Object: messages"},{"location":"api/messages/#object-messages","text":"Type : PyMessages","title":"Object: messages"},{"location":"api/messages/#description","text":"Module handling message bar in application UI.","title":"Description"},{"location":"api/project/","text":"Object: project Type : PyProjectSelector Description Object representing the Project manager.","title":"Object: project"},{"location":"api/project/#object-project","text":"Type : PyProjectSelector","title":"Object: project"},{"location":"api/project/#description","text":"Object representing the Project manager.","title":"Description"},{"location":"api/projects/","text":"Object: projects Type : PyProjectSelector Description Object representing the Project manager.","title":"Object: projects"},{"location":"api/projects/#object-projects","text":"Type : PyProjectSelector","title":"Object: projects"},{"location":"api/projects/#description","text":"Object representing the Project manager.","title":"Description"},{"location":"api/schedule_idle_event/","text":"Object: schedule_idle_event Type : function Description schedule_idle_event( (object)function [, (int)delay=0]) -> None : Register a function callback that will be called eventually when the application is idle. The function must not block and be quick since it will be executed in the main application thread. Keyword arguments: function -- Callable object to be called. delay -- Minimum time (in seconds) to wait before calling function.","title":"Object: schedule_idle_event"},{"location":"api/schedule_idle_event/#object-schedule_idle_event","text":"Type : function","title":"Object: schedule_idle_event"},{"location":"api/schedule_idle_event/#description","text":"schedule_idle_event( (object)function [, (int)delay=0]) -> None : Register a function callback that will be called eventually when the application is idle. The function must not block and be quick since it will be executed in the main application thread. Keyword arguments: function -- Callable object to be called. delay -- Minimum time (in seconds) to wait before calling function.","title":"Description"},{"location":"api/set_current_tab/","text":"Object: set_current_tab Type : function Description set_current_tab( (str)arg1) -> bool : Set the given tab as the active environment. Keyword arguments: tab -- The tab to set active (MediaHub, Conform, Timeline, Effects, Batch, Tools)","title":"Object: set_current_tab"},{"location":"api/set_current_tab/#object-set_current_tab","text":"Type : function","title":"Object: set_current_tab"},{"location":"api/set_current_tab/#description","text":"set_current_tab( (str)arg1) -> bool : Set the given tab as the active environment. Keyword arguments: tab -- The tab to set active (MediaHub, Conform, Timeline, Effects, Batch, Tools)","title":"Description"},{"location":"api/set_render_option/","text":"Object: set_render_option Type : function Description set_render_option( (str)render_option [, (str)render_context='']) -> bool : Set the default render option. Keyword arguments: render_option -- Defines the rendering method used. (Foreground) render_context -- Defines the rendering context. (Timeline, Conform, Effects, BFX, Batch). None for all of them.","title":"Object: set_render_option"},{"location":"api/set_render_option/#object-set_render_option","text":"Type : function","title":"Object: set_render_option"},{"location":"api/set_render_option/#description","text":"set_render_option( (str)render_option [, (str)render_context='']) -> bool : Set the default render option. Keyword arguments: render_option -- Defines the rendering method used. (Foreground) render_context -- Defines the rendering context. (Timeline, Conform, Effects, BFX, Batch). None for all of them.","title":"Description"},{"location":"api/timeline/","text":"Object: timeline Type : PyTimeline Description This class represents the Timeline.","title":"Object: timeline"},{"location":"api/timeline/#object-timeline","text":"Type : PyTimeline","title":"Object: timeline"},{"location":"api/timeline/#description","text":"This class represents the Timeline.","title":"Description"},{"location":"api/users/","text":"Object: users Type : PyUsers Description Object representing the User manager.","title":"Object: users"},{"location":"api/users/#object-users","text":"Type : PyUsers","title":"Object: users"},{"location":"api/users/#description","text":"Object representing the User manager.","title":"Description"},{"location":"api/classes/PyActionFamilyNode/","text":"Class: PyActionFamilyNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Class derived from PyNode. Represents an Action Family node object. Properties Name Description all_tabs Return a list of the object tabs. attributes The attributes of a python object. cursor_position Return a tuple that provides the cursor position in the Action/Image/GMaskTracer schematic. input_sockets Return a list of the node input sockets names. left_tabs Return a list of the object left tabs. media_layers Return a list of the Media layers of the Action/Image/GMaskTracer node. node_types Return a list of the node types available in the Action/Image/GMaskTracer schematic. nodes Return a list of Action/Image/GMaskTracer nodes used in the the Action/Image/GMaskTracer schematic. output_sockets Return a list of the node output sockets names. parent The parent object of this object. right_tabs Return a list of the object right tabs. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic clear_schematic clear_schematic( (PyActionFamilyNode)arg1) -> bool : Clear the Action/Image/GMaskTracer schematic of all nodes. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. connect_nodes connect_nodes connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Connect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) create_node create_node create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic. Keyword argument: file_path -- Required by nodes that load an asset, such as Matchbox. input_colour_space -- Optional for nodes that load external media, such as IBL. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. disconnect_nodes disconnect_nodes disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Disconnect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. encompass_nodes encompass_nodes encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : Create a compass including the node list given as argument Keyword argument: node_list -- a list of nodes (either string or node objects) output_type -- the created compass node get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. get_node get_node get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : Get a node by node name. Doesn't select it in the UI. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. organize organize organize( (PyActionFamilyNode)arg1) -> bool : Clean up the Action/Image/GMaskTracer schematic. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyActionFamilyNode"},{"location":"api/classes/PyActionFamilyNode/#class-pyactionfamilynode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyActionFamilyNode"},{"location":"api/classes/PyActionFamilyNode/#description","text":"Class derived from PyNode. Represents an Action Family node object.","title":"Description"},{"location":"api/classes/PyActionFamilyNode/#properties","text":"Name Description all_tabs Return a list of the object tabs. attributes The attributes of a python object. cursor_position Return a tuple that provides the cursor position in the Action/Image/GMaskTracer schematic. input_sockets Return a list of the node input sockets names. left_tabs Return a list of the object left tabs. media_layers Return a list of the Media layers of the Action/Image/GMaskTracer node. node_types Return a list of the node types available in the Action/Image/GMaskTracer schematic. nodes Return a list of Action/Image/GMaskTracer nodes used in the the Action/Image/GMaskTracer schematic. output_sockets Return a list of the node output sockets names. parent The parent object of this object. right_tabs Return a list of the object right tabs. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyActionFamilyNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyActionFamilyNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyActionFamilyNode/#clear_schematic","text":"clear_schematic clear_schematic( (PyActionFamilyNode)arg1) -> bool : Clear the Action/Image/GMaskTracer schematic of all nodes.","title":"clear_schematic"},{"location":"api/classes/PyActionFamilyNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyActionFamilyNode/#connect_nodes","text":"connect_nodes connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Connect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"connect_nodes"},{"location":"api/classes/PyActionFamilyNode/#create_node","text":"create_node create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic. Keyword argument: file_path -- Required by nodes that load an asset, such as Matchbox. input_colour_space -- Optional for nodes that load external media, such as IBL.","title":"create_node"},{"location":"api/classes/PyActionFamilyNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyActionFamilyNode/#disconnect_nodes","text":"disconnect_nodes disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Disconnect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"disconnect_nodes"},{"location":"api/classes/PyActionFamilyNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyActionFamilyNode/#encompass_nodes","text":"encompass_nodes encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : Create a compass including the node list given as argument Keyword argument: node_list -- a list of nodes (either string or node objects) output_type -- the created compass node","title":"encompass_nodes"},{"location":"api/classes/PyActionFamilyNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyActionFamilyNode/#get_node","text":"get_node get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : Get a node by node name. Doesn't select it in the UI.","title":"get_node"},{"location":"api/classes/PyActionFamilyNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyActionFamilyNode/#organize","text":"organize organize( (PyActionFamilyNode)arg1) -> bool : Clean up the Action/Image/GMaskTracer schematic.","title":"organize"},{"location":"api/classes/PyActionFamilyNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyActionFamilyNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyActionFamilyNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyActionNode/","text":"Class: PyActionNode Module : flame Inherits from : PyActionFamilyNode , PyNode , PyFlameObject , instance, object Description Class derived from PyActionFamilyNode. Represents an Action node object. Properties Name Description all_tabs Return a list of the object tabs. attributes The attributes of a python object. cursor_position Return a tuple that provides the cursor position in the Action/Image/GMaskTracer schematic. input_sockets Return a list of the node input sockets names. left_tabs Return a list of the object left tabs. media_layers Return a list of the Media layers of the Action/Image/GMaskTracer node. media_nodes Return a list of the Media nodes attached to the Action node. node_types Return a list of the node types available in the Action/Image/GMaskTracer schematic. nodes Return a list of Action/Image/GMaskTracer nodes used in the the Action/Image/GMaskTracer schematic. output_sockets Return a list of the node output sockets names. output_types Return a list of the output types available to the Action node. parent The parent object of this object. right_tabs Return a list of the object right tabs. sockets Return a dictionary of the input/output sockets names and their connections. Methods add_media add_media add_media( (PyActionFamilyNode)arg1) -> object : Add a Media layer to the Batch Action node. Also instantiates a matching Surface node (and Axis) in the Action node schematic. cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic clear_schematic clear_schematic( (PyActionFamilyNode)arg1) -> bool : Clear the Action/Image/GMaskTracer schematic of all nodes. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. connect_nodes connect_nodes connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Connect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) create_node create_node create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic. Keyword argument: file_path -- Required by nodes that load an asset, such as Matchbox. input_colour_space -- Optional for nodes that load external media, such as IBL. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. disable_output disable_output disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Disable the render output_type for the Action node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectors Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth) disconnect_nodes disconnect_nodes disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Disconnect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. enable_output enable_output enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Enable the render output_type for the Action node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectoars Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth) encompass_nodes encompass_nodes encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : Create a compass including the node list given as argument Keyword argument: node_list -- a list of nodes (either string or node objects) output_type -- the created compass node export_fbx export_fbx export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : Export Action nodes to an FBX file. Keyword argument: file_path -- Path to the output FBX file. Mandatory. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. get_node get_node get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : Get a node by node name. Doesn't select it in the UI. import_abc import_abc import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : Import an Alembic (ABC) file into the Action schematic using the Action Objects mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. import_fbx import_fbx import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : Import an FBX file into the Action schematic using the Action Objects mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. import_psd import_psd import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : Import a PSD file into the Action schematic. Keyword arguments: file_path -- Path to the PSD file. Mandatory. input_colour_space -- The colour space used as input. Optional. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. organize organize organize( (PyActionFamilyNode)arg1) -> bool : Clean up the Action/Image/GMaskTracer schematic. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. read_abc read_abc read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : Import an Alembic (ABC) file into the Action schematic using the Read File mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. read_fbx read_fbx read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : Import an FBX file into the Action schematic using the Read File mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyActionNode"},{"location":"api/classes/PyActionNode/#class-pyactionnode","text":"Module : flame Inherits from : PyActionFamilyNode , PyNode , PyFlameObject , instance, object","title":"Class: PyActionNode"},{"location":"api/classes/PyActionNode/#description","text":"Class derived from PyActionFamilyNode. Represents an Action node object.","title":"Description"},{"location":"api/classes/PyActionNode/#properties","text":"Name Description all_tabs Return a list of the object tabs. attributes The attributes of a python object. cursor_position Return a tuple that provides the cursor position in the Action/Image/GMaskTracer schematic. input_sockets Return a list of the node input sockets names. left_tabs Return a list of the object left tabs. media_layers Return a list of the Media layers of the Action/Image/GMaskTracer node. media_nodes Return a list of the Media nodes attached to the Action node. node_types Return a list of the node types available in the Action/Image/GMaskTracer schematic. nodes Return a list of Action/Image/GMaskTracer nodes used in the the Action/Image/GMaskTracer schematic. output_sockets Return a list of the node output sockets names. output_types Return a list of the output types available to the Action node. parent The parent object of this object. right_tabs Return a list of the object right tabs. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyActionNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyActionNode/#add_media","text":"add_media add_media( (PyActionFamilyNode)arg1) -> object : Add a Media layer to the Batch Action node. Also instantiates a matching Surface node (and Axis) in the Action node schematic.","title":"add_media"},{"location":"api/classes/PyActionNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyActionNode/#clear_schematic","text":"clear_schematic clear_schematic( (PyActionFamilyNode)arg1) -> bool : Clear the Action/Image/GMaskTracer schematic of all nodes.","title":"clear_schematic"},{"location":"api/classes/PyActionNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyActionNode/#connect_nodes","text":"connect_nodes connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Connect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"connect_nodes"},{"location":"api/classes/PyActionNode/#create_node","text":"create_node create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic. Keyword argument: file_path -- Required by nodes that load an asset, such as Matchbox. input_colour_space -- Optional for nodes that load external media, such as IBL.","title":"create_node"},{"location":"api/classes/PyActionNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyActionNode/#disable_output","text":"disable_output disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Disable the render output_type for the Action node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectors Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)","title":"disable_output"},{"location":"api/classes/PyActionNode/#disconnect_nodes","text":"disconnect_nodes disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Disconnect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"disconnect_nodes"},{"location":"api/classes/PyActionNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyActionNode/#enable_output","text":"enable_output enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Enable the render output_type for the Action node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectoars Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)","title":"enable_output"},{"location":"api/classes/PyActionNode/#encompass_nodes","text":"encompass_nodes encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : Create a compass including the node list given as argument Keyword argument: node_list -- a list of nodes (either string or node objects) output_type -- the created compass node","title":"encompass_nodes"},{"location":"api/classes/PyActionNode/#export_fbx","text":"export_fbx export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : Export Action nodes to an FBX file. Keyword argument: file_path -- Path to the output FBX file. Mandatory.","title":"export_fbx"},{"location":"api/classes/PyActionNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyActionNode/#get_node","text":"get_node get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : Get a node by node name. Doesn't select it in the UI.","title":"get_node"},{"location":"api/classes/PyActionNode/#import_abc","text":"import_abc import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : Import an Alembic (ABC) file into the Action schematic using the Action Objects mode. Keyword argument: file_path -- Path to the ABC file. Mandatory.","title":"import_abc"},{"location":"api/classes/PyActionNode/#import_fbx","text":"import_fbx import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : Import an FBX file into the Action schematic using the Action Objects mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional.","title":"import_fbx"},{"location":"api/classes/PyActionNode/#import_psd","text":"import_psd import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : Import a PSD file into the Action schematic. Keyword arguments: file_path -- Path to the PSD file. Mandatory. input_colour_space -- The colour space used as input. Optional.","title":"import_psd"},{"location":"api/classes/PyActionNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyActionNode/#organize","text":"organize organize( (PyActionFamilyNode)arg1) -> bool : Clean up the Action/Image/GMaskTracer schematic.","title":"organize"},{"location":"api/classes/PyActionNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyActionNode/#read_abc","text":"read_abc read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : Import an Alembic (ABC) file into the Action schematic using the Read File mode. Keyword argument: file_path -- Path to the ABC file. Mandatory.","title":"read_abc"},{"location":"api/classes/PyActionNode/#read_fbx","text":"read_fbx read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : Import an FBX file into the Action schematic using the Read File mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional.","title":"read_fbx"},{"location":"api/classes/PyActionNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyActionNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyArchiveEntry/","text":"Class: PyArchiveEntry Module : flame Inherits from : PyFlameObject , instance, object Description Class derived from PyFlameObject. Base class for any object displayed in the Media Panel. Properties Name Description attributes The attributes of a python object. parent The parent object of this object. Methods clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"Class: PyArchiveEntry"},{"location":"api/classes/PyArchiveEntry/#class-pyarchiveentry","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyArchiveEntry"},{"location":"api/classes/PyArchiveEntry/#description","text":"Class derived from PyFlameObject. Base class for any object displayed in the Media Panel.","title":"Description"},{"location":"api/classes/PyArchiveEntry/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object.","title":"Properties"},{"location":"api/classes/PyArchiveEntry/#methods","text":"","title":"Methods"},{"location":"api/classes/PyArchiveEntry/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyArchiveEntry/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyArchiveEntry/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyArchiveEntry/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyAttribute/","text":"Class: PyAttribute Module : flame","title":"Class: PyAttribute"},{"location":"api/classes/PyAttribute/#class-pyattribute","text":"Module : flame","title":"Class: PyAttribute"},{"location":"api/classes/PyAudioTrack/","text":"Class: PyAudioTrack Module : flame Inherits from : PyFlameObject , instance, object Description Object representing an Audio Track. Properties Name Description attributes The attributes of a python object. channels Return a list of the Audio Track's channels. parent The parent object of this object. stereo Return whether or not the Audio Track is stereo. Methods copy_to_media_panel copy_to_media_panel copy_to_media_panel( (PyAudioTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject.","title":"Class: PyAudioTrack"},{"location":"api/classes/PyAudioTrack/#class-pyaudiotrack","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyAudioTrack"},{"location":"api/classes/PyAudioTrack/#description","text":"Object representing an Audio Track.","title":"Description"},{"location":"api/classes/PyAudioTrack/#properties","text":"Name Description attributes The attributes of a python object. channels Return a list of the Audio Track's channels. parent The parent object of this object. stereo Return whether or not the Audio Track is stereo.","title":"Properties"},{"location":"api/classes/PyAudioTrack/#methods","text":"","title":"Methods"},{"location":"api/classes/PyAudioTrack/#copy_to_media_panel","text":"copy_to_media_panel copy_to_media_panel( (PyAudioTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject.","title":"copy_to_media_panel"},{"location":"api/classes/PyBatch/","text":"Class: PyBatch Module : flame Inherits from : PyFlameObject , instance, object Description Class derived from PyFlameObject. This class represents a Batch Group. Properties Name Description attributes The attributes of a python object. batch_iterations Return a list of Batch Iteration objects of the Batch Group. contexts Return a dictionary of Context views registered in the Batch Group. Dictionary {key:value} -- {Context ID : {Batch node name:socket name} } current_iteration Return the current Batch Iteration object of the Batch Group. current_iteration_number Return the iteration number of the current Batch Iteration. cursor_position Return a tuple that provides the cursor position in the Batch Schematic. node_types Return a list of the names of the Batch node types available to the Batch schematic. nodes Return the list of Batch node objects from the Batch schematic. opened Return True if the Batch Group is loaded in memory. parent The parent object of this object. reels Return the list of reel objects (as Schematic Reels) for the Batch Group. shelf_reels Return the list of reel objects (as Shelf Reels) for the Batch Group. Methods append_setup append_setup append_setup( (PyBatch)arg1, (str)setup_path [, (bool)confirm=True]) -> bool : Append a Batch setup file to the existing Batch setup. Keywords arguments: setup_path -- A path and a filename must be defined as arguments. confirm -- Set to True (default) to display a dialogue box in case of append_to_batch append_to_batch append_to_batch( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : Append a Batch Iteration object to the current Batch Group. A duplicate Batch Iteration object is renamed to the next available *vDD*. Batch Iteration objects are displayed in the Iterations folder. Iterations folder is a UI construction, not accessible directly. append_to_setup append_to_setup append_to_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : Append a Batch Iteration object to the Batch Group's setup. clear clear clear( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : Clear the Batch Group. clear_all_contexts clear_all_contexts clear_all_contexts( (PyBatch)arg1) -> bool : Clear all registered Context views in the Batch Group. clear_colour clear_colour clear_colour( (PyBatch)arg1) -> None : Clear the colour of an object in the Media Panel. clear_context clear_context clear_context( (PyBatch)arg1, (int)index) -> bool : Clear a specific Context view in the Batch Group. clear_setup clear_setup clear_setup( (PyBatch)arg1) -> bool : Clear the Batch Group's setup. close close close( (PyBatch)arg1) -> bool : Close the Batch Group. You cannot close the Batch Group currently selected. Closing a Batch Group frees up the application it occupies when open. The size of the used memory is significant if in Batch Group schematic hosts many Action nodes with textures or 3D geoms. connect_nodes connect_nodes connect_nodes( (PyBatch)arg1, (PyNode)output_node, (str)output_socket_name='Default', (PyNode)input_node [, (str)input_socket_name='Default']) -> bool : Connect two nodes in the Batch schematic. Keyword arguments: output_node -- The Batch node object, the origin of the connection. output_socket_name -- The name of the output socket where the connector starts; use *Default* to use the first output socket, usually *Result*. input_node -- The child Batch node object, the target of the connection. input_socket_name -- The name of the input socket where the connector ends; use *Default* to use the first input socket, usually *Front*. Using *Default* on an Action node connects to the Background socket. To connect to an Action media node, use <ActionNode>.media_nodes[]. create_batch_group create_batch_group create_batch_group( (PyBatch)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : Create a new Batch Group object in the Desktop catalogue. Keyword arguments: name -- Name of the Batch Group. nb_reels -- Number of reels created. *reels* overrides *nb_reels*. nb_shelf_reels -- Number of shelf reels. The first shelf reel created is named Batch Renders. *shelf_reels* ovverides *nb_shelf_reels*. reels -- A list of reel names. Overrides *nb_reels*. shelf_reels -- A list of shelf reel names. Overrides *nb_shelf_reels*. start_frame -- The Batch Group's start frame. No timecodes, only a frame value. duration -- The number of frames. Sets the Duration field in the Batch UI. Will be set to the first clip duration when not specified. create_node create_node create_node( (PyBatch)arg1, (str)node_type [, (str)file_path='']) -> object : Create a Batch node object in the Batch schematic. Keyword argument: node_type -- Must be a value from the PyBatch.node_types or the name of a node in the User, Project, or Shared bin. create_reel create_reel create_reel( (PyBatch)arg1, (str)name) -> object : Create a new Schematic Reel in the Batch Gtroup. create_shelf_reel create_shelf_reel create_shelf_reel( (PyBatch)arg1, (str)name) -> object : Create a new Shelf Reel in the Batch Group. disconnect_node disconnect_node disconnect_node( (PyBatch)arg1, (PyNode)node [, (str)input_socket_name='']) -> bool : Disconnect the input links of a given node, given an input socket. Keyword arguments: node -- The Batch node object, the origin of the connection. input_socket_name -- The name of the input socket to disconnect. encompass_nodes encompass_nodes encompass_nodes( (PyBatch)arg1, (list)nodes) -> object : Create a Compass around a list of nodes in the Batch schematic. Keyword argument: nodes -- List of strings of node names. frame_all frame_all frame_all( (PyBatch)arg1) -> bool : Set the Batch schematic view to frame all the nodes in the Batch schematic. frame_selected frame_selected frame_selected( (PyBatch)arg1) -> bool : Set the Batch schematic view to frame the nodes selected in the Batch schematic. get_node get_node get_node( (PyBatch)arg1, (str)node_name) -> object : Return a Batch node object with a name matching the parameter. Every node in a Batch schematic has a unique name: no duplicates allowed. Keyword argument: node_name -- Node name. go_to go_to go_to( (PyBatch)arg1) -> bool : Display and set the Batch tab as the active environment. import_clip import_clip import_clip( (PyBatch)arg1, (str)file_path, (str)reel_name) -> object : Import a clip using the Import node, and create a Clip node. Keyword arguments: file_path -- The path to the media can be: - A path to a single media file. - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). - A pattern to media files (ie \"/dir/name_v{version}.{frame}.{extension}\").reel_name -- The name of the destination Schematic Reel. import_clips import_clips import_clips( (PyBatch)arg1, (object)file_paths, (str)reel_name) -> object : Import clips using the Import node, and then create Clip nodes in the Schematic Reel. Keyword arguments: file_paths -- A path, or a list of paths, to the media that can be: - A path to a single media file. - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). - A pattern to media files (ie \"/dir/name_v{version}.{frame}.{extension}\").reel_name -- The name of the destination Schematic Reel. iterate iterate iterate( (PyBatch)arg1 [, (int)index=-1]) -> object : Iterate the current Batch Setup, creating a new iteration named BatchSetupName_X, where X is the Batch Iteration's index, and starts at 001. Keyword argument: index -- Specifies the iteration's index. If none is specified, the iteration is assigned the next available index (max index + 1). If the index matches that of an existing Batch Iteration, its overwrites the iteration without warning. load_setup load_setup load_setup( (PyBatch)arg1, (str)setup_path) -> bool : Load a Batch setup from disk and replace the current Batch Group's setup. Keyword argument: setup_path -- Filepath + Batch Setup filename. mimic_link mimic_link mimic_link( (PyBatch)arg1, (PyNode)leader_node, (PyNode)follower_node) -> bool : Create a Mimic Link between two Batch nodes. They must be of the same node_type. Keyword arguments: leader_node -- The node being mimicked. follower_node -- The node doing the mimicking. open open open( (PyBatch)arg1) -> bool : Open the Batch Group and display it in the Batch view. open_as_batch_group open_as_batch_group open_as_batch_group( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : Open a Batch Group as a new Batch Group, adding it to PyDesktop.batch_groups. Can only be called from a Library. organize organize organize( (PyBatch)arg1) -> bool : Clean up the nodes layout in the Batch schematic. render render render( (PyBatch)arg1 [, (str)render_option='Foreground' [, (bool)generate_proxies=False [, (bool)include_history=False]]]) -> bool : Trigger the rendering of the Batch Group setup. Every active Render and Write File nodes render. If specified render_option is not supported by the workstation, returns an error. Keyword arguments: render_option -- Defines the rendering method used. (Foreground, Background Reactor, Burn) generate_proxies -- Set to True to render at proxy resolution. (Default: False) include_history -- Set to True to create History with the rendering. (Default:False) replace_setup replace_setup replace_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration [, (bool)confirm=True]) -> bool : Replace the Batch Group setup with the specified Batch Iteration. Cannot be called on the Batch Group currently selected and displayed in the Batch view. save save save( (PyBatch)arg1) -> object : Save the Batch Group to the location defined by PyDesktop.destination. save_current_iteration save_current_iteration save_current_iteration( (PyBatch)arg1) -> object : Save the current Batch Group setup to the location defined by PyDesktop.destination. save_setup save_setup save_setup( (PyBatch)arg1, (str)setup_path) -> bool : Save the Batch Group setup to disk. Includes media paths for clip node object, but not the media files themselves. Keyword argument: setup_path -- The filepath includes the filename. File extension must be .batch. select_nodes select_nodes select_nodes( (PyBatch)arg1, (object)nodes) -> bool : Select nodes. Keyword argument: nodes -- A list of the names of Batch node objects. set_viewport_layout set_viewport_layout set_viewport_layout( (PyBatch)arg1, (object)num_views) -> bool : Set the viewport layout for Batch. Keyword argument: num_views -- The layout used. (1-Up, 2-Up, 3-Up, 3-Up Split Top, 3-Up Split Left, 3-Up Split Right, 3-Up Split Bottom, 4-Up Split, 4-Up)","title":"Class: PyBatch"},{"location":"api/classes/PyBatch/#class-pybatch","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyBatch"},{"location":"api/classes/PyBatch/#description","text":"Class derived from PyFlameObject. This class represents a Batch Group.","title":"Description"},{"location":"api/classes/PyBatch/#properties","text":"Name Description attributes The attributes of a python object. batch_iterations Return a list of Batch Iteration objects of the Batch Group. contexts Return a dictionary of Context views registered in the Batch Group. Dictionary {key:value} -- {Context ID : {Batch node name:socket name} } current_iteration Return the current Batch Iteration object of the Batch Group. current_iteration_number Return the iteration number of the current Batch Iteration. cursor_position Return a tuple that provides the cursor position in the Batch Schematic. node_types Return a list of the names of the Batch node types available to the Batch schematic. nodes Return the list of Batch node objects from the Batch schematic. opened Return True if the Batch Group is loaded in memory. parent The parent object of this object. reels Return the list of reel objects (as Schematic Reels) for the Batch Group. shelf_reels Return the list of reel objects (as Shelf Reels) for the Batch Group.","title":"Properties"},{"location":"api/classes/PyBatch/#methods","text":"","title":"Methods"},{"location":"api/classes/PyBatch/#append_setup","text":"append_setup append_setup( (PyBatch)arg1, (str)setup_path [, (bool)confirm=True]) -> bool : Append a Batch setup file to the existing Batch setup. Keywords arguments: setup_path -- A path and a filename must be defined as arguments. confirm -- Set to True (default) to display a dialogue box in case of","title":"append_setup"},{"location":"api/classes/PyBatch/#append_to_batch","text":"append_to_batch append_to_batch( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : Append a Batch Iteration object to the current Batch Group. A duplicate Batch Iteration object is renamed to the next available *vDD*. Batch Iteration objects are displayed in the Iterations folder. Iterations folder is a UI construction, not accessible directly.","title":"append_to_batch"},{"location":"api/classes/PyBatch/#append_to_setup","text":"append_to_setup append_to_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : Append a Batch Iteration object to the Batch Group's setup.","title":"append_to_setup"},{"location":"api/classes/PyBatch/#clear","text":"clear clear( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : Clear the Batch Group.","title":"clear"},{"location":"api/classes/PyBatch/#clear_all_contexts","text":"clear_all_contexts clear_all_contexts( (PyBatch)arg1) -> bool : Clear all registered Context views in the Batch Group.","title":"clear_all_contexts"},{"location":"api/classes/PyBatch/#clear_colour","text":"clear_colour clear_colour( (PyBatch)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyBatch/#clear_context","text":"clear_context clear_context( (PyBatch)arg1, (int)index) -> bool : Clear a specific Context view in the Batch Group.","title":"clear_context"},{"location":"api/classes/PyBatch/#clear_setup","text":"clear_setup clear_setup( (PyBatch)arg1) -> bool : Clear the Batch Group's setup.","title":"clear_setup"},{"location":"api/classes/PyBatch/#close","text":"close close( (PyBatch)arg1) -> bool : Close the Batch Group. You cannot close the Batch Group currently selected. Closing a Batch Group frees up the application it occupies when open. The size of the used memory is significant if in Batch Group schematic hosts many Action nodes with textures or 3D geoms.","title":"close"},{"location":"api/classes/PyBatch/#connect_nodes","text":"connect_nodes connect_nodes( (PyBatch)arg1, (PyNode)output_node, (str)output_socket_name='Default', (PyNode)input_node [, (str)input_socket_name='Default']) -> bool : Connect two nodes in the Batch schematic. Keyword arguments: output_node -- The Batch node object, the origin of the connection. output_socket_name -- The name of the output socket where the connector starts; use *Default* to use the first output socket, usually *Result*. input_node -- The child Batch node object, the target of the connection. input_socket_name -- The name of the input socket where the connector ends; use *Default* to use the first input socket, usually *Front*. Using *Default* on an Action node connects to the Background socket. To connect to an Action media node, use <ActionNode>.media_nodes[].","title":"connect_nodes"},{"location":"api/classes/PyBatch/#create_batch_group","text":"create_batch_group create_batch_group( (PyBatch)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : Create a new Batch Group object in the Desktop catalogue. Keyword arguments: name -- Name of the Batch Group. nb_reels -- Number of reels created. *reels* overrides *nb_reels*. nb_shelf_reels -- Number of shelf reels. The first shelf reel created is named Batch Renders. *shelf_reels* ovverides *nb_shelf_reels*. reels -- A list of reel names. Overrides *nb_reels*. shelf_reels -- A list of shelf reel names. Overrides *nb_shelf_reels*. start_frame -- The Batch Group's start frame. No timecodes, only a frame value. duration -- The number of frames. Sets the Duration field in the Batch UI. Will be set to the first clip duration when not specified.","title":"create_batch_group"},{"location":"api/classes/PyBatch/#create_node","text":"create_node create_node( (PyBatch)arg1, (str)node_type [, (str)file_path='']) -> object : Create a Batch node object in the Batch schematic. Keyword argument: node_type -- Must be a value from the PyBatch.node_types or the name of a node in the User, Project, or Shared bin.","title":"create_node"},{"location":"api/classes/PyBatch/#create_reel","text":"create_reel create_reel( (PyBatch)arg1, (str)name) -> object : Create a new Schematic Reel in the Batch Gtroup.","title":"create_reel"},{"location":"api/classes/PyBatch/#create_shelf_reel","text":"create_shelf_reel create_shelf_reel( (PyBatch)arg1, (str)name) -> object : Create a new Shelf Reel in the Batch Group.","title":"create_shelf_reel"},{"location":"api/classes/PyBatch/#disconnect_node","text":"disconnect_node disconnect_node( (PyBatch)arg1, (PyNode)node [, (str)input_socket_name='']) -> bool : Disconnect the input links of a given node, given an input socket. Keyword arguments: node -- The Batch node object, the origin of the connection. input_socket_name -- The name of the input socket to disconnect.","title":"disconnect_node"},{"location":"api/classes/PyBatch/#encompass_nodes","text":"encompass_nodes encompass_nodes( (PyBatch)arg1, (list)nodes) -> object : Create a Compass around a list of nodes in the Batch schematic. Keyword argument: nodes -- List of strings of node names.","title":"encompass_nodes"},{"location":"api/classes/PyBatch/#frame_all","text":"frame_all frame_all( (PyBatch)arg1) -> bool : Set the Batch schematic view to frame all the nodes in the Batch schematic.","title":"frame_all"},{"location":"api/classes/PyBatch/#frame_selected","text":"frame_selected frame_selected( (PyBatch)arg1) -> bool : Set the Batch schematic view to frame the nodes selected in the Batch schematic.","title":"frame_selected"},{"location":"api/classes/PyBatch/#get_node","text":"get_node get_node( (PyBatch)arg1, (str)node_name) -> object : Return a Batch node object with a name matching the parameter. Every node in a Batch schematic has a unique name: no duplicates allowed. Keyword argument: node_name -- Node name.","title":"get_node"},{"location":"api/classes/PyBatch/#go_to","text":"go_to go_to( (PyBatch)arg1) -> bool : Display and set the Batch tab as the active environment.","title":"go_to"},{"location":"api/classes/PyBatch/#import_clip","text":"import_clip import_clip( (PyBatch)arg1, (str)file_path, (str)reel_name) -> object : Import a clip using the Import node, and create a Clip node. Keyword arguments: file_path -- The path to the media can be: - A path to a single media file. - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). - A pattern to media files (ie \"/dir/name_v{version}.{frame}.{extension}\").reel_name -- The name of the destination Schematic Reel.","title":"import_clip"},{"location":"api/classes/PyBatch/#import_clips","text":"import_clips import_clips( (PyBatch)arg1, (object)file_paths, (str)reel_name) -> object : Import clips using the Import node, and then create Clip nodes in the Schematic Reel. Keyword arguments: file_paths -- A path, or a list of paths, to the media that can be: - A path to a single media file. - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). - A pattern to media files (ie \"/dir/name_v{version}.{frame}.{extension}\").reel_name -- The name of the destination Schematic Reel.","title":"import_clips"},{"location":"api/classes/PyBatch/#iterate","text":"iterate iterate( (PyBatch)arg1 [, (int)index=-1]) -> object : Iterate the current Batch Setup, creating a new iteration named BatchSetupName_X, where X is the Batch Iteration's index, and starts at 001. Keyword argument: index -- Specifies the iteration's index. If none is specified, the iteration is assigned the next available index (max index + 1). If the index matches that of an existing Batch Iteration, its overwrites the iteration without warning.","title":"iterate"},{"location":"api/classes/PyBatch/#load_setup","text":"load_setup load_setup( (PyBatch)arg1, (str)setup_path) -> bool : Load a Batch setup from disk and replace the current Batch Group's setup. Keyword argument: setup_path -- Filepath + Batch Setup filename.","title":"load_setup"},{"location":"api/classes/PyBatch/#mimic_link","text":"mimic_link mimic_link( (PyBatch)arg1, (PyNode)leader_node, (PyNode)follower_node) -> bool : Create a Mimic Link between two Batch nodes. They must be of the same node_type. Keyword arguments: leader_node -- The node being mimicked. follower_node -- The node doing the mimicking.","title":"mimic_link"},{"location":"api/classes/PyBatch/#open","text":"open open( (PyBatch)arg1) -> bool : Open the Batch Group and display it in the Batch view.","title":"open"},{"location":"api/classes/PyBatch/#open_as_batch_group","text":"open_as_batch_group open_as_batch_group( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : Open a Batch Group as a new Batch Group, adding it to PyDesktop.batch_groups. Can only be called from a Library.","title":"open_as_batch_group"},{"location":"api/classes/PyBatch/#organize","text":"organize organize( (PyBatch)arg1) -> bool : Clean up the nodes layout in the Batch schematic.","title":"organize"},{"location":"api/classes/PyBatch/#render","text":"render render( (PyBatch)arg1 [, (str)render_option='Foreground' [, (bool)generate_proxies=False [, (bool)include_history=False]]]) -> bool : Trigger the rendering of the Batch Group setup. Every active Render and Write File nodes render. If specified render_option is not supported by the workstation, returns an error. Keyword arguments: render_option -- Defines the rendering method used. (Foreground, Background Reactor, Burn) generate_proxies -- Set to True to render at proxy resolution. (Default: False) include_history -- Set to True to create History with the rendering. (Default:False)","title":"render"},{"location":"api/classes/PyBatch/#replace_setup","text":"replace_setup replace_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration [, (bool)confirm=True]) -> bool : Replace the Batch Group setup with the specified Batch Iteration. Cannot be called on the Batch Group currently selected and displayed in the Batch view.","title":"replace_setup"},{"location":"api/classes/PyBatch/#save","text":"save save( (PyBatch)arg1) -> object : Save the Batch Group to the location defined by PyDesktop.destination.","title":"save"},{"location":"api/classes/PyBatch/#save_current_iteration","text":"save_current_iteration save_current_iteration( (PyBatch)arg1) -> object : Save the current Batch Group setup to the location defined by PyDesktop.destination.","title":"save_current_iteration"},{"location":"api/classes/PyBatch/#save_setup","text":"save_setup save_setup( (PyBatch)arg1, (str)setup_path) -> bool : Save the Batch Group setup to disk. Includes media paths for clip node object, but not the media files themselves. Keyword argument: setup_path -- The filepath includes the filename. File extension must be .batch.","title":"save_setup"},{"location":"api/classes/PyBatch/#select_nodes","text":"select_nodes select_nodes( (PyBatch)arg1, (object)nodes) -> bool : Select nodes. Keyword argument: nodes -- A list of the names of Batch node objects.","title":"select_nodes"},{"location":"api/classes/PyBatch/#set_viewport_layout","text":"set_viewport_layout set_viewport_layout( (PyBatch)arg1, (object)num_views) -> bool : Set the viewport layout for Batch. Keyword argument: num_views -- The layout used. (1-Up, 2-Up, 3-Up, 3-Up Split Top, 3-Up Split Left, 3-Up Split Right, 3-Up Split Bottom, 4-Up Split, 4-Up)","title":"set_viewport_layout"},{"location":"api/classes/PyBatchIteration/","text":"Class: PyBatchIteration Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Class derived from PyArchiveEntry. This class represents a Batch Iteration. Properties Name Description attributes The attributes of a python object. iteration_number Return the iteration number of the Batch Iteration. parent The parent object of this object. Methods clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. open_as_batch_group open_as_batch_group open_as_batch_group( (PyBatchIteration)arg1 [, (bool)confirm=True]) -> bool : Open a Batch Iteration as a new Batch Group, adding it to PyDesktop.batch_groups. Can only be called from a Library.","title":"Class: PyBatchIteration"},{"location":"api/classes/PyBatchIteration/#class-pybatchiteration","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyBatchIteration"},{"location":"api/classes/PyBatchIteration/#description","text":"Class derived from PyArchiveEntry. This class represents a Batch Iteration.","title":"Description"},{"location":"api/classes/PyBatchIteration/#properties","text":"Name Description attributes The attributes of a python object. iteration_number Return the iteration number of the Batch Iteration. parent The parent object of this object.","title":"Properties"},{"location":"api/classes/PyBatchIteration/#methods","text":"","title":"Methods"},{"location":"api/classes/PyBatchIteration/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyBatchIteration/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyBatchIteration/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyBatchIteration/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyBatchIteration/#open_as_batch_group","text":"open_as_batch_group open_as_batch_group( (PyBatchIteration)arg1 [, (bool)confirm=True]) -> bool : Open a Batch Iteration as a new Batch Group, adding it to PyDesktop.batch_groups. Can only be called from a Library.","title":"open_as_batch_group"},{"location":"api/classes/PyBrowser/","text":"Class: PyBrowser Module : flame Inherits from : instance, object Description This class represents the file browser. Properties Name Description bit_depth Return the bit depth. colour_space Return the colour space. frame_ratio Return the frame ratio. Returns None when resolution is set to Same As Source. height Return the height. Returns None when resolution is set to Same As Source. resize_filter Return the resize filter. resize_mode Return the resize mode. resolution Return the name of the resolution preset. scaling_presets_value Return the scaling presets value. Returns None when resolution is not set to Scaling Presets. scan_mode Return the scan mode. selection Get the selected files/directories. sequence_mode Return the sequence mode. width Return the width. Returns None when resolution is set to Same As Source. Methods show show show( (PyBrowser)arg1, (str)default_path [, (object)extension='' [, (bool)select_directory=False [, (bool)multi_selection=False [, (object)include_resolution=False [, (str)title='Load']]]]]) -> None : Show the file browser.Keyword arguments: default_path -- Set the path. extension -- Set the extension filter. Can be a single extension or a list of extensions.Leave empty to see all files. select_directory -- Only show directories. multi_selection -- Allow the user to select multiple files. include_resolution -- Display the resolution controls. Possible values are False, True, or \"Full\". The Full mode includes the new adaptive and scaling presets modes. title -- Set the window title.","title":"Class: PyBrowser"},{"location":"api/classes/PyBrowser/#class-pybrowser","text":"Module : flame Inherits from : instance, object","title":"Class: PyBrowser"},{"location":"api/classes/PyBrowser/#description","text":"This class represents the file browser.","title":"Description"},{"location":"api/classes/PyBrowser/#properties","text":"Name Description bit_depth Return the bit depth. colour_space Return the colour space. frame_ratio Return the frame ratio. Returns None when resolution is set to Same As Source. height Return the height. Returns None when resolution is set to Same As Source. resize_filter Return the resize filter. resize_mode Return the resize mode. resolution Return the name of the resolution preset. scaling_presets_value Return the scaling presets value. Returns None when resolution is not set to Scaling Presets. scan_mode Return the scan mode. selection Get the selected files/directories. sequence_mode Return the sequence mode. width Return the width. Returns None when resolution is set to Same As Source.","title":"Properties"},{"location":"api/classes/PyBrowser/#methods","text":"","title":"Methods"},{"location":"api/classes/PyBrowser/#show","text":"show show( (PyBrowser)arg1, (str)default_path [, (object)extension='' [, (bool)select_directory=False [, (bool)multi_selection=False [, (object)include_resolution=False [, (str)title='Load']]]]]) -> None : Show the file browser.Keyword arguments: default_path -- Set the path. extension -- Set the extension filter. Can be a single extension or a list of extensions.Leave empty to see all files. select_directory -- Only show directories. multi_selection -- Allow the user to select multiple files. include_resolution -- Display the resolution controls. Possible values are False, True, or \"Full\". The Full mode includes the new adaptive and scaling presets modes. title -- Set the window title.","title":"show"},{"location":"api/classes/PyClip/","text":"Class: PyClip Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description CLass derived from PyArchiveEntry. This class represents a Clip. Properties Name Description archive_date Return the Clip's last archive date. archive_error Return the Clip's last archive error. attributes The attributes of a python object. audio_tracks Return a list of the Clip's Audio Tracks. bit_depth Return the Clip's bit depth. cached Return the Clip's cache status. colour_primaries Deduce the Clip's 'colour primaries' export attribute. creation_date Return the Clip's creation date. duration Return the Clip's duration. essence_uid Return the Clip's essence uid. frame_rate Return the Clip's frame rate. has_deliverables Return the existence of deliverables on the Clip. has_history Return the existence of history inside the Clip. height Return the Clip's height. markers Return a list of the Clip's Markers. matrix_coefficients Deduce the Clip's 'matrix coefficients' export attribute. original_source_uid Return the Clip's original source UID. parent The parent object of this object. proxy_resolution Return the Clip's proxy resolution if it has proxies. ratio Return the Clip's frame ratio. sample_rate Return the Clip's audio sample rate. scan_mode Return the Clip's scan mode. source_uid Return the Clip's source uid. start_frame Return the Clip's start frame. subtitles Return a list of the Clip's Subtitles Tracks. transfer_characteristics Deduce the Clip's 'transfer characteristics' export attribute. unlinked Return the Clip's unlinked status. versions Return a list of the Clip's versions. width Return the Clip's width. Methods cache_media cache_media cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Cache the Clip's linked media. Keyword argument: mode -- Determine the version to cache (currently selected or all versions). All Versions is only useful with to multi-version clips (Current, All Versions) change_dominance change_dominance change_dominance( (PyClip)arg1, (str)scan_mode) -> None : Change the Clip's dominance. Changes only the clip's metadata. Keyword argument: scan_mode -- Field dominance. (P, F1, F2) change_start_frame change_start_frame change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : Modify the start frame of a source Clip. Keywords argument: start_frame -- New start frame of the clip. use_segment_connections -- Sync the start frame of connected segments. clear_cache_media clear_cache_media clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current) clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. clear_renders clear_renders clear_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders. close_container close_container close_container( (PyClip)arg1) -> None : Close the container timeline if the Clip is inside a container. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. create_marker create_marker create_marker( (PyClip)arg1, (object)location) -> object : Add a Marker to the Clip.Keyword argument: location -- The frame where the marker gets created. cut cut cut( (PyClip)arg1, (PyTime)cut_time) -> None : Cut all tracks of the Clip. flush_cache_media flush_cache_media flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current)(Deprecated: use 'clear_cache_media' instead.) flush_renders flush_renders flush_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders.(Deprecated: use 'clear_renders' instead.) get_colour_space get_colour_space get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str : Return the colour space at the requested time. Use current_time when no time is supplied. get_metadata get_metadata get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : Return the metadata of the clip. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. time -- Must be a PyTime. If not specified, the current clip time is used. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. is_rendered is_rendered is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool : Return if a Clip is rendered. The following attributes can be defined: top_only, render_quality. open_as_sequence open_as_sequence open_as_sequence( (PyClip)arg1) -> object : Open the Clip as a Sequence. Mutates the PyClip object into a PySequence object. open_container open_container open_container( (PyClip)arg1) -> bool : Open the container timeline if the Clip is inside a container. reformat reformat reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None : Reformat the Clip to the specified format. Keywords arguments: width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. bit_depth -- Bit depth. (8, 10, 12, 16 or 32) scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) resize_mode -- Resize mode. (Letterbox, Crop Edges, Fill, Centre) render render render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool : Trigger a render of the Clip The following attributes can be defined: render_mode, render_option, render_quality, effect_type, effect_caching_mode and include_handles. save save save( (PyClip)arg1) -> bool : Save the Clip to the defined save destination.","title":"Class: PyClip"},{"location":"api/classes/PyClip/#class-pyclip","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyClip"},{"location":"api/classes/PyClip/#description","text":"CLass derived from PyArchiveEntry. This class represents a Clip.","title":"Description"},{"location":"api/classes/PyClip/#properties","text":"Name Description archive_date Return the Clip's last archive date. archive_error Return the Clip's last archive error. attributes The attributes of a python object. audio_tracks Return a list of the Clip's Audio Tracks. bit_depth Return the Clip's bit depth. cached Return the Clip's cache status. colour_primaries Deduce the Clip's 'colour primaries' export attribute. creation_date Return the Clip's creation date. duration Return the Clip's duration. essence_uid Return the Clip's essence uid. frame_rate Return the Clip's frame rate. has_deliverables Return the existence of deliverables on the Clip. has_history Return the existence of history inside the Clip. height Return the Clip's height. markers Return a list of the Clip's Markers. matrix_coefficients Deduce the Clip's 'matrix coefficients' export attribute. original_source_uid Return the Clip's original source UID. parent The parent object of this object. proxy_resolution Return the Clip's proxy resolution if it has proxies. ratio Return the Clip's frame ratio. sample_rate Return the Clip's audio sample rate. scan_mode Return the Clip's scan mode. source_uid Return the Clip's source uid. start_frame Return the Clip's start frame. subtitles Return a list of the Clip's Subtitles Tracks. transfer_characteristics Deduce the Clip's 'transfer characteristics' export attribute. unlinked Return the Clip's unlinked status. versions Return a list of the Clip's versions. width Return the Clip's width.","title":"Properties"},{"location":"api/classes/PyClip/#methods","text":"","title":"Methods"},{"location":"api/classes/PyClip/#cache_media","text":"cache_media cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Cache the Clip's linked media. Keyword argument: mode -- Determine the version to cache (currently selected or all versions). All Versions is only useful with to multi-version clips (Current, All Versions)","title":"cache_media"},{"location":"api/classes/PyClip/#change_dominance","text":"change_dominance change_dominance( (PyClip)arg1, (str)scan_mode) -> None : Change the Clip's dominance. Changes only the clip's metadata. Keyword argument: scan_mode -- Field dominance. (P, F1, F2)","title":"change_dominance"},{"location":"api/classes/PyClip/#change_start_frame","text":"change_start_frame change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : Modify the start frame of a source Clip. Keywords argument: start_frame -- New start frame of the clip. use_segment_connections -- Sync the start frame of connected segments.","title":"change_start_frame"},{"location":"api/classes/PyClip/#clear_cache_media","text":"clear_cache_media clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current)","title":"clear_cache_media"},{"location":"api/classes/PyClip/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyClip/#clear_renders","text":"clear_renders clear_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders.","title":"clear_renders"},{"location":"api/classes/PyClip/#close_container","text":"close_container close_container( (PyClip)arg1) -> None : Close the container timeline if the Clip is inside a container.","title":"close_container"},{"location":"api/classes/PyClip/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyClip/#create_marker","text":"create_marker create_marker( (PyClip)arg1, (object)location) -> object : Add a Marker to the Clip.Keyword argument: location -- The frame where the marker gets created.","title":"create_marker"},{"location":"api/classes/PyClip/#cut","text":"cut cut( (PyClip)arg1, (PyTime)cut_time) -> None : Cut all tracks of the Clip.","title":"cut"},{"location":"api/classes/PyClip/#flush_cache_media","text":"flush_cache_media flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current)(Deprecated: use 'clear_cache_media' instead.)","title":"flush_cache_media"},{"location":"api/classes/PyClip/#flush_renders","text":"flush_renders flush_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders.(Deprecated: use 'clear_renders' instead.)","title":"flush_renders"},{"location":"api/classes/PyClip/#get_colour_space","text":"get_colour_space get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str : Return the colour space at the requested time. Use current_time when no time is supplied.","title":"get_colour_space"},{"location":"api/classes/PyClip/#get_metadata","text":"get_metadata get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : Return the metadata of the clip. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. time -- Must be a PyTime. If not specified, the current clip time is used.","title":"get_metadata"},{"location":"api/classes/PyClip/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyClip/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyClip/#is_rendered","text":"is_rendered is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool : Return if a Clip is rendered. The following attributes can be defined: top_only, render_quality.","title":"is_rendered"},{"location":"api/classes/PyClip/#open_as_sequence","text":"open_as_sequence open_as_sequence( (PyClip)arg1) -> object : Open the Clip as a Sequence. Mutates the PyClip object into a PySequence object.","title":"open_as_sequence"},{"location":"api/classes/PyClip/#open_container","text":"open_container open_container( (PyClip)arg1) -> bool : Open the container timeline if the Clip is inside a container.","title":"open_container"},{"location":"api/classes/PyClip/#reformat","text":"reformat reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None : Reformat the Clip to the specified format. Keywords arguments: width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. bit_depth -- Bit depth. (8, 10, 12, 16 or 32) scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) resize_mode -- Resize mode. (Letterbox, Crop Edges, Fill, Centre)","title":"reformat"},{"location":"api/classes/PyClip/#render","text":"render render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool : Trigger a render of the Clip The following attributes can be defined: render_mode, render_option, render_quality, effect_type, effect_caching_mode and include_handles.","title":"render"},{"location":"api/classes/PyClip/#save","text":"save save( (PyClip)arg1) -> bool : Save the Clip to the defined save destination.","title":"save"},{"location":"api/classes/PyClipNode/","text":"Class: PyClipNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Class derived from PyNode. This class represents a Clip node. Properties Name Description attributes The attributes of a python object. clip The associated PyClip or PySequence of the clip node. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. version_uid The clip node's list of available version unique IDs. version_uids The clip node's list of available version unique IDs. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments. set_metadata_discarded set_metadata_discarded set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key. set_metadata_key set_metadata_key set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value. set_metadata_value set_metadata_value set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. set_version_uid set_version_uid set_version_uid( (PyClipNode)arg1, (str)version_uid) -> bool : Set the clip node's current version unique ID. Keywords argument: version_uid -- version unique ID.","title":"Class: PyClipNode"},{"location":"api/classes/PyClipNode/#class-pyclipnode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyClipNode"},{"location":"api/classes/PyClipNode/#description","text":"Class derived from PyNode. This class represents a Clip node.","title":"Description"},{"location":"api/classes/PyClipNode/#properties","text":"Name Description attributes The attributes of a python object. clip The associated PyClip or PySequence of the clip node. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. version_uid The clip node's list of available version unique IDs. version_uids The clip node's list of available version unique IDs.","title":"Properties"},{"location":"api/classes/PyClipNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyClipNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyClipNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyClipNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyClipNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyClipNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyClipNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyClipNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyClipNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyClipNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyClipNode/#set_metadata_discarded","text":"set_metadata_discarded set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key.","title":"set_metadata_discarded"},{"location":"api/classes/PyClipNode/#set_metadata_key","text":"set_metadata_key set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value.","title":"set_metadata_key"},{"location":"api/classes/PyClipNode/#set_metadata_value","text":"set_metadata_value set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value.","title":"set_metadata_value"},{"location":"api/classes/PyClipNode/#set_version_uid","text":"set_version_uid set_version_uid( (PyClipNode)arg1, (str)version_uid) -> bool : Set the clip node's current version unique ID. Keywords argument: version_uid -- version unique ID.","title":"set_version_uid"},{"location":"api/classes/PyClrMgmtNode/","text":"Class: PyClrMgmtNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Object representing a Colour Mgmt node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_context_variables get_context_variables get_context_variables( (PyClrMgmtNode)arg1) -> dict : Get the context variables in a dictionary. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. import_transform import_transform import_transform( (PyClrMgmtNode)arg1, (str)file_path) -> None : Import a transform from a file. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. reset_context_variables reset_context_variables reset_context_variables( (PyClrMgmtNode)arg1) -> None : Reset the context variables to their initial state from the ocio config. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments. set_context_variable set_context_variable set_context_variable( (PyClrMgmtNode)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable.","title":"Class: PyClrMgmtNode"},{"location":"api/classes/PyClrMgmtNode/#class-pyclrmgmtnode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyClrMgmtNode"},{"location":"api/classes/PyClrMgmtNode/#description","text":"Object representing a Colour Mgmt node.","title":"Description"},{"location":"api/classes/PyClrMgmtNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyClrMgmtNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyClrMgmtNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyClrMgmtNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyClrMgmtNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyClrMgmtNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyClrMgmtNode/#get_context_variables","text":"get_context_variables get_context_variables( (PyClrMgmtNode)arg1) -> dict : Get the context variables in a dictionary.","title":"get_context_variables"},{"location":"api/classes/PyClrMgmtNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyClrMgmtNode/#import_transform","text":"import_transform import_transform( (PyClrMgmtNode)arg1, (str)file_path) -> None : Import a transform from a file.","title":"import_transform"},{"location":"api/classes/PyClrMgmtNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyClrMgmtNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyClrMgmtNode/#reset_context_variables","text":"reset_context_variables reset_context_variables( (PyClrMgmtNode)arg1) -> None : Reset the context variables to their initial state from the ocio config.","title":"reset_context_variables"},{"location":"api/classes/PyClrMgmtNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyClrMgmtNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyClrMgmtNode/#set_context_variable","text":"set_context_variable set_context_variable( (PyClrMgmtNode)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable.","title":"set_context_variable"},{"location":"api/classes/PyCoCameraAnalysis/","text":"Class: PyCoCameraAnalysis Module : flame Inherits from : PyCoNode , PyFlameObject , instance, object Description Class derived from PyCoNode. This class represents the camera analysis node in the Action schematic. Properties Name Description attributes The attributes of a python object. parent The parent object of this object. type Return the type of the Action node. Methods add_reference add_reference add_reference( (PyCoNode)arg1, (object)frame) -> bool : Add a Motion Warp map's reference frame at specified index. Keyword argument frame -- The reference frame's index. An integer. analyseRange analyseRange analyseRange( (PyCoCameraAnalysis)arg1, (object)arg2, (object)start) -> bool : Run the analysis for the given frame range using the first frame as a reference if none has been already set. assign_media assign_media assign_media( (PyCoNode)arg1, (object)media_name) -> bool : Assign a media layer to the node. Keyword argument media_name -- The index of the media layer from Actions' *media_layers*; or the name of the media layer. cache_range cache_range cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : Cache the selected Map Analysis over the specified range. Keyword arguments start -- The first frame of the range. An integer. end -- The last frame of the range. An integer. children children children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the children of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) parents parents parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the parents of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) resetAnalysis resetAnalysis resetAnalysis( (PyCoCameraAnalysis)arg1) -> bool : Reset the current analysis.","title":"Class: PyCoCameraAnalysis"},{"location":"api/classes/PyCoCameraAnalysis/#class-pycocameraanalysis","text":"Module : flame Inherits from : PyCoNode , PyFlameObject , instance, object","title":"Class: PyCoCameraAnalysis"},{"location":"api/classes/PyCoCameraAnalysis/#description","text":"Class derived from PyCoNode. This class represents the camera analysis node in the Action schematic.","title":"Description"},{"location":"api/classes/PyCoCameraAnalysis/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. type Return the type of the Action node.","title":"Properties"},{"location":"api/classes/PyCoCameraAnalysis/#methods","text":"","title":"Methods"},{"location":"api/classes/PyCoCameraAnalysis/#add_reference","text":"add_reference add_reference( (PyCoNode)arg1, (object)frame) -> bool : Add a Motion Warp map's reference frame at specified index. Keyword argument frame -- The reference frame's index. An integer.","title":"add_reference"},{"location":"api/classes/PyCoCameraAnalysis/#analyserange","text":"analyseRange analyseRange( (PyCoCameraAnalysis)arg1, (object)arg2, (object)start) -> bool : Run the analysis for the given frame range using the first frame as a reference if none has been already set.","title":"analyseRange"},{"location":"api/classes/PyCoCameraAnalysis/#assign_media","text":"assign_media assign_media( (PyCoNode)arg1, (object)media_name) -> bool : Assign a media layer to the node. Keyword argument media_name -- The index of the media layer from Actions' *media_layers*; or the name of the media layer.","title":"assign_media"},{"location":"api/classes/PyCoCameraAnalysis/#cache_range","text":"cache_range cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : Cache the selected Map Analysis over the specified range. Keyword arguments start -- The first frame of the range. An integer. end -- The last frame of the range. An integer.","title":"cache_range"},{"location":"api/classes/PyCoCameraAnalysis/#children","text":"children children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the children of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"children"},{"location":"api/classes/PyCoCameraAnalysis/#parents","text":"parents parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the parents of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"parents"},{"location":"api/classes/PyCoCameraAnalysis/#resetanalysis","text":"resetAnalysis resetAnalysis( (PyCoCameraAnalysis)arg1) -> bool : Reset the current analysis.","title":"resetAnalysis"},{"location":"api/classes/PyCoCompass/","text":"Class: PyCoCompass Module : flame Inherits from : PyCoNode , PyFlameObject , instance, object Description Class derived from PyCoNode. This class represents the compass node in the Action schematic. Properties Name Description attributes The attributes of a python object. nodes Return a list of PyCoNode objects enclosed by the Compass node. parent The parent object of this object. type Return the type of the Action node. Methods add_reference add_reference add_reference( (PyCoNode)arg1, (object)frame) -> bool : Add a Motion Warp map's reference frame at specified index. Keyword argument frame -- The reference frame's index. An integer. assign_media assign_media assign_media( (PyCoNode)arg1, (object)media_name) -> bool : Assign a media layer to the node. Keyword argument media_name -- The index of the media layer from Actions' *media_layers*; or the name of the media layer. cache_range cache_range cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : Cache the selected Map Analysis over the specified range. Keyword arguments start -- The first frame of the range. An integer. end -- The last frame of the range. An integer. children children children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the children of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) parents parents parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the parents of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"Class: PyCoCompass"},{"location":"api/classes/PyCoCompass/#class-pycocompass","text":"Module : flame Inherits from : PyCoNode , PyFlameObject , instance, object","title":"Class: PyCoCompass"},{"location":"api/classes/PyCoCompass/#description","text":"Class derived from PyCoNode. This class represents the compass node in the Action schematic.","title":"Description"},{"location":"api/classes/PyCoCompass/#properties","text":"Name Description attributes The attributes of a python object. nodes Return a list of PyCoNode objects enclosed by the Compass node. parent The parent object of this object. type Return the type of the Action node.","title":"Properties"},{"location":"api/classes/PyCoCompass/#methods","text":"","title":"Methods"},{"location":"api/classes/PyCoCompass/#add_reference","text":"add_reference add_reference( (PyCoNode)arg1, (object)frame) -> bool : Add a Motion Warp map's reference frame at specified index. Keyword argument frame -- The reference frame's index. An integer.","title":"add_reference"},{"location":"api/classes/PyCoCompass/#assign_media","text":"assign_media assign_media( (PyCoNode)arg1, (object)media_name) -> bool : Assign a media layer to the node. Keyword argument media_name -- The index of the media layer from Actions' *media_layers*; or the name of the media layer.","title":"assign_media"},{"location":"api/classes/PyCoCompass/#cache_range","text":"cache_range cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : Cache the selected Map Analysis over the specified range. Keyword arguments start -- The first frame of the range. An integer. end -- The last frame of the range. An integer.","title":"cache_range"},{"location":"api/classes/PyCoCompass/#children","text":"children children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the children of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"children"},{"location":"api/classes/PyCoCompass/#parents","text":"parents parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the parents of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"parents"},{"location":"api/classes/PyCoNode/","text":"Class: PyCoNode Module : flame Inherits from : PyFlameObject , instance, object Description Class derived from PyFlameObject. This class represents an Action node in the Action schematic. Properties Name Description attributes The attributes of a python object. parent The parent object of this object. type Return the type of the Action node. Methods add_reference add_reference add_reference( (PyCoNode)arg1, (object)frame) -> bool : Add a Motion Warp map's reference frame at specified index. Keyword argument frame -- The reference frame's index. An integer. assign_media assign_media assign_media( (PyCoNode)arg1, (object)media_name) -> bool : Assign a media layer to the node. Keyword argument media_name -- The index of the media layer from Actions' *media_layers*; or the name of the media layer. cache_range cache_range cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : Cache the selected Map Analysis over the specified range. Keyword arguments start -- The first frame of the range. An integer. end -- The last frame of the range. An integer. children children children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the children of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) parents parents parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the parents of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"Class: PyCoNode"},{"location":"api/classes/PyCoNode/#class-pyconode","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyCoNode"},{"location":"api/classes/PyCoNode/#description","text":"Class derived from PyFlameObject. This class represents an Action node in the Action schematic.","title":"Description"},{"location":"api/classes/PyCoNode/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. type Return the type of the Action node.","title":"Properties"},{"location":"api/classes/PyCoNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyCoNode/#add_reference","text":"add_reference add_reference( (PyCoNode)arg1, (object)frame) -> bool : Add a Motion Warp map's reference frame at specified index. Keyword argument frame -- The reference frame's index. An integer.","title":"add_reference"},{"location":"api/classes/PyCoNode/#assign_media","text":"assign_media assign_media( (PyCoNode)arg1, (object)media_name) -> bool : Assign a media layer to the node. Keyword argument media_name -- The index of the media layer from Actions' *media_layers*; or the name of the media layer.","title":"assign_media"},{"location":"api/classes/PyCoNode/#cache_range","text":"cache_range cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : Cache the selected Map Analysis over the specified range. Keyword arguments start -- The first frame of the range. An integer. end -- The last frame of the range. An integer.","title":"cache_range"},{"location":"api/classes/PyCoNode/#children","text":"children children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the children of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"children"},{"location":"api/classes/PyCoNode/#parents","text":"parents parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the parents of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"parents"},{"location":"api/classes/PyColourMgtTimelineFX/","text":"Class: PyColourMgtTimelineFX Module : flame Inherits from : PyTimelineFX , PyFlameObject , instance, object Description Object representing a Colour Mgmt Timeline FX. Properties Name Description attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. parent The parent object of this object. type Return the type of the Timeline FX. Methods clear_maps_cache_media clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media. flush_maps_cache_media flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.) get_context_variables get_context_variables get_context_variables( (PyColourMgtTimelineFX)arg1) -> dict : Get the context variables in a dictionary. import_transform import_transform import_transform( (PyColourMgtTimelineFX)arg1, (str)file_path) -> None : Import a transform from a file. load_setup load_setup load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting. reset_context_variables reset_context_variables reset_context_variables( (PyColourMgtTimelineFX)arg1) -> None : Reset the context variables to their initial state from the ocio config. save_setup save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context_variable set_context_variable set_context_variable( (PyColourMgtTimelineFX)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable. slide_keyframes slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. sync_connected_segments sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"Class: PyColourMgtTimelineFX"},{"location":"api/classes/PyColourMgtTimelineFX/#class-pycolourmgttimelinefx","text":"Module : flame Inherits from : PyTimelineFX , PyFlameObject , instance, object","title":"Class: PyColourMgtTimelineFX"},{"location":"api/classes/PyColourMgtTimelineFX/#description","text":"Object representing a Colour Mgmt Timeline FX.","title":"Description"},{"location":"api/classes/PyColourMgtTimelineFX/#properties","text":"Name Description attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. parent The parent object of this object. type Return the type of the Timeline FX.","title":"Properties"},{"location":"api/classes/PyColourMgtTimelineFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyColourMgtTimelineFX/#clear_maps_cache_media","text":"clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.","title":"clear_maps_cache_media"},{"location":"api/classes/PyColourMgtTimelineFX/#flush_maps_cache_media","text":"flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.)","title":"flush_maps_cache_media"},{"location":"api/classes/PyColourMgtTimelineFX/#get_context_variables","text":"get_context_variables get_context_variables( (PyColourMgtTimelineFX)arg1) -> dict : Get the context variables in a dictionary.","title":"get_context_variables"},{"location":"api/classes/PyColourMgtTimelineFX/#import_transform","text":"import_transform import_transform( (PyColourMgtTimelineFX)arg1, (str)file_path) -> None : Import a transform from a file.","title":"import_transform"},{"location":"api/classes/PyColourMgtTimelineFX/#load_setup","text":"load_setup load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_setup"},{"location":"api/classes/PyColourMgtTimelineFX/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyColourMgtTimelineFX/#reset_context_variables","text":"reset_context_variables reset_context_variables( (PyColourMgtTimelineFX)arg1) -> None : Reset the context variables to their initial state from the ocio config.","title":"reset_context_variables"},{"location":"api/classes/PyColourMgtTimelineFX/#save_setup","text":"save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_setup"},{"location":"api/classes/PyColourMgtTimelineFX/#set_context_variable","text":"set_context_variable set_context_variable( (PyColourMgtTimelineFX)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable.","title":"set_context_variable"},{"location":"api/classes/PyColourMgtTimelineFX/#slide_keyframes","text":"slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.","title":"slide_keyframes"},{"location":"api/classes/PyColourMgtTimelineFX/#sync_connected_segments","text":"sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"sync_connected_segments"},{"location":"api/classes/PyCompassNode/","text":"Class: PyCompassNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Class derived from PyNode. This class represents a Compass node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. nodes Return a list of PyNode objects enclosed by the Compass node. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyCompassNode"},{"location":"api/classes/PyCompassNode/#class-pycompassnode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyCompassNode"},{"location":"api/classes/PyCompassNode/#description","text":"Class derived from PyNode. This class represents a Compass node.","title":"Description"},{"location":"api/classes/PyCompassNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. nodes Return a list of PyNode objects enclosed by the Compass node. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyCompassNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyCompassNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyCompassNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyCompassNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyCompassNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyCompassNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyCompassNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyCompassNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyCompassNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyCompassNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyDesktop/","text":"Class: PyDesktop Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Class derived from PyArchiveEntry. This class represents a Desktop. Properties Name Description attributes The attributes of a python object. batch_groups Return a list of Batch Group objects that are immediate children of the current object. children Return a list of the immediate children of the current object. parent The parent object of this object. reel_groups Return a list of Reel Group objects that are immediate children of the current object. Methods clear clear clear( (PyDesktop)arg1) -> bool : Clear the Desktop. clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. create_batch_group create_batch_group create_batch_group( (PyDesktop)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : Create a new Batch Group object in the Desktop catalogue. Keyword arguments: name -- Name of the Batch Group. nb_reels -- Number of reels created. *reels* overrides *nb_reels*. nb_shelf_reels -- Number of shelf reels. The first shelf reel created is named Batch Renders. *shelf_reels* ovverides *nb_shelf_reels*. reels -- A list of reel names. Overrides *nb_reels*. shelf_reels -- A list of shelf reel names. Overrides *nb_shelf_reels*. start_frame -- The Batch Group's start frame. No timecodes, only a frame value. duration -- The number of frames. Sets the Duration field in the Batch UI. Will be set to the first clip duration when not specified. create_reel_group create_reel_group create_reel_group( (PyDesktop)arg1, (str)name) -> object : Create a new Reel Group object in the Desktop catalogue. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. save save save( (PyDesktop)arg1) -> bool : Save the Desktop to the location defined by the *destination* attribute.","title":"Class: PyDesktop"},{"location":"api/classes/PyDesktop/#class-pydesktop","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyDesktop"},{"location":"api/classes/PyDesktop/#description","text":"Class derived from PyArchiveEntry. This class represents a Desktop.","title":"Description"},{"location":"api/classes/PyDesktop/#properties","text":"Name Description attributes The attributes of a python object. batch_groups Return a list of Batch Group objects that are immediate children of the current object. children Return a list of the immediate children of the current object. parent The parent object of this object. reel_groups Return a list of Reel Group objects that are immediate children of the current object.","title":"Properties"},{"location":"api/classes/PyDesktop/#methods","text":"","title":"Methods"},{"location":"api/classes/PyDesktop/#clear","text":"clear clear( (PyDesktop)arg1) -> bool : Clear the Desktop.","title":"clear"},{"location":"api/classes/PyDesktop/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyDesktop/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyDesktop/#create_batch_group","text":"create_batch_group create_batch_group( (PyDesktop)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : Create a new Batch Group object in the Desktop catalogue. Keyword arguments: name -- Name of the Batch Group. nb_reels -- Number of reels created. *reels* overrides *nb_reels*. nb_shelf_reels -- Number of shelf reels. The first shelf reel created is named Batch Renders. *shelf_reels* ovverides *nb_shelf_reels*. reels -- A list of reel names. Overrides *nb_reels*. shelf_reels -- A list of shelf reel names. Overrides *nb_shelf_reels*. start_frame -- The Batch Group's start frame. No timecodes, only a frame value. duration -- The number of frames. Sets the Duration field in the Batch UI. Will be set to the first clip duration when not specified.","title":"create_batch_group"},{"location":"api/classes/PyDesktop/#create_reel_group","text":"create_reel_group create_reel_group( (PyDesktop)arg1, (str)name) -> object : Create a new Reel Group object in the Desktop catalogue.","title":"create_reel_group"},{"location":"api/classes/PyDesktop/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyDesktop/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyDesktop/#save","text":"save save( (PyDesktop)arg1) -> bool : Save the Desktop to the location defined by the *destination* attribute.","title":"save"},{"location":"api/classes/PyExporter/","text":"Class: PyExporter Module : flame Inherits from : instance, object Description Object holding export settings. Properties Name Description Audio Autodesk Distribution_Package Flow_Production_Tracking Image_Sequence Movie Project Sequence_Publish Shared Shotgun User export_all_subtitles Set export option 'All Subtitles Tracks'. export_between_marks Set export option 'Export between marks'. export_subtitles_as_files Set subtitles export option 'Export As Files. foreground Set export option 'Foreground export'. include_subtitles Set export option 'Include Subtitles'. keep_timeline_fx_renders Set export option 'Keep Timeline FX Renders'. use_top_video_track Set export option 'Use top video track'. warn_on_mixed_colour_space Set export option 'Warn on mixed colour space'. warn_on_no_media Set export option 'Warn on no media'. warn_on_pending_render Set export option 'Warn on pending render'. warn_on_reimport_unsupported Set export option 'Warn on reimport unsupported'. warn_on_unlinked Set export option 'Warn on unlinked'. warn_on_unrendered Set export option 'Warn on unrendered'. Methods BackgroundJobSettings BackgroundJobSettings Object holding background export job settings. These settings refer to the Backburner job, server and manager. PresetType PresetType PresetVisibility PresetVisibility export export export( (PyExporter)arg1, (object)sources, (str)preset_path, (str)output_directory [, (PyExporter.BackgroundJobSettings)background_job_settings=None [, (object)hooks=None [, (object)hooks_user_data=None]]]) -> None : Perform export. Keyword arguments: sources -- Flame clip object, a Flame container object or a list of either first. If a container is passed, a multi-export will be done and structure will be respected as much as possible. preset_path -- Absolute path to the export preset to use. output_directory -- Absolute path to the output directory root. background_job_settings -- Settings of background job(s) created if any. hooks -- Export python hooks override. If passed, regular export python hooks implemented in exportHooks.py will be bypassed for this export and methods in the passed object with matching name will be called. Instance of object passed should implement the following signature: class PythonHookOverride(object): def preExport(self, info, userData, *args, **kwargs) pass def postExport(self, info, userData, *args, **kwargs): pass def preExportSequence(self, info, userData, *args, **kwargs): pass def postExportSequence(self, info, userData, *args, **kwargs): pass def preExportAsset(self, info, userData, *args, **kwargs): pass def postExportAsset(self, info, userData, *args, **kwargs): pass def exportOverwriteFile(self, path, *args, **kwargs): return \"ask\" # or \"overwrite\" hooks_user_data -- User data object passed to the export python hooks. This object can be modified by the PythonHookOverride methods but cannot be re-assigned get_presets_base_dir get_presets_base_dir get_presets_base_dir( (PyExporter.PresetVisibility)preset_visibility) -> str : Get a presets base directory. get_presets_dir get_presets_dir get_presets_dir( (PyExporter.PresetVisibility)preset_visibility, (PyExporter.PresetType)preset_type) -> str : Get a presets directory.","title":"Class: PyExporter"},{"location":"api/classes/PyExporter/#class-pyexporter","text":"Module : flame Inherits from : instance, object","title":"Class: PyExporter"},{"location":"api/classes/PyExporter/#description","text":"Object holding export settings.","title":"Description"},{"location":"api/classes/PyExporter/#properties","text":"Name Description Audio Autodesk Distribution_Package Flow_Production_Tracking Image_Sequence Movie Project Sequence_Publish Shared Shotgun User export_all_subtitles Set export option 'All Subtitles Tracks'. export_between_marks Set export option 'Export between marks'. export_subtitles_as_files Set subtitles export option 'Export As Files. foreground Set export option 'Foreground export'. include_subtitles Set export option 'Include Subtitles'. keep_timeline_fx_renders Set export option 'Keep Timeline FX Renders'. use_top_video_track Set export option 'Use top video track'. warn_on_mixed_colour_space Set export option 'Warn on mixed colour space'. warn_on_no_media Set export option 'Warn on no media'. warn_on_pending_render Set export option 'Warn on pending render'. warn_on_reimport_unsupported Set export option 'Warn on reimport unsupported'. warn_on_unlinked Set export option 'Warn on unlinked'. warn_on_unrendered Set export option 'Warn on unrendered'.","title":"Properties"},{"location":"api/classes/PyExporter/#methods","text":"","title":"Methods"},{"location":"api/classes/PyExporter/#backgroundjobsettings","text":"BackgroundJobSettings Object holding background export job settings. These settings refer to the Backburner job, server and manager.","title":"BackgroundJobSettings"},{"location":"api/classes/PyExporter/#presettype","text":"PresetType","title":"PresetType"},{"location":"api/classes/PyExporter/#presetvisibility","text":"PresetVisibility","title":"PresetVisibility"},{"location":"api/classes/PyExporter/#export","text":"export export( (PyExporter)arg1, (object)sources, (str)preset_path, (str)output_directory [, (PyExporter.BackgroundJobSettings)background_job_settings=None [, (object)hooks=None [, (object)hooks_user_data=None]]]) -> None : Perform export. Keyword arguments: sources -- Flame clip object, a Flame container object or a list of either first. If a container is passed, a multi-export will be done and structure will be respected as much as possible. preset_path -- Absolute path to the export preset to use. output_directory -- Absolute path to the output directory root. background_job_settings -- Settings of background job(s) created if any. hooks -- Export python hooks override. If passed, regular export python hooks implemented in exportHooks.py will be bypassed for this export and methods in the passed object with matching name will be called. Instance of object passed should implement the following signature: class PythonHookOverride(object): def preExport(self, info, userData, *args, **kwargs) pass def postExport(self, info, userData, *args, **kwargs): pass def preExportSequence(self, info, userData, *args, **kwargs): pass def postExportSequence(self, info, userData, *args, **kwargs): pass def preExportAsset(self, info, userData, *args, **kwargs): pass def postExportAsset(self, info, userData, *args, **kwargs): pass def exportOverwriteFile(self, path, *args, **kwargs): return \"ask\" # or \"overwrite\" hooks_user_data -- User data object passed to the export python hooks. This object can be modified by the PythonHookOverride methods but cannot be re-assigned","title":"export"},{"location":"api/classes/PyExporter/#get_presets_base_dir","text":"get_presets_base_dir get_presets_base_dir( (PyExporter.PresetVisibility)preset_visibility) -> str : Get a presets base directory.","title":"get_presets_base_dir"},{"location":"api/classes/PyExporter/#get_presets_dir","text":"get_presets_dir get_presets_dir( (PyExporter.PresetVisibility)preset_visibility, (PyExporter.PresetType)preset_type) -> str : Get a presets directory.","title":"get_presets_dir"},{"location":"api/classes/PyFlameObject/","text":"Class: PyFlameObject Module : flame Inherits from : instance, object Description The basic type of all accessible Flame objects from the python API. Properties Name Description attributes The attributes of a python object. parent The parent object of this object.","title":"Class: PyFlameObject"},{"location":"api/classes/PyFlameObject/#class-pyflameobject","text":"Module : flame Inherits from : instance, object","title":"Class: PyFlameObject"},{"location":"api/classes/PyFlameObject/#description","text":"The basic type of all accessible Flame objects from the python API.","title":"Description"},{"location":"api/classes/PyFlameObject/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object.","title":"Properties"},{"location":"api/classes/PyFolder/","text":"Class: PyFolder Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Class derived from PyArchiveEntry. This class represents a Folder. Properties Name Description attributes The attributes of a python object. batch_groups Return a list of Batch Group objects that are immediate children of the current object. batch_iterations Return a list of Batch Iteration objects that are immediate children of the current object. children Return a list of the immediate children of the current object. clips Return a list of Clip objects that are immediate children of the current object. desktops Return a list Desktop objects that are immediate children of the current object. folders Return a list of the Folder objects that are immediate children of the current object. parent The parent object of this object. reel_groups Return a list of Reel Group objects that are immediate children of the current object. reels Return a list of Reel objects that are immediate children of the current object. sequences Return a list of Sequence objects that are immediate children of the current object. Methods clear clear clear( (PyFolder)arg1 [, (bool)confirm=True]) -> bool : Clear the contents of the Folder object. clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. create_folder create_folder create_folder( (PyFolder)arg1, (str)name) -> object : Create a new Folder object inside the Folder. create_reel create_reel create_reel( (PyFolder)arg1, (str)name) -> object : Create a new Reel object inside the Folder. create_reel_group create_reel_group create_reel_group( (PyFolder)arg1, (str)name) -> object : Create a new Reel Group object inside the Folder. create_sequence create_sequence create_sequence( (PyFolder)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by *frame_rate*. duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by *frame_rate*. If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all *audio_tracks*. False for mono tracks, True for stereo. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"Class: PyFolder"},{"location":"api/classes/PyFolder/#class-pyfolder","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyFolder"},{"location":"api/classes/PyFolder/#description","text":"Class derived from PyArchiveEntry. This class represents a Folder.","title":"Description"},{"location":"api/classes/PyFolder/#properties","text":"Name Description attributes The attributes of a python object. batch_groups Return a list of Batch Group objects that are immediate children of the current object. batch_iterations Return a list of Batch Iteration objects that are immediate children of the current object. children Return a list of the immediate children of the current object. clips Return a list of Clip objects that are immediate children of the current object. desktops Return a list Desktop objects that are immediate children of the current object. folders Return a list of the Folder objects that are immediate children of the current object. parent The parent object of this object. reel_groups Return a list of Reel Group objects that are immediate children of the current object. reels Return a list of Reel objects that are immediate children of the current object. sequences Return a list of Sequence objects that are immediate children of the current object.","title":"Properties"},{"location":"api/classes/PyFolder/#methods","text":"","title":"Methods"},{"location":"api/classes/PyFolder/#clear","text":"clear clear( (PyFolder)arg1 [, (bool)confirm=True]) -> bool : Clear the contents of the Folder object.","title":"clear"},{"location":"api/classes/PyFolder/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyFolder/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyFolder/#create_folder","text":"create_folder create_folder( (PyFolder)arg1, (str)name) -> object : Create a new Folder object inside the Folder.","title":"create_folder"},{"location":"api/classes/PyFolder/#create_reel","text":"create_reel create_reel( (PyFolder)arg1, (str)name) -> object : Create a new Reel object inside the Folder.","title":"create_reel"},{"location":"api/classes/PyFolder/#create_reel_group","text":"create_reel_group create_reel_group( (PyFolder)arg1, (str)name) -> object : Create a new Reel Group object inside the Folder.","title":"create_reel_group"},{"location":"api/classes/PyFolder/#create_sequence","text":"create_sequence create_sequence( (PyFolder)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by *frame_rate*. duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by *frame_rate*. If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all *audio_tracks*. False for mono tracks, True for stereo.","title":"create_sequence"},{"location":"api/classes/PyFolder/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyFolder/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyGMaskTracerNode/","text":"Class: PyGMaskTracerNode Module : flame Inherits from : PyActionFamilyNode , PyNode , PyFlameObject , instance, object Description Class derived from PyActionFamilyNode. Represents a GMask Tracer node object. Properties Name Description all_tabs Return a list of the object tabs. attributes The attributes of a python object. cursor_position Return a tuple that provides the cursor position in the Action/Image/GMaskTracer schematic. input_sockets Return a list of the node input sockets names. left_tabs Return a list of the object left tabs. media_layers Return a list of the Media layers of the Action/Image/GMaskTracer node. node_types Return a list of the node types available in the Action/Image/GMaskTracer schematic. nodes Return a list of Action/Image/GMaskTracer nodes used in the the Action/Image/GMaskTracer schematic. output_sockets Return a list of the node output sockets names. output_types Return a list of the output types available to the GMask Tracer node. parent The parent object of this object. right_tabs Return a list of the object right tabs. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic clear_schematic clear_schematic( (PyActionFamilyNode)arg1) -> bool : Clear the Action/Image/GMaskTracer schematic of all nodes. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. connect_nodes connect_nodes connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Connect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) create_node create_node create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic. Keyword argument: file_path -- Required by nodes that load an asset, such as Matchbox. input_colour_space -- Optional for nodes that load external media, such as IBL. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. disable_output disable_output disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Disable the render output_type for the GMask Tracer node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectors Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth) disconnect_nodes disconnect_nodes disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Disconnect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. enable_output enable_output enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Enable the render output_type for the GMask Tracer node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectoars Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth) encompass_nodes encompass_nodes encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : Create a compass including the node list given as argument Keyword argument: node_list -- a list of nodes (either string or node objects) output_type -- the created compass node export_fbx export_fbx export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : Export GMask Tracer nodes to an FBX file. Keyword argument: file_path -- Path to the output FBX file. Mandatory. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. get_node get_node get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : Get a node by node name. Doesn't select it in the UI. import_abc import_abc import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : Import an Alembic (ABC) file into the GMask Tracer schematic using the GMask Tracer Objects mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. import_fbx import_fbx import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : Import an FBX file into the GMask Tracer schematic using the GMask Tracer Objects mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. import_psd import_psd import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : Import a PSD file into the GMask Tracer schematic. Keyword arguments: file_path -- Path to the PSD file. Mandatory. input_colour_space -- The colour space used as input. Optional. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. organize organize organize( (PyActionFamilyNode)arg1) -> bool : Clean up the Action/Image/GMaskTracer schematic. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. read_abc read_abc read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : Import an Alembic (ABC) file into the GMask Tracer schematic using the Read File mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. read_fbx read_fbx read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : Import an FBX file into the GMask Tracer schematic using the Read File mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyGMaskTracerNode"},{"location":"api/classes/PyGMaskTracerNode/#class-pygmasktracernode","text":"Module : flame Inherits from : PyActionFamilyNode , PyNode , PyFlameObject , instance, object","title":"Class: PyGMaskTracerNode"},{"location":"api/classes/PyGMaskTracerNode/#description","text":"Class derived from PyActionFamilyNode. Represents a GMask Tracer node object.","title":"Description"},{"location":"api/classes/PyGMaskTracerNode/#properties","text":"Name Description all_tabs Return a list of the object tabs. attributes The attributes of a python object. cursor_position Return a tuple that provides the cursor position in the Action/Image/GMaskTracer schematic. input_sockets Return a list of the node input sockets names. left_tabs Return a list of the object left tabs. media_layers Return a list of the Media layers of the Action/Image/GMaskTracer node. node_types Return a list of the node types available in the Action/Image/GMaskTracer schematic. nodes Return a list of Action/Image/GMaskTracer nodes used in the the Action/Image/GMaskTracer schematic. output_sockets Return a list of the node output sockets names. output_types Return a list of the output types available to the GMask Tracer node. parent The parent object of this object. right_tabs Return a list of the object right tabs. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyGMaskTracerNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyGMaskTracerNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyGMaskTracerNode/#clear_schematic","text":"clear_schematic clear_schematic( (PyActionFamilyNode)arg1) -> bool : Clear the Action/Image/GMaskTracer schematic of all nodes.","title":"clear_schematic"},{"location":"api/classes/PyGMaskTracerNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyGMaskTracerNode/#connect_nodes","text":"connect_nodes connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Connect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"connect_nodes"},{"location":"api/classes/PyGMaskTracerNode/#create_node","text":"create_node create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic. Keyword argument: file_path -- Required by nodes that load an asset, such as Matchbox. input_colour_space -- Optional for nodes that load external media, such as IBL.","title":"create_node"},{"location":"api/classes/PyGMaskTracerNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyGMaskTracerNode/#disable_output","text":"disable_output disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Disable the render output_type for the GMask Tracer node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectors Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)","title":"disable_output"},{"location":"api/classes/PyGMaskTracerNode/#disconnect_nodes","text":"disconnect_nodes disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Disconnect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"disconnect_nodes"},{"location":"api/classes/PyGMaskTracerNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyGMaskTracerNode/#enable_output","text":"enable_output enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Enable the render output_type for the GMask Tracer node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectoars Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)","title":"enable_output"},{"location":"api/classes/PyGMaskTracerNode/#encompass_nodes","text":"encompass_nodes encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : Create a compass including the node list given as argument Keyword argument: node_list -- a list of nodes (either string or node objects) output_type -- the created compass node","title":"encompass_nodes"},{"location":"api/classes/PyGMaskTracerNode/#export_fbx","text":"export_fbx export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : Export GMask Tracer nodes to an FBX file. Keyword argument: file_path -- Path to the output FBX file. Mandatory.","title":"export_fbx"},{"location":"api/classes/PyGMaskTracerNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyGMaskTracerNode/#get_node","text":"get_node get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : Get a node by node name. Doesn't select it in the UI.","title":"get_node"},{"location":"api/classes/PyGMaskTracerNode/#import_abc","text":"import_abc import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : Import an Alembic (ABC) file into the GMask Tracer schematic using the GMask Tracer Objects mode. Keyword argument: file_path -- Path to the ABC file. Mandatory.","title":"import_abc"},{"location":"api/classes/PyGMaskTracerNode/#import_fbx","text":"import_fbx import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : Import an FBX file into the GMask Tracer schematic using the GMask Tracer Objects mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional.","title":"import_fbx"},{"location":"api/classes/PyGMaskTracerNode/#import_psd","text":"import_psd import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : Import a PSD file into the GMask Tracer schematic. Keyword arguments: file_path -- Path to the PSD file. Mandatory. input_colour_space -- The colour space used as input. Optional.","title":"import_psd"},{"location":"api/classes/PyGMaskTracerNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyGMaskTracerNode/#organize","text":"organize organize( (PyActionFamilyNode)arg1) -> bool : Clean up the Action/Image/GMaskTracer schematic.","title":"organize"},{"location":"api/classes/PyGMaskTracerNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyGMaskTracerNode/#read_abc","text":"read_abc read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : Import an Alembic (ABC) file into the GMask Tracer schematic using the Read File mode. Keyword argument: file_path -- Path to the ABC file. Mandatory.","title":"read_abc"},{"location":"api/classes/PyGMaskTracerNode/#read_fbx","text":"read_fbx read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : Import an FBX file into the GMask Tracer schematic using the Read File mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional.","title":"read_fbx"},{"location":"api/classes/PyGMaskTracerNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyGMaskTracerNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyHDRNode/","text":"Class: PyHDRNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Object representing a HDR node. Properties Name Description analysis_status Return the current state of the HDR analysis. attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. mastering_display_ids List of available Mastering Display Ids. mastering_display_info Dictionary containing Mastering Display information. Returned object is a copy. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. target_display_ids List of available Target Display Ids. target_display_info Dictionary containing Target Display information. Returned object is a copy. Methods analyze analyze analyze( (PyHDRNode)arg1 [, (str)analyze_mode='Current Shot']) -> None : Perform HDR analysis. cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. export_DolbyVision_xml export_DolbyVision_xml export_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)comment='']) -> None : Export the current HDR to a Dolby Vision XML file. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. has_trim has_trim has_trim( (PyHDRNode)arg1, (int)target_display_id) -> bool : Returns True if the given Target Display ID has trims. import_DolbyVision_xml import_DolbyVision_xml import_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : Import the current HDR from a Dolby Vision XML file. interpolate_trims interpolate_trims interpolate_trims( (PyHDRNode)arg1) -> None : Interpolate the current HDR trims. keep_analysis keep_analysis keep_analysis( (PyHDRNode)arg1) -> None : Remove the dirty flag from the HDR analysis. l2_from_l8 l2_from_l8 l2_from_l8( (PyHDRNode)arg1) -> object : Dictionary containing the L2 values based on L8 values. Not valid in Dolby Vision 2.9. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. reset_analysis reset_analysis reset_analysis( (PyHDRNode)arg1) -> None : Reset the current HDR analysis. reset_trims reset_trims reset_trims( (PyHDRNode)arg1) -> None : Reset the current HDR trims. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyHDRNode"},{"location":"api/classes/PyHDRNode/#class-pyhdrnode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyHDRNode"},{"location":"api/classes/PyHDRNode/#description","text":"Object representing a HDR node.","title":"Description"},{"location":"api/classes/PyHDRNode/#properties","text":"Name Description analysis_status Return the current state of the HDR analysis. attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. mastering_display_ids List of available Mastering Display Ids. mastering_display_info Dictionary containing Mastering Display information. Returned object is a copy. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. target_display_ids List of available Target Display Ids. target_display_info Dictionary containing Target Display information. Returned object is a copy.","title":"Properties"},{"location":"api/classes/PyHDRNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyHDRNode/#analyze","text":"analyze analyze( (PyHDRNode)arg1 [, (str)analyze_mode='Current Shot']) -> None : Perform HDR analysis.","title":"analyze"},{"location":"api/classes/PyHDRNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyHDRNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyHDRNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyHDRNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyHDRNode/#export_dolbyvision_xml","text":"export_DolbyVision_xml export_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)comment='']) -> None : Export the current HDR to a Dolby Vision XML file.","title":"export_DolbyVision_xml"},{"location":"api/classes/PyHDRNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyHDRNode/#has_trim","text":"has_trim has_trim( (PyHDRNode)arg1, (int)target_display_id) -> bool : Returns True if the given Target Display ID has trims.","title":"has_trim"},{"location":"api/classes/PyHDRNode/#import_dolbyvision_xml","text":"import_DolbyVision_xml import_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : Import the current HDR from a Dolby Vision XML file.","title":"import_DolbyVision_xml"},{"location":"api/classes/PyHDRNode/#interpolate_trims","text":"interpolate_trims interpolate_trims( (PyHDRNode)arg1) -> None : Interpolate the current HDR trims.","title":"interpolate_trims"},{"location":"api/classes/PyHDRNode/#keep_analysis","text":"keep_analysis keep_analysis( (PyHDRNode)arg1) -> None : Remove the dirty flag from the HDR analysis.","title":"keep_analysis"},{"location":"api/classes/PyHDRNode/#l2_from_l8","text":"l2_from_l8 l2_from_l8( (PyHDRNode)arg1) -> object : Dictionary containing the L2 values based on L8 values. Not valid in Dolby Vision 2.9.","title":"l2_from_l8"},{"location":"api/classes/PyHDRNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyHDRNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyHDRNode/#reset_analysis","text":"reset_analysis reset_analysis( (PyHDRNode)arg1) -> None : Reset the current HDR analysis.","title":"reset_analysis"},{"location":"api/classes/PyHDRNode/#reset_trims","text":"reset_trims reset_trims( (PyHDRNode)arg1) -> None : Reset the current HDR trims.","title":"reset_trims"},{"location":"api/classes/PyHDRNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyHDRNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyHDRTimelineFX/","text":"Class: PyHDRTimelineFX Module : flame Inherits from : PyTimelineFX , PyFlameObject , instance, object Description Object representing a HDR Timeline FX. Properties Name Description analysis_status Return the current state of the HDR analysis. attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. mastering_display_ids List of available Mastering Display Ids. mastering_display_info Dictionary containing Mastering Display information. Returned object is a copy. parent The parent object of this object. target_display_ids List of available Target Display Ids. target_display_info Dictionary containing Target Display information. Returned object is a copy. type Return the type of the Timeline FX. Methods analyze analyze analyze( (PyHDRTimelineFX)arg1 [, (str)analyze_mode='Current Shot']) -> None : Perform HDR analysis. clear_maps_cache_media clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media. export_DolbyVision_xml export_DolbyVision_xml export_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (bool)shot_only=False [, (str)comment='']]) -> None : Export the current HDR to a Dolby Vision XML file. flush_maps_cache_media flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.) has_trim has_trim has_trim( (PyHDRTimelineFX)arg1, (int)target_display_id) -> bool : Returns True if the given Target Display ID has trims. import_DolbyVision_xml import_DolbyVision_xml import_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : Import the current HDR from a Dolby Vision XML file. interpolate_trims interpolate_trims interpolate_trims( (PyHDRTimelineFX)arg1, (str)arg2) -> None : Interpolate the current HDR trims. keep_analysis keep_analysis keep_analysis( (PyHDRTimelineFX)arg1) -> None : Remove the dirty flag from the HDR analysis. l2_from_l8 l2_from_l8 l2_from_l8( (PyHDRTimelineFX)arg1) -> object : Dictionary containing the L2 values based on L8 values. Not valid in Dolby Vision 2.9. load_setup load_setup load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting. reset_analysis reset_analysis reset_analysis( (PyHDRTimelineFX)arg1) -> None : Reset the current HDR analysis. reset_trims reset_trims reset_trims( (PyHDRTimelineFX)arg1) -> None : Reset the current HDR trims. save_setup save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. slide_keyframes slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. sync_connected_segments sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"Class: PyHDRTimelineFX"},{"location":"api/classes/PyHDRTimelineFX/#class-pyhdrtimelinefx","text":"Module : flame Inherits from : PyTimelineFX , PyFlameObject , instance, object","title":"Class: PyHDRTimelineFX"},{"location":"api/classes/PyHDRTimelineFX/#description","text":"Object representing a HDR Timeline FX.","title":"Description"},{"location":"api/classes/PyHDRTimelineFX/#properties","text":"Name Description analysis_status Return the current state of the HDR analysis. attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. mastering_display_ids List of available Mastering Display Ids. mastering_display_info Dictionary containing Mastering Display information. Returned object is a copy. parent The parent object of this object. target_display_ids List of available Target Display Ids. target_display_info Dictionary containing Target Display information. Returned object is a copy. type Return the type of the Timeline FX.","title":"Properties"},{"location":"api/classes/PyHDRTimelineFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyHDRTimelineFX/#analyze","text":"analyze analyze( (PyHDRTimelineFX)arg1 [, (str)analyze_mode='Current Shot']) -> None : Perform HDR analysis.","title":"analyze"},{"location":"api/classes/PyHDRTimelineFX/#clear_maps_cache_media","text":"clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.","title":"clear_maps_cache_media"},{"location":"api/classes/PyHDRTimelineFX/#export_dolbyvision_xml","text":"export_DolbyVision_xml export_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (bool)shot_only=False [, (str)comment='']]) -> None : Export the current HDR to a Dolby Vision XML file.","title":"export_DolbyVision_xml"},{"location":"api/classes/PyHDRTimelineFX/#flush_maps_cache_media","text":"flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.)","title":"flush_maps_cache_media"},{"location":"api/classes/PyHDRTimelineFX/#has_trim","text":"has_trim has_trim( (PyHDRTimelineFX)arg1, (int)target_display_id) -> bool : Returns True if the given Target Display ID has trims.","title":"has_trim"},{"location":"api/classes/PyHDRTimelineFX/#import_dolbyvision_xml","text":"import_DolbyVision_xml import_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : Import the current HDR from a Dolby Vision XML file.","title":"import_DolbyVision_xml"},{"location":"api/classes/PyHDRTimelineFX/#interpolate_trims","text":"interpolate_trims interpolate_trims( (PyHDRTimelineFX)arg1, (str)arg2) -> None : Interpolate the current HDR trims.","title":"interpolate_trims"},{"location":"api/classes/PyHDRTimelineFX/#keep_analysis","text":"keep_analysis keep_analysis( (PyHDRTimelineFX)arg1) -> None : Remove the dirty flag from the HDR analysis.","title":"keep_analysis"},{"location":"api/classes/PyHDRTimelineFX/#l2_from_l8","text":"l2_from_l8 l2_from_l8( (PyHDRTimelineFX)arg1) -> object : Dictionary containing the L2 values based on L8 values. Not valid in Dolby Vision 2.9.","title":"l2_from_l8"},{"location":"api/classes/PyHDRTimelineFX/#load_setup","text":"load_setup load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_setup"},{"location":"api/classes/PyHDRTimelineFX/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyHDRTimelineFX/#reset_analysis","text":"reset_analysis reset_analysis( (PyHDRTimelineFX)arg1) -> None : Reset the current HDR analysis.","title":"reset_analysis"},{"location":"api/classes/PyHDRTimelineFX/#reset_trims","text":"reset_trims reset_trims( (PyHDRTimelineFX)arg1) -> None : Reset the current HDR trims.","title":"reset_trims"},{"location":"api/classes/PyHDRTimelineFX/#save_setup","text":"save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_setup"},{"location":"api/classes/PyHDRTimelineFX/#slide_keyframes","text":"slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.","title":"slide_keyframes"},{"location":"api/classes/PyHDRTimelineFX/#sync_connected_segments","text":"sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"sync_connected_segments"},{"location":"api/classes/PyImageNode/","text":"Class: PyImageNode Module : flame Inherits from : PyActionFamilyNode , PyNode , PyFlameObject , instance, object Description Class derived from PyActionFamilyNode. Represents an Image node object. Properties Name Description all_tabs Return a list of the object tabs. attributes The attributes of a python object. cursor_position Return a tuple that provides the cursor position in the Action/Image/GMaskTracer schematic. input_sockets Return a list of the node input sockets names. left_tabs Return a list of the object left tabs. media_layers Return a list of the Media layers of the Action/Image/GMaskTracer node. media_nodes Return a list of the Media nodes attached to the Image node. node_types Return a list of the node types available in the Action/Image/GMaskTracer schematic. nodes Return a list of Action/Image/GMaskTracer nodes used in the the Action/Image/GMaskTracer schematic. output_sockets Return a list of the node output sockets names. parent The parent object of this object. right_tabs Return a list of the object right tabs. sockets Return a dictionary of the input/output sockets names and their connections. Methods add_media add_media add_media( (PyActionFamilyNode)arg1) -> object : Add a Media layer to the Batch Image node. cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic clear_schematic clear_schematic( (PyActionFamilyNode)arg1) -> bool : Clear the Action/Image/GMaskTracer schematic of all nodes. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. connect_nodes connect_nodes connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Connect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) create_node create_node create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic. Keyword argument: file_path -- Required by nodes that load an asset, such as Matchbox. input_colour_space -- Optional for nodes that load external media, such as IBL. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. disconnect_nodes disconnect_nodes disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Disconnect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. encompass_nodes encompass_nodes encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : Create a compass including the node list given as argument Keyword argument: node_list -- a list of nodes (either string or node objects) output_type -- the created compass node get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. get_node get_node get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : Get a node by node name. Doesn't select it in the UI. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. organize organize organize( (PyActionFamilyNode)arg1) -> bool : Clean up the Action/Image/GMaskTracer schematic. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyImageNode"},{"location":"api/classes/PyImageNode/#class-pyimagenode","text":"Module : flame Inherits from : PyActionFamilyNode , PyNode , PyFlameObject , instance, object","title":"Class: PyImageNode"},{"location":"api/classes/PyImageNode/#description","text":"Class derived from PyActionFamilyNode. Represents an Image node object.","title":"Description"},{"location":"api/classes/PyImageNode/#properties","text":"Name Description all_tabs Return a list of the object tabs. attributes The attributes of a python object. cursor_position Return a tuple that provides the cursor position in the Action/Image/GMaskTracer schematic. input_sockets Return a list of the node input sockets names. left_tabs Return a list of the object left tabs. media_layers Return a list of the Media layers of the Action/Image/GMaskTracer node. media_nodes Return a list of the Media nodes attached to the Image node. node_types Return a list of the node types available in the Action/Image/GMaskTracer schematic. nodes Return a list of Action/Image/GMaskTracer nodes used in the the Action/Image/GMaskTracer schematic. output_sockets Return a list of the node output sockets names. parent The parent object of this object. right_tabs Return a list of the object right tabs. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyImageNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyImageNode/#add_media","text":"add_media add_media( (PyActionFamilyNode)arg1) -> object : Add a Media layer to the Batch Image node.","title":"add_media"},{"location":"api/classes/PyImageNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyImageNode/#clear_schematic","text":"clear_schematic clear_schematic( (PyActionFamilyNode)arg1) -> bool : Clear the Action/Image/GMaskTracer schematic of all nodes.","title":"clear_schematic"},{"location":"api/classes/PyImageNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyImageNode/#connect_nodes","text":"connect_nodes connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Connect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"connect_nodes"},{"location":"api/classes/PyImageNode/#create_node","text":"create_node create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic. Keyword argument: file_path -- Required by nodes that load an asset, such as Matchbox. input_colour_space -- Optional for nodes that load external media, such as IBL.","title":"create_node"},{"location":"api/classes/PyImageNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyImageNode/#disconnect_nodes","text":"disconnect_nodes disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Disconnect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"disconnect_nodes"},{"location":"api/classes/PyImageNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyImageNode/#encompass_nodes","text":"encompass_nodes encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : Create a compass including the node list given as argument Keyword argument: node_list -- a list of nodes (either string or node objects) output_type -- the created compass node","title":"encompass_nodes"},{"location":"api/classes/PyImageNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyImageNode/#get_node","text":"get_node get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : Get a node by node name. Doesn't select it in the UI.","title":"get_node"},{"location":"api/classes/PyImageNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyImageNode/#organize","text":"organize organize( (PyActionFamilyNode)arg1) -> bool : Clean up the Action/Image/GMaskTracer schematic.","title":"organize"},{"location":"api/classes/PyImageNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyImageNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyImageNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyLensDistortionNode/","text":"Class: PyLensDistortionNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Object representing a Lens Distortion node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. calculate calculate calculate( (PyLensDistortionNode)arg1) -> None : Calculate the amount of distorsion based on the position of vertices. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. import_lens_distortion import_lens_distortion import_lens_distortion( (PyLensDistortionNode)arg1, (str)filename) -> None : Import the Lens Distortion file. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyLensDistortionNode"},{"location":"api/classes/PyLensDistortionNode/#class-pylensdistortionnode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyLensDistortionNode"},{"location":"api/classes/PyLensDistortionNode/#description","text":"Object representing a Lens Distortion node.","title":"Description"},{"location":"api/classes/PyLensDistortionNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyLensDistortionNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyLensDistortionNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyLensDistortionNode/#calculate","text":"calculate calculate( (PyLensDistortionNode)arg1) -> None : Calculate the amount of distorsion based on the position of vertices.","title":"calculate"},{"location":"api/classes/PyLensDistortionNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyLensDistortionNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyLensDistortionNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyLensDistortionNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyLensDistortionNode/#import_lens_distortion","text":"import_lens_distortion import_lens_distortion( (PyLensDistortionNode)arg1, (str)filename) -> None : Import the Lens Distortion file.","title":"import_lens_distortion"},{"location":"api/classes/PyLensDistortionNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyLensDistortionNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyLensDistortionNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyLensDistortionNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyLibrary/","text":"Class: PyLibrary Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Class derived from PyArchiveEntry. This class represents a Library. Properties Name Description attributes The attributes of a python object. batch_groups Return a list of Batch Group objects that are immediate children of the current object. batch_iterations Return a list of Batch Iteration objects that are immediate children of the current object. children Return a list of the immediate children of the current object. clips Return a list of Clip objects that are immediate children of the current object. desktops Return a list Desktop objects that are immediate children of the current object. folders Return a list of the Folder objects that are immediate children of the current object. opened Return True if the Library is in the open state. parent The parent object of this object. reel_groups Return a list of Reel Group objects that are immediate children of the current object. reels Return a list of Reel objects that are immediate children of the current object. sequences Return a list of Sequence objects that are immediate children of the current object. Methods acquire_exclusive_access acquire_exclusive_access acquire_exclusive_access( (PyLibrary)arg1) -> bool : Acquire exclusive access to the Shared Library. Shared Libraries are created locked. Only use with Shared Libraries. clear clear clear( (PyLibrary)arg1 [, (bool)confirm=True]) -> bool : Clear the Library's contents. clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. close close close( (PyLibrary)arg1) -> bool : Close a Library to release it from the application memory. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. create_folder create_folder create_folder( (PyLibrary)arg1, (str)name) -> object : Create a Folder inside a Library. create_reel create_reel create_reel( (PyLibrary)arg1, (str)name) -> object : Create a Reel inside a Library. create_reel_group create_reel_group create_reel_group( (PyLibrary)arg1, (str)name) -> object : Create a Reel Group inside a Library. create_sequence create_sequence create_sequence( (PyLibrary)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by *frame_rate*. duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by *frame_rate*. If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all *audio_tracks*. False for mono tracks, True for stereo. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. open open open( (PyLibrary)arg1) -> bool : Open a Library and load it in the application memory. Until a Library is open, it cannot be accessed. Libraries are created open. release_exclusive_access release_exclusive_access release_exclusive_access( (PyLibrary)arg1) -> bool : Release exclusive access to the Shared Library. Only used for Shared Libraries. Only use with Shared Libraries.","title":"Class: PyLibrary"},{"location":"api/classes/PyLibrary/#class-pylibrary","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyLibrary"},{"location":"api/classes/PyLibrary/#description","text":"Class derived from PyArchiveEntry. This class represents a Library.","title":"Description"},{"location":"api/classes/PyLibrary/#properties","text":"Name Description attributes The attributes of a python object. batch_groups Return a list of Batch Group objects that are immediate children of the current object. batch_iterations Return a list of Batch Iteration objects that are immediate children of the current object. children Return a list of the immediate children of the current object. clips Return a list of Clip objects that are immediate children of the current object. desktops Return a list Desktop objects that are immediate children of the current object. folders Return a list of the Folder objects that are immediate children of the current object. opened Return True if the Library is in the open state. parent The parent object of this object. reel_groups Return a list of Reel Group objects that are immediate children of the current object. reels Return a list of Reel objects that are immediate children of the current object. sequences Return a list of Sequence objects that are immediate children of the current object.","title":"Properties"},{"location":"api/classes/PyLibrary/#methods","text":"","title":"Methods"},{"location":"api/classes/PyLibrary/#acquire_exclusive_access","text":"acquire_exclusive_access acquire_exclusive_access( (PyLibrary)arg1) -> bool : Acquire exclusive access to the Shared Library. Shared Libraries are created locked. Only use with Shared Libraries.","title":"acquire_exclusive_access"},{"location":"api/classes/PyLibrary/#clear","text":"clear clear( (PyLibrary)arg1 [, (bool)confirm=True]) -> bool : Clear the Library's contents.","title":"clear"},{"location":"api/classes/PyLibrary/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyLibrary/#close","text":"close close( (PyLibrary)arg1) -> bool : Close a Library to release it from the application memory.","title":"close"},{"location":"api/classes/PyLibrary/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyLibrary/#create_folder","text":"create_folder create_folder( (PyLibrary)arg1, (str)name) -> object : Create a Folder inside a Library.","title":"create_folder"},{"location":"api/classes/PyLibrary/#create_reel","text":"create_reel create_reel( (PyLibrary)arg1, (str)name) -> object : Create a Reel inside a Library.","title":"create_reel"},{"location":"api/classes/PyLibrary/#create_reel_group","text":"create_reel_group create_reel_group( (PyLibrary)arg1, (str)name) -> object : Create a Reel Group inside a Library.","title":"create_reel_group"},{"location":"api/classes/PyLibrary/#create_sequence","text":"create_sequence create_sequence( (PyLibrary)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by *frame_rate*. duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by *frame_rate*. If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all *audio_tracks*. False for mono tracks, True for stereo.","title":"create_sequence"},{"location":"api/classes/PyLibrary/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyLibrary/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyLibrary/#open","text":"open open( (PyLibrary)arg1) -> bool : Open a Library and load it in the application memory. Until a Library is open, it cannot be accessed. Libraries are created open.","title":"open"},{"location":"api/classes/PyLibrary/#release_exclusive_access","text":"release_exclusive_access release_exclusive_access( (PyLibrary)arg1) -> bool : Release exclusive access to the Shared Library. Only used for Shared Libraries. Only use with Shared Libraries.","title":"release_exclusive_access"},{"location":"api/classes/PyMarker/","text":"Class: PyMarker Module : flame Inherits from : PyFlameObject , instance, object Description Object representing a Marker. Properties Name Description attributes The attributes of a python object. has_annotations Returns True when the Marker contains at least one annotation. parent The parent object of this object. Methods clear_annotations clear_annotations clear_annotations( (PyMarker)arg1) -> None : Clear all the annotations from the Marker. sync_connected_segments sync_connected_segments sync_connected_segments( (PyMarker)arg1) -> None : Push the Segment Marker to connected segments.","title":"Class: PyMarker"},{"location":"api/classes/PyMarker/#class-pymarker","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyMarker"},{"location":"api/classes/PyMarker/#description","text":"Object representing a Marker.","title":"Description"},{"location":"api/classes/PyMarker/#properties","text":"Name Description attributes The attributes of a python object. has_annotations Returns True when the Marker contains at least one annotation. parent The parent object of this object.","title":"Properties"},{"location":"api/classes/PyMarker/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMarker/#clear_annotations","text":"clear_annotations clear_annotations( (PyMarker)arg1) -> None : Clear all the annotations from the Marker.","title":"clear_annotations"},{"location":"api/classes/PyMarker/#sync_connected_segments","text":"sync_connected_segments sync_connected_segments( (PyMarker)arg1) -> None : Push the Segment Marker to connected segments.","title":"sync_connected_segments"},{"location":"api/classes/PyMediaHub/","text":"Class: PyMediaHub Module : flame Inherits from : instance, object Description This class represents the MediaHub. Properties Name Description archives None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubTab files None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubFilesTab","title":"Class: PyMediaHub"},{"location":"api/classes/PyMediaHub/#class-pymediahub","text":"Module : flame Inherits from : instance, object","title":"Class: PyMediaHub"},{"location":"api/classes/PyMediaHub/#description","text":"This class represents the MediaHub.","title":"Description"},{"location":"api/classes/PyMediaHub/#properties","text":"Name Description archives None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubTab files None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubFilesTab","title":"Properties"},{"location":"api/classes/PyMediaHubFilesEntry/","text":"Class: PyMediaHubFilesEntry Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Object representing a clip in the MediaHub Files tabs Properties Name Description attributes The attributes of a python object. parent The parent object of this object. path Returns the absolute path of the clip Methods clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"Class: PyMediaHubFilesEntry"},{"location":"api/classes/PyMediaHubFilesEntry/#class-pymediahubfilesentry","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyMediaHubFilesEntry"},{"location":"api/classes/PyMediaHubFilesEntry/#description","text":"Object representing a clip in the MediaHub Files tabs","title":"Description"},{"location":"api/classes/PyMediaHubFilesEntry/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. path Returns the absolute path of the clip","title":"Properties"},{"location":"api/classes/PyMediaHubFilesEntry/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubFilesEntry/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyMediaHubFilesEntry/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyMediaHubFilesEntry/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyMediaHubFilesEntry/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyMediaHubFilesFolder/","text":"Class: PyMediaHubFilesFolder Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Object representing a folder in the MediaHub Files tabs Properties Name Description attributes The attributes of a python object. parent The parent object of this object. path Returns the absolute path of the folder Methods clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"Class: PyMediaHubFilesFolder"},{"location":"api/classes/PyMediaHubFilesFolder/#class-pymediahubfilesfolder","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyMediaHubFilesFolder"},{"location":"api/classes/PyMediaHubFilesFolder/#description","text":"Object representing a folder in the MediaHub Files tabs","title":"Description"},{"location":"api/classes/PyMediaHubFilesFolder/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. path Returns the absolute path of the folder","title":"Properties"},{"location":"api/classes/PyMediaHubFilesFolder/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubFilesFolder/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyMediaHubFilesFolder/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyMediaHubFilesFolder/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyMediaHubFilesFolder/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyMediaHubFilesTab/","text":"Class: PyMediaHubFilesTab Module : flame Inherits from : PyMediaHubTab , instance, object Description This class represents the MediaHub Files tab. Properties Name Description options None( (flame.PyMediaHubFilesTab)arg1) -> object Methods get_path get_path get_path( (PyMediaHubTab)arg1) -> str : Return the MediaHub tab current path. set_path set_path set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool : Set the MediaHub tab current path. If allow_partial_success is True, the path will be set to the last valid folder in the path.","title":"Class: PyMediaHubFilesTab"},{"location":"api/classes/PyMediaHubFilesTab/#class-pymediahubfilestab","text":"Module : flame Inherits from : PyMediaHubTab , instance, object","title":"Class: PyMediaHubFilesTab"},{"location":"api/classes/PyMediaHubFilesTab/#description","text":"This class represents the MediaHub Files tab.","title":"Description"},{"location":"api/classes/PyMediaHubFilesTab/#properties","text":"Name Description options None( (flame.PyMediaHubFilesTab)arg1) -> object","title":"Properties"},{"location":"api/classes/PyMediaHubFilesTab/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubFilesTab/#get_path","text":"get_path get_path( (PyMediaHubTab)arg1) -> str : Return the MediaHub tab current path.","title":"get_path"},{"location":"api/classes/PyMediaHubFilesTab/#set_path","text":"set_path set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool : Set the MediaHub tab current path. If allow_partial_success is True, the path will be set to the last valid folder in the path.","title":"set_path"},{"location":"api/classes/PyMediaHubFilesTabOptions/","text":"Class: PyMediaHubFilesTabOptions Module : flame Inherits from : instance, object Description This class represents the MediaHub Files tab options. Properties Name Description bit_depth Import bit depth value. Possible values are 8, 10, 12, 16, 32, and From Source. cache_and_proxies_all_versions Generate caches and proxies for all versions instead of the current one on import. cache_mode Cache media on import. colour_mgmt_display Import colour management Display name. Can only be set while in View Transform mode. colour_mgmt_invert Import colour management Invert status. Can only be set while in View Transform mode. colour_mgmt_mode Import colour management Mode value. Possible values are Tag Only, Auto Convert, View Transform, and Use LUT. colour_mgmt_view Import colour management View name. Can only be set while in View Transform mode. colour_mgmt_working_space Import colour management Working Space name. Can only be set while in Auto Convert mode. frame_ratio Import frame ratio value. Returns None when resolution mode is not set to Resolution List. height Import height value. Returns None when resolution is set to Same as Source, Scaling Presets or Adaptive when based on width. multi_channel_mode Multi-Channel Mode to use upon import. pixel_ratio Import pixel ratio value. Returns None when resolution is not set to Same As Source. proxies_mode Generate proxies on import. resize_filter Import resizing filter value. Possible values are Lanczos, Shannon, Gaussian, Quadratic, Bicubic, Mitchell, Triangle, and Impulse. resize_mode Import resizing mode value. Possible values are Letterbox, Crop Edges, Fill, and Centre. resolution Set the resolution based on the name. Possible values are Custom Resolution, Project Res, Adaptive, Scaling Presets, Same as Source or a resolution with this format: HD 720 16:9 (1280 x 720) scaling_presets_value Import scaling presets value. Returns None when the resolution selector is not Scaling Presets. scan_mode Import scan mode value. Possible values are P, F1, F2, and From Source. sequence_mode Use the sequence mode to import a range of files. tagged_colour_space Import colour management Tagged Colour Space name in Tag Only, View Transform and Use LUT modes. It also represents the Input Colour Space name in Auto Convert mode. width Import width value. Returns None when resolution is set to Same as Source, Scaling Presets or Adaptive when based on height. Methods import_transform import_transform import_transform( (PyMediaHubFilesTabOptions)arg1, (str)file_path) -> None : Import a transform from a file. set_tagged_colour_space set_tagged_colour_space set_tagged_colour_space( (PyMediaHubFilesTabOptions)arg1, (str)colour_space) -> None : Set the tagged colour space to use upon import.","title":"Class: PyMediaHubFilesTabOptions"},{"location":"api/classes/PyMediaHubFilesTabOptions/#class-pymediahubfilestaboptions","text":"Module : flame Inherits from : instance, object","title":"Class: PyMediaHubFilesTabOptions"},{"location":"api/classes/PyMediaHubFilesTabOptions/#description","text":"This class represents the MediaHub Files tab options.","title":"Description"},{"location":"api/classes/PyMediaHubFilesTabOptions/#properties","text":"Name Description bit_depth Import bit depth value. Possible values are 8, 10, 12, 16, 32, and From Source. cache_and_proxies_all_versions Generate caches and proxies for all versions instead of the current one on import. cache_mode Cache media on import. colour_mgmt_display Import colour management Display name. Can only be set while in View Transform mode. colour_mgmt_invert Import colour management Invert status. Can only be set while in View Transform mode. colour_mgmt_mode Import colour management Mode value. Possible values are Tag Only, Auto Convert, View Transform, and Use LUT. colour_mgmt_view Import colour management View name. Can only be set while in View Transform mode. colour_mgmt_working_space Import colour management Working Space name. Can only be set while in Auto Convert mode. frame_ratio Import frame ratio value. Returns None when resolution mode is not set to Resolution List. height Import height value. Returns None when resolution is set to Same as Source, Scaling Presets or Adaptive when based on width. multi_channel_mode Multi-Channel Mode to use upon import. pixel_ratio Import pixel ratio value. Returns None when resolution is not set to Same As Source. proxies_mode Generate proxies on import. resize_filter Import resizing filter value. Possible values are Lanczos, Shannon, Gaussian, Quadratic, Bicubic, Mitchell, Triangle, and Impulse. resize_mode Import resizing mode value. Possible values are Letterbox, Crop Edges, Fill, and Centre. resolution Set the resolution based on the name. Possible values are Custom Resolution, Project Res, Adaptive, Scaling Presets, Same as Source or a resolution with this format: HD 720 16:9 (1280 x 720) scaling_presets_value Import scaling presets value. Returns None when the resolution selector is not Scaling Presets. scan_mode Import scan mode value. Possible values are P, F1, F2, and From Source. sequence_mode Use the sequence mode to import a range of files. tagged_colour_space Import colour management Tagged Colour Space name in Tag Only, View Transform and Use LUT modes. It also represents the Input Colour Space name in Auto Convert mode. width Import width value. Returns None when resolution is set to Same as Source, Scaling Presets or Adaptive when based on height.","title":"Properties"},{"location":"api/classes/PyMediaHubFilesTabOptions/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubFilesTabOptions/#import_transform","text":"import_transform import_transform( (PyMediaHubFilesTabOptions)arg1, (str)file_path) -> None : Import a transform from a file.","title":"import_transform"},{"location":"api/classes/PyMediaHubFilesTabOptions/#set_tagged_colour_space","text":"set_tagged_colour_space set_tagged_colour_space( (PyMediaHubFilesTabOptions)arg1, (str)colour_space) -> None : Set the tagged colour space to use upon import.","title":"set_tagged_colour_space"},{"location":"api/classes/PyMediaHubProjectsEntry/","text":"Class: PyMediaHubProjectsEntry Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Object representing a clip in the MediaHub Projects tabs Properties Name Description attributes The attributes of a python object. parent The parent object of this object. path Returns the path of the clip uid Returns the Unique ID of the clip Methods clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"Class: PyMediaHubProjectsEntry"},{"location":"api/classes/PyMediaHubProjectsEntry/#class-pymediahubprojectsentry","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyMediaHubProjectsEntry"},{"location":"api/classes/PyMediaHubProjectsEntry/#description","text":"Object representing a clip in the MediaHub Projects tabs","title":"Description"},{"location":"api/classes/PyMediaHubProjectsEntry/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. path Returns the path of the clip uid Returns the Unique ID of the clip","title":"Properties"},{"location":"api/classes/PyMediaHubProjectsEntry/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubProjectsEntry/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyMediaHubProjectsEntry/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyMediaHubProjectsEntry/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyMediaHubProjectsEntry/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyMediaHubProjectsFolder/","text":"Class: PyMediaHubProjectsFolder Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Object representing a folder in the MediaHub Projects tabs Properties Name Description attributes The attributes of a python object. parent The parent object of this object. path Returns the path of the folder uid Returns the Unique ID of the folder Methods clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"Class: PyMediaHubProjectsFolder"},{"location":"api/classes/PyMediaHubProjectsFolder/#class-pymediahubprojectsfolder","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyMediaHubProjectsFolder"},{"location":"api/classes/PyMediaHubProjectsFolder/#description","text":"Object representing a folder in the MediaHub Projects tabs","title":"Description"},{"location":"api/classes/PyMediaHubProjectsFolder/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. path Returns the path of the folder uid Returns the Unique ID of the folder","title":"Properties"},{"location":"api/classes/PyMediaHubProjectsFolder/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubProjectsFolder/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyMediaHubProjectsFolder/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyMediaHubProjectsFolder/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyMediaHubProjectsFolder/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyMediaHubTab/","text":"Class: PyMediaHubTab Module : flame Inherits from : instance, object Description This class represents a MediaHub tab. Methods get_path get_path get_path( (PyMediaHubTab)arg1) -> str : Return the MediaHub tab current path. set_path set_path set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool : Set the MediaHub tab current path. If allow_partial_success is True, the path will be set to the last valid folder in the path.","title":"Class: PyMediaHubTab"},{"location":"api/classes/PyMediaHubTab/#class-pymediahubtab","text":"Module : flame Inherits from : instance, object","title":"Class: PyMediaHubTab"},{"location":"api/classes/PyMediaHubTab/#description","text":"This class represents a MediaHub tab.","title":"Description"},{"location":"api/classes/PyMediaHubTab/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubTab/#get_path","text":"get_path get_path( (PyMediaHubTab)arg1) -> str : Return the MediaHub tab current path.","title":"get_path"},{"location":"api/classes/PyMediaHubTab/#set_path","text":"set_path set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool : Set the MediaHub tab current path. If allow_partial_success is True, the path will be set to the last valid folder in the path.","title":"set_path"},{"location":"api/classes/PyMediaPanel/","text":"Class: PyMediaPanel Module : flame Inherits from : instance, object Description This class represents the media panel. Properties Name Description dual The dual view status of the media panel. full_height The full height status of the media panel. full_width The full width status of the media panel. selected_entries A list of PyObject currently selected. visible The visible status of the media panel. Methods copy copy copy( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : Copy a PyObject or a list of PyObjects from the Media Panel to a destination inside the Media Panel.Return a list of the copied PyObjects.Keyword arguments: source_entries -- The PyObject or list of PyObjects to copy. destination -- The PyObject that acts as destination. duplicate_action -- Action to take when finding an object with the same name (add or replace). move move move( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : Move a PyObject or a list of PyObjects from the Media Panel to a destination inside the Media Panel. Return a list of the moved PyObjects. Keyword arguments: source_entries -- The PyObject or list of PyObjects to move. destination -- The PyObject that acts as destination. duplicate_action -- Action to take when finding an object with the same name (add or replace).","title":"Class: PyMediaPanel"},{"location":"api/classes/PyMediaPanel/#class-pymediapanel","text":"Module : flame Inherits from : instance, object","title":"Class: PyMediaPanel"},{"location":"api/classes/PyMediaPanel/#description","text":"This class represents the media panel.","title":"Description"},{"location":"api/classes/PyMediaPanel/#properties","text":"Name Description dual The dual view status of the media panel. full_height The full height status of the media panel. full_width The full width status of the media panel. selected_entries A list of PyObject currently selected. visible The visible status of the media panel.","title":"Properties"},{"location":"api/classes/PyMediaPanel/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaPanel/#copy","text":"copy copy( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : Copy a PyObject or a list of PyObjects from the Media Panel to a destination inside the Media Panel.Return a list of the copied PyObjects.Keyword arguments: source_entries -- The PyObject or list of PyObjects to copy. destination -- The PyObject that acts as destination. duplicate_action -- Action to take when finding an object with the same name (add or replace).","title":"copy"},{"location":"api/classes/PyMediaPanel/#move","text":"move move( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : Move a PyObject or a list of PyObjects from the Media Panel to a destination inside the Media Panel. Return a list of the moved PyObjects. Keyword arguments: source_entries -- The PyObject or list of PyObjects to move. destination -- The PyObject that acts as destination. duplicate_action -- Action to take when finding an object with the same name (add or replace).","title":"move"},{"location":"api/classes/PyMessages/","text":"Class: PyMessages Module : flame Inherits from : instance, object Description Module handling message bar in application UI. Methods clear_console clear_console clear_console( (PyMessages)arg1) -> None : Remove currently displayed message in the message bar. show_in_console show_in_console show_in_console( (PyMessages)arg1, (str)message [, (str)type='info' [, (int)duration=-1]]) -> None : Display an informative message in application message bar. message -- Message string to display. type -- Message type can be info, warning, or error. duration -- An optional time in seconds to keep message on screen. show_in_dialog show_in_dialog show_in_dialog( (PyMessages)arg1, (str)title, (str)message, (str)type, (list)buttons [, (str)cancel_button='']) -> str : Display a custom dialog with a selection of options. Keywords argument: title -- The title of the dialog. message -- The message displayed in the centre of the dialog. type -- The type of dialog. Can be error, info, question, or warning. buttons -- The list of titles used to refer to the options cancel_button -- The text displayed in the cancel option","title":"Class: PyMessages"},{"location":"api/classes/PyMessages/#class-pymessages","text":"Module : flame Inherits from : instance, object","title":"Class: PyMessages"},{"location":"api/classes/PyMessages/#description","text":"Module handling message bar in application UI.","title":"Description"},{"location":"api/classes/PyMessages/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMessages/#clear_console","text":"clear_console clear_console( (PyMessages)arg1) -> None : Remove currently displayed message in the message bar.","title":"clear_console"},{"location":"api/classes/PyMessages/#show_in_console","text":"show_in_console show_in_console( (PyMessages)arg1, (str)message [, (str)type='info' [, (int)duration=-1]]) -> None : Display an informative message in application message bar. message -- Message string to display. type -- Message type can be info, warning, or error. duration -- An optional time in seconds to keep message on screen.","title":"show_in_console"},{"location":"api/classes/PyMessages/#show_in_dialog","text":"show_in_dialog show_in_dialog( (PyMessages)arg1, (str)title, (str)message, (str)type, (list)buttons [, (str)cancel_button='']) -> str : Display a custom dialog with a selection of options. Keywords argument: title -- The title of the dialog. message -- The message displayed in the centre of the dialog. type -- The type of dialog. Can be error, info, question, or warning. buttons -- The list of titles used to refer to the options cancel_button -- The text displayed in the cancel option","title":"show_in_dialog"},{"location":"api/classes/PyMetadataNode/","text":"Class: PyMetadataNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Class derived from PyNode. This class represents a Metadata node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. load_node_setup load_node_setup load_node_setup( (PyMetadataNode)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)replaced_keys=True [, (bool)update_tokens=True]]]]]) -> bool : Load a Metadata Node setup. Keywords argument: file_name -- the path and file name of the setup. edited_keys -- apply edited keys from the setup. discarded_keys -- apply discarded keys from the setup. added_keys -- apply added keys from the setup. replaced_keys -- apply replaced keys from the setup. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments. set_metadata_discarded set_metadata_discarded set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key. set_metadata_key set_metadata_key set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value. set_metadata_value set_metadata_value set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value.","title":"Class: PyMetadataNode"},{"location":"api/classes/PyMetadataNode/#class-pymetadatanode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyMetadataNode"},{"location":"api/classes/PyMetadataNode/#description","text":"Class derived from PyNode. This class represents a Metadata node.","title":"Description"},{"location":"api/classes/PyMetadataNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyMetadataNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMetadataNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyMetadataNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyMetadataNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyMetadataNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyMetadataNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyMetadataNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyMetadataNode)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)replaced_keys=True [, (bool)update_tokens=True]]]]]) -> bool : Load a Metadata Node setup. Keywords argument: file_name -- the path and file name of the setup. edited_keys -- apply edited keys from the setup. discarded_keys -- apply discarded keys from the setup. added_keys -- apply added keys from the setup. replaced_keys -- apply replaced keys from the setup.","title":"load_node_setup"},{"location":"api/classes/PyMetadataNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyMetadataNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyMetadataNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyMetadataNode/#set_metadata_discarded","text":"set_metadata_discarded set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key.","title":"set_metadata_discarded"},{"location":"api/classes/PyMetadataNode/#set_metadata_key","text":"set_metadata_key set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value.","title":"set_metadata_key"},{"location":"api/classes/PyMetadataNode/#set_metadata_value","text":"set_metadata_value set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value.","title":"set_metadata_value"},{"location":"api/classes/PyMetadataTimelineFX/","text":"Class: PyMetadataTimelineFX Module : flame Inherits from : PyTimelineFX , PyFlameObject , instance, object Description Object representing a Metadata Timeline FX. Properties Name Description attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. parent The parent object of this object. type Return the type of the Timeline FX. Methods clear_maps_cache_media clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media. flush_maps_cache_media flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.) get_metadata get_metadata get_metadata( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (int)frame=1]]) -> object : Return the metadata of a Metadata Timeline FX. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. frame -- Frame number. The first exposed frame being 1. If not specified, the current frame is used. load_setup load_setup load_setup( (PyMetadataTimelineFX)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)update_tokens=True]]]]) -> bool : Load a Metadata Timeline FX setup. Keywords argument: file_name -- the path and file name of the setup. edited_keys -- apply edited keys from the setup. discarded_keys -- apply discarded keys from the setup. added_keys -- apply added keys from the setup. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting. save_setup save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_metadata_discarded set_metadata_discarded set_metadata_discarded( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (bool)discarded=True]]) -> None : Discard key from the metadata output of a Metadata Timeline FX. Keywords argument: key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the Metadata Timeline FX output, False to restore the key. set_metadata_key set_metadata_key set_metadata_key( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (object)name=None]]) -> None : Rename a metadata key on a Metadata Timeline FX. Keyword arguments: key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value. set_metadata_value set_metadata_value set_metadata_value( (PyMetadataTimelineFX)arg1, (str)key [, (object)value=None]) -> None : Set the metadata on a Metadata Timeline FX. Keywords argument: key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. slide_keyframes slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. sync_connected_segments sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"Class: PyMetadataTimelineFX"},{"location":"api/classes/PyMetadataTimelineFX/#class-pymetadatatimelinefx","text":"Module : flame Inherits from : PyTimelineFX , PyFlameObject , instance, object","title":"Class: PyMetadataTimelineFX"},{"location":"api/classes/PyMetadataTimelineFX/#description","text":"Object representing a Metadata Timeline FX.","title":"Description"},{"location":"api/classes/PyMetadataTimelineFX/#properties","text":"Name Description attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. parent The parent object of this object. type Return the type of the Timeline FX.","title":"Properties"},{"location":"api/classes/PyMetadataTimelineFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMetadataTimelineFX/#clear_maps_cache_media","text":"clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.","title":"clear_maps_cache_media"},{"location":"api/classes/PyMetadataTimelineFX/#flush_maps_cache_media","text":"flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.)","title":"flush_maps_cache_media"},{"location":"api/classes/PyMetadataTimelineFX/#get_metadata","text":"get_metadata get_metadata( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (int)frame=1]]) -> object : Return the metadata of a Metadata Timeline FX. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. frame -- Frame number. The first exposed frame being 1. If not specified, the current frame is used.","title":"get_metadata"},{"location":"api/classes/PyMetadataTimelineFX/#load_setup","text":"load_setup load_setup( (PyMetadataTimelineFX)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)update_tokens=True]]]]) -> bool : Load a Metadata Timeline FX setup. Keywords argument: file_name -- the path and file name of the setup. edited_keys -- apply edited keys from the setup. discarded_keys -- apply discarded keys from the setup. added_keys -- apply added keys from the setup.","title":"load_setup"},{"location":"api/classes/PyMetadataTimelineFX/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyMetadataTimelineFX/#save_setup","text":"save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_setup"},{"location":"api/classes/PyMetadataTimelineFX/#set_metadata_discarded","text":"set_metadata_discarded set_metadata_discarded( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (bool)discarded=True]]) -> None : Discard key from the metadata output of a Metadata Timeline FX. Keywords argument: key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the Metadata Timeline FX output, False to restore the key.","title":"set_metadata_discarded"},{"location":"api/classes/PyMetadataTimelineFX/#set_metadata_key","text":"set_metadata_key set_metadata_key( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (object)name=None]]) -> None : Rename a metadata key on a Metadata Timeline FX. Keyword arguments: key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value.","title":"set_metadata_key"},{"location":"api/classes/PyMetadataTimelineFX/#set_metadata_value","text":"set_metadata_value set_metadata_value( (PyMetadataTimelineFX)arg1, (str)key [, (object)value=None]) -> None : Set the metadata on a Metadata Timeline FX. Keywords argument: key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value.","title":"set_metadata_value"},{"location":"api/classes/PyMetadataTimelineFX/#slide_keyframes","text":"slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.","title":"slide_keyframes"},{"location":"api/classes/PyMetadataTimelineFX/#sync_connected_segments","text":"sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"sync_connected_segments"},{"location":"api/classes/PyMetadataValue/","text":"Class: PyMetadataValue Module : flame Inherits from : instance, object Description This class holds the metadata of a specific data type. Properties Name Description type Return the data type of the metadata Methods get_value get_value get_value( (PyMetadataValue)arg1) -> object : Get the metadata value. set_value set_value set_value( (PyMetadataValue)arg1, (object)value) -> None : Set the metadata value.","title":"Class: PyMetadataValue"},{"location":"api/classes/PyMetadataValue/#class-pymetadatavalue","text":"Module : flame Inherits from : instance, object","title":"Class: PyMetadataValue"},{"location":"api/classes/PyMetadataValue/#description","text":"This class holds the metadata of a specific data type.","title":"Description"},{"location":"api/classes/PyMetadataValue/#properties","text":"Name Description type Return the data type of the metadata","title":"Properties"},{"location":"api/classes/PyMetadataValue/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMetadataValue/#get_value","text":"get_value get_value( (PyMetadataValue)arg1) -> object : Get the metadata value.","title":"get_value"},{"location":"api/classes/PyMetadataValue/#set_value","text":"set_value set_value( (PyMetadataValue)arg1, (object)value) -> None : Set the metadata value.","title":"set_value"},{"location":"api/classes/PyMorphNode/","text":"Class: PyMorphNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Object representing a Morph node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments. set_mix_to_range set_mix_to_range set_mix_to_range( (PyMorphNode)arg1) -> None : Move the first and last keyframes of the mix curve to the range's first and last frame.","title":"Class: PyMorphNode"},{"location":"api/classes/PyMorphNode/#class-pymorphnode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyMorphNode"},{"location":"api/classes/PyMorphNode/#description","text":"Object representing a Morph node.","title":"Description"},{"location":"api/classes/PyMorphNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyMorphNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMorphNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyMorphNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyMorphNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyMorphNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyMorphNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyMorphNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyMorphNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyMorphNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyMorphNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyMorphNode/#set_mix_to_range","text":"set_mix_to_range set_mix_to_range( (PyMorphNode)arg1) -> None : Move the first and last keyframes of the mix curve to the range's first and last frame.","title":"set_mix_to_range"},{"location":"api/classes/PyNode/","text":"Class: PyNode Module : flame Inherits from : PyFlameObject , instance, object Description Object representing a Node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyNode"},{"location":"api/classes/PyNode/#class-pynode","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyNode"},{"location":"api/classes/PyNode/#description","text":"Object representing a Node.","title":"Description"},{"location":"api/classes/PyNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyOFXNode/","text":"Class: PyOFXNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Object representing a OpenFX node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. change_plugin change_plugin change_plugin( (PyOFXNode)arg1, (str)plugin_name) -> bool : Change the active plugin for the openFX node clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyOFXNode"},{"location":"api/classes/PyOFXNode/#class-pyofxnode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyOFXNode"},{"location":"api/classes/PyOFXNode/#description","text":"Object representing a OpenFX node.","title":"Description"},{"location":"api/classes/PyOFXNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyOFXNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyOFXNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyOFXNode/#change_plugin","text":"change_plugin change_plugin( (PyOFXNode)arg1, (str)plugin_name) -> bool : Change the active plugin for the openFX node","title":"change_plugin"},{"location":"api/classes/PyOFXNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyOFXNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyOFXNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyOFXNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyOFXNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyOFXNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyOFXNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyOFXNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyPaintNode/","text":"Class: PyPaintNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Object representing a Paint node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods add_source add_source add_source( (PyPaintNode)arg1) -> object : Add a Source layer to a Paint node. cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyPaintNode"},{"location":"api/classes/PyPaintNode/#class-pypaintnode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyPaintNode"},{"location":"api/classes/PyPaintNode/#description","text":"Object representing a Paint node.","title":"Description"},{"location":"api/classes/PyPaintNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyPaintNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyPaintNode/#add_source","text":"add_source add_source( (PyPaintNode)arg1) -> object : Add a Source layer to a Paint node.","title":"add_source"},{"location":"api/classes/PyPaintNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyPaintNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyPaintNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyPaintNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyPaintNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyPaintNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyPaintNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyPaintNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyPaintNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyProject/","text":"Class: PyProject Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Object representing a Project. Properties Name Description attributes The attributes of a python object. current_workspace Return the current Workspace. description Return the Project description. media_folder The path where the project media is located. name Return the Project name. nickname Return the Project nickname. parent The parent object of this object. project_folder The path where the project is located. project_name Deprecated / use name instead setups_folder The path where the project setups are located. shared_libraries Return a list of Shared Libraries inside the Project. workspaces_count Return the amount of Project Workspaces. Methods clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. create_shared_library create_shared_library create_shared_library( (PyProject)arg1, (str)name) -> object : Create a new Shared Library in the Project. export_ocio_config export_ocio_config export_ocio_config( (PyProject)arg1, (str)config_name [, (str)destination_folder='' [, (bool)overwrite_existing=False [, (bool)export_as_locked=False [, (bool)generate_ocioz=False]]]]) -> bool : Export the OCIO config file. Keyword arguments: config_name -- Specifies the name that will be written inside the exported OCIO config and used as the parent folder name where the config will be exported. It should not contain the '.ocio' extension. Mandatory. destination_folder -- Specifies the absolute destination folder for the exported OCIO config. It will use the default colour management shared path if empty. overwrite_existing -- Specifies if the export should overwrite an existing OCIO config with the same name located in the same destination_folder. export_as_locked -- Specifies if the exported OCIO config should be locked (the 'LockedPolicy' parameter inside the settings.cfg sidecar file). generate_ocioz -- Specifies if an OCIOZ archive should be created alongside the exported OCIO config. get_context_variables get_context_variables get_context_variables( (PyProject)arg1) -> dict : Get the context variables in a dictionary. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. refresh_shared_libraries refresh_shared_libraries refresh_shared_libraries( (PyProject)arg1) -> bool : Refresh the Shared Libraries list in the Media Panel. reload_ocio_config reload_ocio_config reload_ocio_config( (PyProject)arg1 [, (bool)reset_colour_policy=False]) -> bool : Reload the OCIO config file. Keyword argument: reset_colour_policy -- Delete the project's custom colour spaces, roles, and rules (false by default). reset_context_variables reset_context_variables reset_context_variables( (PyProject)arg1) -> None : Reset the context variables to their initial state from the ocio config. set_context_variable set_context_variable set_context_variable( (PyProject)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable.","title":"Class: PyProject"},{"location":"api/classes/PyProject/#class-pyproject","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyProject"},{"location":"api/classes/PyProject/#description","text":"Object representing a Project.","title":"Description"},{"location":"api/classes/PyProject/#properties","text":"Name Description attributes The attributes of a python object. current_workspace Return the current Workspace. description Return the Project description. media_folder The path where the project media is located. name Return the Project name. nickname Return the Project nickname. parent The parent object of this object. project_folder The path where the project is located. project_name Deprecated / use name instead setups_folder The path where the project setups are located. shared_libraries Return a list of Shared Libraries inside the Project. workspaces_count Return the amount of Project Workspaces.","title":"Properties"},{"location":"api/classes/PyProject/#methods","text":"","title":"Methods"},{"location":"api/classes/PyProject/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyProject/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyProject/#create_shared_library","text":"create_shared_library create_shared_library( (PyProject)arg1, (str)name) -> object : Create a new Shared Library in the Project.","title":"create_shared_library"},{"location":"api/classes/PyProject/#export_ocio_config","text":"export_ocio_config export_ocio_config( (PyProject)arg1, (str)config_name [, (str)destination_folder='' [, (bool)overwrite_existing=False [, (bool)export_as_locked=False [, (bool)generate_ocioz=False]]]]) -> bool : Export the OCIO config file. Keyword arguments: config_name -- Specifies the name that will be written inside the exported OCIO config and used as the parent folder name where the config will be exported. It should not contain the '.ocio' extension. Mandatory. destination_folder -- Specifies the absolute destination folder for the exported OCIO config. It will use the default colour management shared path if empty. overwrite_existing -- Specifies if the export should overwrite an existing OCIO config with the same name located in the same destination_folder. export_as_locked -- Specifies if the exported OCIO config should be locked (the 'LockedPolicy' parameter inside the settings.cfg sidecar file). generate_ocioz -- Specifies if an OCIOZ archive should be created alongside the exported OCIO config.","title":"export_ocio_config"},{"location":"api/classes/PyProject/#get_context_variables","text":"get_context_variables get_context_variables( (PyProject)arg1) -> dict : Get the context variables in a dictionary.","title":"get_context_variables"},{"location":"api/classes/PyProject/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyProject/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyProject/#refresh_shared_libraries","text":"refresh_shared_libraries refresh_shared_libraries( (PyProject)arg1) -> bool : Refresh the Shared Libraries list in the Media Panel.","title":"refresh_shared_libraries"},{"location":"api/classes/PyProject/#reload_ocio_config","text":"reload_ocio_config reload_ocio_config( (PyProject)arg1 [, (bool)reset_colour_policy=False]) -> bool : Reload the OCIO config file. Keyword argument: reset_colour_policy -- Delete the project's custom colour spaces, roles, and rules (false by default).","title":"reload_ocio_config"},{"location":"api/classes/PyProject/#reset_context_variables","text":"reset_context_variables reset_context_variables( (PyProject)arg1) -> None : Reset the context variables to their initial state from the ocio config.","title":"reset_context_variables"},{"location":"api/classes/PyProject/#set_context_variable","text":"set_context_variable set_context_variable( (PyProject)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable.","title":"set_context_variable"},{"location":"api/classes/PyProjectSelector/","text":"Class: PyProjectSelector Module : flame Inherits from : instance, object Description Object representing the Project manager. Properties Name Description current_project The PyProject linked to the current Project.","title":"Class: PyProjectSelector"},{"location":"api/classes/PyProjectSelector/#class-pyprojectselector","text":"Module : flame Inherits from : instance, object","title":"Class: PyProjectSelector"},{"location":"api/classes/PyProjectSelector/#description","text":"Object representing the Project manager.","title":"Description"},{"location":"api/classes/PyProjectSelector/#properties","text":"Name Description current_project The PyProject linked to the current Project.","title":"Properties"},{"location":"api/classes/PyReadFileNode/","text":"Class: PyReadFileNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Class derived from PyNode. This class represents a ReadFile node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyReadFileNode"},{"location":"api/classes/PyReadFileNode/#class-pyreadfilenode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyReadFileNode"},{"location":"api/classes/PyReadFileNode/#description","text":"Class derived from PyNode. This class represents a ReadFile node.","title":"Description"},{"location":"api/classes/PyReadFileNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyReadFileNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyReadFileNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyReadFileNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyReadFileNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyReadFileNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyReadFileNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyReadFileNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyReadFileNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyReadFileNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyReadFileNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyReel/","text":"Class: PyReel Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Object representing a Reel. Properties Name Description attributes The attributes of a python object. children Return a list of the immediate children of the current object. clips Return a list of Clip objects that are immediate children of the current object. parent The parent object of this object. sequences Return a list of Sequence objects that are immediate children of the current object. type Return the Reel type (Reel, Schematic, Sequences, Shelf). Methods clear clear clear( (PyReel)arg1 [, (bool)confirm=True]) -> bool : Clear the Reel content. clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. create_sequence create_sequence create_sequence( (PyReel)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by *frame_rate*. duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by *frame_rate*. If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all *audio_tracks*. False for mono tracks, True for stereo. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. save save save( (PyReel)arg1) -> bool : Save the Reel to the defined save destination.","title":"Class: PyReel"},{"location":"api/classes/PyReel/#class-pyreel","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyReel"},{"location":"api/classes/PyReel/#description","text":"Object representing a Reel.","title":"Description"},{"location":"api/classes/PyReel/#properties","text":"Name Description attributes The attributes of a python object. children Return a list of the immediate children of the current object. clips Return a list of Clip objects that are immediate children of the current object. parent The parent object of this object. sequences Return a list of Sequence objects that are immediate children of the current object. type Return the Reel type (Reel, Schematic, Sequences, Shelf).","title":"Properties"},{"location":"api/classes/PyReel/#methods","text":"","title":"Methods"},{"location":"api/classes/PyReel/#clear","text":"clear clear( (PyReel)arg1 [, (bool)confirm=True]) -> bool : Clear the Reel content.","title":"clear"},{"location":"api/classes/PyReel/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyReel/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyReel/#create_sequence","text":"create_sequence create_sequence( (PyReel)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by *frame_rate*. duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by *frame_rate*. If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all *audio_tracks*. False for mono tracks, True for stereo.","title":"create_sequence"},{"location":"api/classes/PyReel/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyReel/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyReel/#save","text":"save save( (PyReel)arg1) -> bool : Save the Reel to the defined save destination.","title":"save"},{"location":"api/classes/PyReelGroup/","text":"Class: PyReelGroup Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Object representing a Reel Group. Properties Name Description attributes The attributes of a python object. children Return a list of the immediate children of the current object. parent The parent object of this object. reels Return a list of Reel objects that are immediate children of the current object. Methods clear clear clear( (PyReelGroup)arg1 [, (bool)confirm=True]) -> bool : Clear the Reel Group content. clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. create_reel create_reel create_reel( (PyReelGroup)arg1, (str)name [, (bool)sequence=False]) -> object : Create a new Reel inside a Reel Group. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. save save save( (PyReelGroup)arg1) -> bool : Save the Reel Group to the defined save destination.","title":"Class: PyReelGroup"},{"location":"api/classes/PyReelGroup/#class-pyreelgroup","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyReelGroup"},{"location":"api/classes/PyReelGroup/#description","text":"Object representing a Reel Group.","title":"Description"},{"location":"api/classes/PyReelGroup/#properties","text":"Name Description attributes The attributes of a python object. children Return a list of the immediate children of the current object. parent The parent object of this object. reels Return a list of Reel objects that are immediate children of the current object.","title":"Properties"},{"location":"api/classes/PyReelGroup/#methods","text":"","title":"Methods"},{"location":"api/classes/PyReelGroup/#clear","text":"clear clear( (PyReelGroup)arg1 [, (bool)confirm=True]) -> bool : Clear the Reel Group content.","title":"clear"},{"location":"api/classes/PyReelGroup/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyReelGroup/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyReelGroup/#create_reel","text":"create_reel create_reel( (PyReelGroup)arg1, (str)name [, (bool)sequence=False]) -> object : Create a new Reel inside a Reel Group.","title":"create_reel"},{"location":"api/classes/PyReelGroup/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyReelGroup/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyReelGroup/#save","text":"save save( (PyReelGroup)arg1) -> bool : Save the Reel Group to the defined save destination.","title":"save"},{"location":"api/classes/PyRenderNode/","text":"Class: PyRenderNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Class derived from PyNode. This class represents a Render node. Properties Name Description attributes The attributes of a python object. channels The channels attribute is a list of tuples, where each tuple is made of a socket name and its channel name. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_channel_name set_channel_name set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None : Rename a channel, using its index or front channel name as the index key. Keyword arguments: channel -- The channel to rename. Can be the channel index or the current name of the channel's front socket. name -- The new name of the channel. The type is either a string or a tuple. A Write File node always takes a string. A Render node takes a string or a tuple. In a Render node, a string only sets the name of the channel's front socket; the function creates the name of the matte socket by appending '_alpha' to 'name'. In the UI, the channel is flagged 'Sync'. A Write File node has only one socket per channel, and requires only a string to set a socket name. In a Render node, a tuple sets the names of the front and matte sockets. In the UI, the channel is not flagged 'Sync'. A Write File node does not accept a tuple. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments. set_metadata_discarded set_metadata_discarded set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key. set_metadata_key set_metadata_key set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value. set_metadata_value set_metadata_value set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. is_dynamic -- Set the Metadata value to be resolved dynamically if it contains tokens.","title":"Class: PyRenderNode"},{"location":"api/classes/PyRenderNode/#class-pyrendernode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyRenderNode"},{"location":"api/classes/PyRenderNode/#description","text":"Class derived from PyNode. This class represents a Render node.","title":"Description"},{"location":"api/classes/PyRenderNode/#properties","text":"Name Description attributes The attributes of a python object. channels The channels attribute is a list of tuples, where each tuple is made of a socket name and its channel name. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyRenderNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyRenderNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyRenderNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyRenderNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyRenderNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyRenderNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyRenderNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyRenderNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyRenderNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyRenderNode/#set_channel_name","text":"set_channel_name set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None : Rename a channel, using its index or front channel name as the index key. Keyword arguments: channel -- The channel to rename. Can be the channel index or the current name of the channel's front socket. name -- The new name of the channel. The type is either a string or a tuple. A Write File node always takes a string. A Render node takes a string or a tuple. In a Render node, a string only sets the name of the channel's front socket; the function creates the name of the matte socket by appending '_alpha' to 'name'. In the UI, the channel is flagged 'Sync'. A Write File node has only one socket per channel, and requires only a string to set a socket name. In a Render node, a tuple sets the names of the front and matte sockets. In the UI, the channel is not flagged 'Sync'. A Write File node does not accept a tuple.","title":"set_channel_name"},{"location":"api/classes/PyRenderNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyRenderNode/#set_metadata_discarded","text":"set_metadata_discarded set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key.","title":"set_metadata_discarded"},{"location":"api/classes/PyRenderNode/#set_metadata_key","text":"set_metadata_key set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value.","title":"set_metadata_key"},{"location":"api/classes/PyRenderNode/#set_metadata_value","text":"set_metadata_value set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. is_dynamic -- Set the Metadata value to be resolved dynamically if it contains tokens.","title":"set_metadata_value"},{"location":"api/classes/PyResolution/","text":"Class: PyResolution Module : flame Inherits from : instance, object Description Object representing a resolution PyResolution() PyResolution(width, height, bit_depth, frame_ratio, scan_format) Properties Name Description bit_depth Return the resolution bit depth. frame_ratio Return the resolution frame ratio. height Return the resolution height. resolution Set the resolution based on its name in the UI. Possible values are: Custom Resolution Project Res Project Resolution A resolution, in the format used by the Resolution List in the UI. Example: HD 720 16:9 (1280 x 720) scan_mode Return the resolution scan mode. width Return the resolution width.","title":"Class: PyResolution"},{"location":"api/classes/PyResolution/#class-pyresolution","text":"Module : flame Inherits from : instance, object","title":"Class: PyResolution"},{"location":"api/classes/PyResolution/#description","text":"Object representing a resolution PyResolution() PyResolution(width, height, bit_depth, frame_ratio, scan_format)","title":"Description"},{"location":"api/classes/PyResolution/#properties","text":"Name Description bit_depth Return the resolution bit depth. frame_ratio Return the resolution frame ratio. height Return the resolution height. resolution Set the resolution based on its name in the UI. Possible values are: Custom Resolution Project Res Project Resolution A resolution, in the format used by the Resolution List in the UI. Example: HD 720 16:9 (1280 x 720) scan_mode Return the resolution scan mode. width Return the resolution width.","title":"Properties"},{"location":"api/classes/PySearch/","text":"Class: PySearch Module : flame Inherits from : instance, object Description This class represents the search. Properties Name Description use_weight Return true if the search sorting is done using weight. Methods activate_search_result activate_search_result activate_search_result( (PySearch)arg1, (str)name, (str)type [, (str)tab='Tools']) -> None : Activate a search result. search_results search_results search_results( (PySearch)arg1 [, (str)search_str='*' [, (str)tab='Tools']]) -> list : Search results that match a string. set_tool_favorite set_tool_favorite set_tool_favorite( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : Return the favorite status of a tool. set_tool_hidden set_tool_hidden set_tool_hidden( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : Return the hidden status of a tool. set_tool_weight set_tool_weight set_tool_weight( (PySearch)arg1, (str)arg2, (str)name, (int)type) -> None : Return the tool weight.","title":"Class: PySearch"},{"location":"api/classes/PySearch/#class-pysearch","text":"Module : flame Inherits from : instance, object","title":"Class: PySearch"},{"location":"api/classes/PySearch/#description","text":"This class represents the search.","title":"Description"},{"location":"api/classes/PySearch/#properties","text":"Name Description use_weight Return true if the search sorting is done using weight.","title":"Properties"},{"location":"api/classes/PySearch/#methods","text":"","title":"Methods"},{"location":"api/classes/PySearch/#activate_search_result","text":"activate_search_result activate_search_result( (PySearch)arg1, (str)name, (str)type [, (str)tab='Tools']) -> None : Activate a search result.","title":"activate_search_result"},{"location":"api/classes/PySearch/#search_results","text":"search_results search_results( (PySearch)arg1 [, (str)search_str='*' [, (str)tab='Tools']]) -> list : Search results that match a string.","title":"search_results"},{"location":"api/classes/PySearch/#set_tool_favorite","text":"set_tool_favorite set_tool_favorite( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : Return the favorite status of a tool.","title":"set_tool_favorite"},{"location":"api/classes/PySearch/#set_tool_hidden","text":"set_tool_hidden set_tool_hidden( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : Return the hidden status of a tool.","title":"set_tool_hidden"},{"location":"api/classes/PySearch/#set_tool_weight","text":"set_tool_weight set_tool_weight( (PySearch)arg1, (str)arg2, (str)name, (int)type) -> None : Return the tool weight.","title":"set_tool_weight"},{"location":"api/classes/PySegment/","text":"Class: PySegment Module : flame Inherits from : PyFlameObject , instance, object Description Object representing a Segment. Properties Name Description attributes The attributes of a python object. container_clip Return the current Matte mode. effect_types Return a list of available effect types for the segment effects Return a list of PyTimeline FX on the segment. file_path Return the file path of the Segment's source. groups Return a list of PySequenceGroups that contains the segment. head Return the amount of head of the Segment. markers Return a list of the segment's Markers. matte_channel Return the name of the Matte channel. matte_channels Return a list of all Matte channels. matte_mode Return the current Matte mode. original_source_uid Return the Clip's original source UID. parent The parent object of this object. record_duration Return the duration of the Segment. record_in Return the record time in of the Segment. record_out Return the record time out of the Segment. rgb_channel Return the name of the RGB channel. rgb_channels Return a list of all RGB channels source_audio_track Return the audio track of the source. source_bit_depth Return the Clip's bit depth. source_cached Return the Clip's cache status. source_colour_primaries Deduce the Clip's 'colour primaries' export attribute. source_duration Return the duration of the Segment's source. source_essence_uid Return the Clip's essence uid. source_frame_rate Return the Clip's frame rate. source_has_history Return the existence of history inside the Clip. source_height Return the Clip's height. source_in Return the source time in of the Segment. source_matrix_coefficients Deduce the Clip's 'matrix coefficients' export attribute. source_name Return the name of the Segment's source. source_out Return the source time out of the Segment. source_ratio Return the Clip's frame ratio. source_sample_rate Return the Clip's audio sample rate. source_scan_mode Return the Clip's scan mode. source_transfer_characteristics Deduce the Clip's 'transfer characteristics' export attribute. source_uid Return the Clip's source uid. source_unlinked Return the Clip's unlinked status. source_width Return the Clip's width. start_frame Return the start frame of the Segment. tail Return the amount of tail of the Segment. tape_name Return the tape name of the Segment. type Return the Segment type. version_uid Return the current version unique ID. version_uids Return a list of available version unique IDs. Methods change_start_frame change_start_frame change_start_frame( (PySegment)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : Modify the start frame of the segment. Keywords argument: start_frame -- New start frame of the segment. use_segment_connections -- Sync the start frame of connected segments. clear_colour clear_colour clear_colour( (PySegment)arg1) -> None : Clear the colour of the Segment. connected_segments connected_segments connected_segments( (PySegment)arg1 [, (str)scoping='all reels']) -> object : Return a list of the connected segments. Keywords argument: scoping -- Scopes of the sequences to query (all reels, sequences reels, current reel, current sequence). (Default:all reels) copy_to_media_panel copy_to_media_panel copy_to_media_panel( (PySegment)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject. create_connection create_connection create_connection( (PySegment)arg1) -> None : Create a connected segment connection. create_effect create_effect create_effect( (PySegment)arg1, (str)effect_type [, (str)after_effect_type='']) -> object : Add an effect of effect_type on the Segment. after_effect_type can be specified to insert the effect at a specific position. create_marker create_marker create_marker( (PySegment)arg1, (object)location) -> object : Create a Marker at the specified location on the Segment. create_unlinked_segment create_unlinked_segment create_unlinked_segment( (PySegment)arg1 [, (str)source_name='' [, (str)tape_name='' [, (object)start_time=0 [, (object)source_duration=0 [, (object)head=0 [, (str)file_path='' [, (int)source_audio_track=1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='Same As Sequence' [, (str)frame_rate='Same As Sequence' [, (object)timewarp_speed=None]]]]]]]]]]]]]]) -> None : Replace the gap with an unlinked source media segment. Keywords argument: source_name -- Name of the source. tape_name -- Tape name of the source. start_time -- Start time of the source. Must be a PyTime or a frame number. source_duration -- Length of the source. Must be a PyTime, a number of frames, or \"Infinite\". head -- Amount of head media to set on the segment. file_path -- File path to the media. source_audio_track -- Audio track from the source. width -- Width of the video media. (0 to use the sequence width) height -- Height of the video media. (0 to use the sequence height) ratio -- Frame ratio of the video media. (0.0 to use the sequence ratio) bit_depth -- Bit depth of the video media. (0 to use the sequence bit depth) scan_mode -- Scan mode of the video media. (P, F1, F2, or Same As Sequence) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps, Same As Sequence) timewarp_speed -- When defined, a timewarp is applied to the segment with the percentage of timewarp_speed. For audio segments, the speed must be greater than zero. duplicate_source duplicate_source duplicate_source( (PySegment)arg1) -> None : Insure that the segment's source is not shared anymore. get_colour_space get_colour_space get_colour_space( (PySegment)arg1 [, (PyTime)time=None]) -> str : Return the colour space at the requested time. Use record_in when no time is supplied. get_metadata get_metadata get_metadata( (PySegment)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : Return the metadata of the segment. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. time -- Must be a PyTime. If not specified, the segment start time is used. match match match( (PySegment)arg1, (PyArchiveEntry)destination [, (bool)preserve_handle=False [, (bool)use_sequence_info=True [, (bool)include_nested_content=False [, (bool)include_timeline_fx=False]]]]) -> object : Match out the media of the PySegment to the destination. Returns a PyClip or a list of PyClip (with the included_nested_content option). Keywords argument: destination -- The PyObject that acts as the destination. preserve_handle -- Prevent the unrolling of the media handles. use_sequence_info -- Copy sequence segment information to the new matched clip. include_nested_content -- Include all sources found inside a BFX or Matte Container. include_timeline_fx -- Copy the Timeline FX present on the original clip to the new matched clip. remove_connection remove_connection remove_connection( (PySegment)arg1) -> None : Remove the connected segment connection. set_gap_bars set_gap_bars set_gap_bars( (PySegment)arg1 [, (str)type='smpte' [, (bool)full_luminance=False [, (float)softness=0.0]]]) -> object : Create colour bars segment for the duration of the gap. Returns a new PySegment on success. Keywords argument: type -- smpte or pal. full_luminance -- bars created at 100 or 75 percent luminance. softness -- softness to apply between the bars. set_gap_colour set_gap_colour set_gap_colour( (PySegment)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : Create a colour source segment for the duration of the gap, or set the colour of an existing colour source. set_matte_channel set_matte_channel set_matte_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences' [, (str)matte_mode='Custom Matte']]]]) -> bool : Set the Matte channel of the source specified by channel_index or by channel_name if the matte_mode is set to Custom Matte. Keywords argument: channel_name -- Name of the channel found in matte_channels. channel_index -- Index of the channel found in matte_channels. scope -- Scope of the changes ( Follow Preferences, No Sharing, Follow Source Sharing, Follow Connected Segments). matte_mode -- Matte origin (Follow RGB, No Matte, Custom Matte). set_rgb_channel set_rgb_channel set_rgb_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences']]]) -> bool : Set the RGB channel of the source specified by channel_index or by channel_name Keywords argument: channel_name -- Name of the channel found in rgb_channels. channel_index -- Index of the channel found in rgb_channels. scope -- Scope of the changes ( Follow Preferences, No Sharing, Follow Source Sharing, Follow Connected Segments). set_version_uid set_version_uid set_version_uid( (PySegment)arg1, (str)version_uid [, (str)scope='Follow Source Sharing']) -> bool : Set the current version unique ID of the source. Keywords argument: version_uid -- version unique ID. scope -- Scope of the changes ( No Sharing, Follow Source Sharing, Follow Connected Segments). shared_source_segments shared_source_segments shared_source_segments( (PySegment)arg1) -> object : Return a list of the segments sharing this segment's source. slide_keyframes slide_keyframes slide_keyframes( (PySegment)arg1, (int)offset [, (bool)sync=False]) -> bool : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. slip slip slip( (PySegment)arg1, (int)offset [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]) -> bool : Slip the media of the PySegment. Keywords argument: offset -- Relative offset to slip the media. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop) smart_replace smart_replace smart_replace( (PySegment)arg1, (PyClip)source_clip) -> None : Replace the PySegment by the source_clip segment, including the Timeline FX. smart_replace_media smart_replace_media smart_replace_media( (PySegment)arg1, (PyClip)source_clip) -> None : Replace the media of PySegment by the source_clip segment, leaving the PySegment Timeline FX untouched sync_connected_segments sync_connected_segments sync_connected_segments( (PySegment)arg1) -> None : Sync connected segments with the Timeline FXs of the current segment. trim_head trim_head trim_head( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : Modify the amount of head of the PySegment. Keywords argument: offset -- Number of frames to add or remove from the head. ripple -- Enable to prevent gaps from appearing when performing a trim. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop) trim_tail trim_tail trim_tail( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : Modify the amount of tail of the PySegment. Keywords argument: offset -- Number of frames to add or remove from the tail. ripple -- Enable to prevent gaps from appearing when performing a trim. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop)","title":"Class: PySegment"},{"location":"api/classes/PySegment/#class-pysegment","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PySegment"},{"location":"api/classes/PySegment/#description","text":"Object representing a Segment.","title":"Description"},{"location":"api/classes/PySegment/#properties","text":"Name Description attributes The attributes of a python object. container_clip Return the current Matte mode. effect_types Return a list of available effect types for the segment effects Return a list of PyTimeline FX on the segment. file_path Return the file path of the Segment's source. groups Return a list of PySequenceGroups that contains the segment. head Return the amount of head of the Segment. markers Return a list of the segment's Markers. matte_channel Return the name of the Matte channel. matte_channels Return a list of all Matte channels. matte_mode Return the current Matte mode. original_source_uid Return the Clip's original source UID. parent The parent object of this object. record_duration Return the duration of the Segment. record_in Return the record time in of the Segment. record_out Return the record time out of the Segment. rgb_channel Return the name of the RGB channel. rgb_channels Return a list of all RGB channels source_audio_track Return the audio track of the source. source_bit_depth Return the Clip's bit depth. source_cached Return the Clip's cache status. source_colour_primaries Deduce the Clip's 'colour primaries' export attribute. source_duration Return the duration of the Segment's source. source_essence_uid Return the Clip's essence uid. source_frame_rate Return the Clip's frame rate. source_has_history Return the existence of history inside the Clip. source_height Return the Clip's height. source_in Return the source time in of the Segment. source_matrix_coefficients Deduce the Clip's 'matrix coefficients' export attribute. source_name Return the name of the Segment's source. source_out Return the source time out of the Segment. source_ratio Return the Clip's frame ratio. source_sample_rate Return the Clip's audio sample rate. source_scan_mode Return the Clip's scan mode. source_transfer_characteristics Deduce the Clip's 'transfer characteristics' export attribute. source_uid Return the Clip's source uid. source_unlinked Return the Clip's unlinked status. source_width Return the Clip's width. start_frame Return the start frame of the Segment. tail Return the amount of tail of the Segment. tape_name Return the tape name of the Segment. type Return the Segment type. version_uid Return the current version unique ID. version_uids Return a list of available version unique IDs.","title":"Properties"},{"location":"api/classes/PySegment/#methods","text":"","title":"Methods"},{"location":"api/classes/PySegment/#change_start_frame","text":"change_start_frame change_start_frame( (PySegment)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : Modify the start frame of the segment. Keywords argument: start_frame -- New start frame of the segment. use_segment_connections -- Sync the start frame of connected segments.","title":"change_start_frame"},{"location":"api/classes/PySegment/#clear_colour","text":"clear_colour clear_colour( (PySegment)arg1) -> None : Clear the colour of the Segment.","title":"clear_colour"},{"location":"api/classes/PySegment/#connected_segments","text":"connected_segments connected_segments( (PySegment)arg1 [, (str)scoping='all reels']) -> object : Return a list of the connected segments. Keywords argument: scoping -- Scopes of the sequences to query (all reels, sequences reels, current reel, current sequence). (Default:all reels)","title":"connected_segments"},{"location":"api/classes/PySegment/#copy_to_media_panel","text":"copy_to_media_panel copy_to_media_panel( (PySegment)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject.","title":"copy_to_media_panel"},{"location":"api/classes/PySegment/#create_connection","text":"create_connection create_connection( (PySegment)arg1) -> None : Create a connected segment connection.","title":"create_connection"},{"location":"api/classes/PySegment/#create_effect","text":"create_effect create_effect( (PySegment)arg1, (str)effect_type [, (str)after_effect_type='']) -> object : Add an effect of effect_type on the Segment. after_effect_type can be specified to insert the effect at a specific position.","title":"create_effect"},{"location":"api/classes/PySegment/#create_marker","text":"create_marker create_marker( (PySegment)arg1, (object)location) -> object : Create a Marker at the specified location on the Segment.","title":"create_marker"},{"location":"api/classes/PySegment/#create_unlinked_segment","text":"create_unlinked_segment create_unlinked_segment( (PySegment)arg1 [, (str)source_name='' [, (str)tape_name='' [, (object)start_time=0 [, (object)source_duration=0 [, (object)head=0 [, (str)file_path='' [, (int)source_audio_track=1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='Same As Sequence' [, (str)frame_rate='Same As Sequence' [, (object)timewarp_speed=None]]]]]]]]]]]]]]) -> None : Replace the gap with an unlinked source media segment. Keywords argument: source_name -- Name of the source. tape_name -- Tape name of the source. start_time -- Start time of the source. Must be a PyTime or a frame number. source_duration -- Length of the source. Must be a PyTime, a number of frames, or \"Infinite\". head -- Amount of head media to set on the segment. file_path -- File path to the media. source_audio_track -- Audio track from the source. width -- Width of the video media. (0 to use the sequence width) height -- Height of the video media. (0 to use the sequence height) ratio -- Frame ratio of the video media. (0.0 to use the sequence ratio) bit_depth -- Bit depth of the video media. (0 to use the sequence bit depth) scan_mode -- Scan mode of the video media. (P, F1, F2, or Same As Sequence) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps, Same As Sequence) timewarp_speed -- When defined, a timewarp is applied to the segment with the percentage of timewarp_speed. For audio segments, the speed must be greater than zero.","title":"create_unlinked_segment"},{"location":"api/classes/PySegment/#duplicate_source","text":"duplicate_source duplicate_source( (PySegment)arg1) -> None : Insure that the segment's source is not shared anymore.","title":"duplicate_source"},{"location":"api/classes/PySegment/#get_colour_space","text":"get_colour_space get_colour_space( (PySegment)arg1 [, (PyTime)time=None]) -> str : Return the colour space at the requested time. Use record_in when no time is supplied.","title":"get_colour_space"},{"location":"api/classes/PySegment/#get_metadata","text":"get_metadata get_metadata( (PySegment)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : Return the metadata of the segment. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. time -- Must be a PyTime. If not specified, the segment start time is used.","title":"get_metadata"},{"location":"api/classes/PySegment/#match","text":"match match( (PySegment)arg1, (PyArchiveEntry)destination [, (bool)preserve_handle=False [, (bool)use_sequence_info=True [, (bool)include_nested_content=False [, (bool)include_timeline_fx=False]]]]) -> object : Match out the media of the PySegment to the destination. Returns a PyClip or a list of PyClip (with the included_nested_content option). Keywords argument: destination -- The PyObject that acts as the destination. preserve_handle -- Prevent the unrolling of the media handles. use_sequence_info -- Copy sequence segment information to the new matched clip. include_nested_content -- Include all sources found inside a BFX or Matte Container. include_timeline_fx -- Copy the Timeline FX present on the original clip to the new matched clip.","title":"match"},{"location":"api/classes/PySegment/#remove_connection","text":"remove_connection remove_connection( (PySegment)arg1) -> None : Remove the connected segment connection.","title":"remove_connection"},{"location":"api/classes/PySegment/#set_gap_bars","text":"set_gap_bars set_gap_bars( (PySegment)arg1 [, (str)type='smpte' [, (bool)full_luminance=False [, (float)softness=0.0]]]) -> object : Create colour bars segment for the duration of the gap. Returns a new PySegment on success. Keywords argument: type -- smpte or pal. full_luminance -- bars created at 100 or 75 percent luminance. softness -- softness to apply between the bars.","title":"set_gap_bars"},{"location":"api/classes/PySegment/#set_gap_colour","text":"set_gap_colour set_gap_colour( (PySegment)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : Create a colour source segment for the duration of the gap, or set the colour of an existing colour source.","title":"set_gap_colour"},{"location":"api/classes/PySegment/#set_matte_channel","text":"set_matte_channel set_matte_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences' [, (str)matte_mode='Custom Matte']]]]) -> bool : Set the Matte channel of the source specified by channel_index or by channel_name if the matte_mode is set to Custom Matte. Keywords argument: channel_name -- Name of the channel found in matte_channels. channel_index -- Index of the channel found in matte_channels. scope -- Scope of the changes ( Follow Preferences, No Sharing, Follow Source Sharing, Follow Connected Segments). matte_mode -- Matte origin (Follow RGB, No Matte, Custom Matte).","title":"set_matte_channel"},{"location":"api/classes/PySegment/#set_rgb_channel","text":"set_rgb_channel set_rgb_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences']]]) -> bool : Set the RGB channel of the source specified by channel_index or by channel_name Keywords argument: channel_name -- Name of the channel found in rgb_channels. channel_index -- Index of the channel found in rgb_channels. scope -- Scope of the changes ( Follow Preferences, No Sharing, Follow Source Sharing, Follow Connected Segments).","title":"set_rgb_channel"},{"location":"api/classes/PySegment/#set_version_uid","text":"set_version_uid set_version_uid( (PySegment)arg1, (str)version_uid [, (str)scope='Follow Source Sharing']) -> bool : Set the current version unique ID of the source. Keywords argument: version_uid -- version unique ID. scope -- Scope of the changes ( No Sharing, Follow Source Sharing, Follow Connected Segments).","title":"set_version_uid"},{"location":"api/classes/PySegment/#shared_source_segments","text":"shared_source_segments shared_source_segments( (PySegment)arg1) -> object : Return a list of the segments sharing this segment's source.","title":"shared_source_segments"},{"location":"api/classes/PySegment/#slide_keyframes","text":"slide_keyframes slide_keyframes( (PySegment)arg1, (int)offset [, (bool)sync=False]) -> bool : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.","title":"slide_keyframes"},{"location":"api/classes/PySegment/#slip","text":"slip slip( (PySegment)arg1, (int)offset [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]) -> bool : Slip the media of the PySegment. Keywords argument: offset -- Relative offset to slip the media. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop)","title":"slip"},{"location":"api/classes/PySegment/#smart_replace","text":"smart_replace smart_replace( (PySegment)arg1, (PyClip)source_clip) -> None : Replace the PySegment by the source_clip segment, including the Timeline FX.","title":"smart_replace"},{"location":"api/classes/PySegment/#smart_replace_media","text":"smart_replace_media smart_replace_media( (PySegment)arg1, (PyClip)source_clip) -> None : Replace the media of PySegment by the source_clip segment, leaving the PySegment Timeline FX untouched","title":"smart_replace_media"},{"location":"api/classes/PySegment/#sync_connected_segments","text":"sync_connected_segments sync_connected_segments( (PySegment)arg1) -> None : Sync connected segments with the Timeline FXs of the current segment.","title":"sync_connected_segments"},{"location":"api/classes/PySegment/#trim_head","text":"trim_head trim_head( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : Modify the amount of head of the PySegment. Keywords argument: offset -- Number of frames to add or remove from the head. ripple -- Enable to prevent gaps from appearing when performing a trim. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop)","title":"trim_head"},{"location":"api/classes/PySegment/#trim_tail","text":"trim_tail trim_tail( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : Modify the amount of tail of the PySegment. Keywords argument: offset -- Number of frames to add or remove from the tail. ripple -- Enable to prevent gaps from appearing when performing a trim. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop)","title":"trim_tail"},{"location":"api/classes/PySequence/","text":"Class: PySequence Module : flame Inherits from : PyClip , PyArchiveEntry , PyFlameObject , instance, object Description Object representing a Sequence. Properties Name Description archive_date Return the Clip's last archive date. archive_error Return the Clip's last archive error. attributes The attributes of a python object. audio_tracks Return a list of the Clip's Audio Tracks. bit_depth Return the Clip's bit depth. cached Return the Clip's cache status. colour_primaries Deduce the Clip's 'colour primaries' export attribute. creation_date Return the Clip's creation date. duration Return the Clip's duration. essence_uid Return the Clip's essence uid. frame_rate Return the Clip's frame rate. groups Return a list of the sequence's PySequenceGroups. has_deliverables Return the existence of deliverables on the Clip. has_history Return the existence of history inside the Clip. height Return the Clip's height. markers Return a list of the Clip's Markers. matrix_coefficients Deduce the Clip's 'matrix coefficients' export attribute. original_source_uid Return the Clip's original source UID. parent The parent object of this object. proxy_resolution Return the Clip's proxy resolution if it has proxies. ratio Return the Clip's frame ratio. sample_rate Return the Clip's audio sample rate. scan_mode Return the Clip's scan mode. source_uid Return the Clip's source uid. start_frame Return the Clip's start frame. subtitles Return a list of the Clip's Subtitles Tracks. transfer_characteristics Deduce the Clip's 'transfer characteristics' export attribute. unlinked Return the Clip's unlinked status. versions Return a list of the Clip's versions. width Return the Clip's width. Methods cache_media cache_media cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Cache the Clip's linked media. Keyword argument: mode -- Determine the version to cache (currently selected or all versions). All Versions is only useful with to multi-version clips (Current, All Versions) change_dominance change_dominance change_dominance( (PyClip)arg1, (str)scan_mode) -> None : Change the Clip's dominance. Changes only the clip's metadata. Keyword argument: scan_mode -- Field dominance. (P, F1, F2) change_start_frame change_start_frame change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : Modify the start frame of a source Clip. Keywords argument: start_frame -- New start frame of the clip. use_segment_connections -- Sync the start frame of connected segments. clear_cache_media clear_cache_media clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current) clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. clear_renders clear_renders clear_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders. close_container close_container close_container( (PyClip)arg1) -> None : Close the container timeline if the Clip is inside a container. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. copy_selection_to_media_panel copy_selection_to_media_panel copy_selection_to_media_panel( (PySequence)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip by copying the currently selected segments. Return the new PyClip. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace). create_audio create_audio create_audio( (PySequence)arg1 [, (bool)stereo=False]) -> object : Add an Audio Track to the Sequence. create_container create_container create_container( (PySequence)arg1) -> object : Create a container with the selected segments or between the in and out marks. create_group create_group create_group( (PySequence)arg1, (str)name) -> object : Creates a new PySequenceGroup. The group name must be supplied as argument. create_marker create_marker create_marker( (PyClip)arg1, (object)location) -> object : Add a Marker to the Clip.Keyword argument: location -- The frame where the marker gets created. create_subtitle create_subtitle create_subtitle( (PySequence)arg1) -> object : Add a Subtitle Track to the Sequence. create_version create_version create_version( (PySequence)arg1 [, (bool)stereo=False]) -> object : Add a Version to the Sequence. cut cut cut( (PyClip)arg1, (PyTime)cut_time) -> None : Cut all tracks of the Clip. extract_selection_to_media_panel extract_selection_to_media_panel extract_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : Extract the selection from the sequence. Return the new PyClip created from the selection when a destination is supplied. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace). flush_cache_media flush_cache_media flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current)(Deprecated: use 'clear_cache_media' instead.) flush_renders flush_renders flush_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders.(Deprecated: use 'clear_renders' instead.) get_colour_space get_colour_space get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str : Return the colour space at the requested time. Use current_time when no time is supplied. get_metadata get_metadata get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : Return the metadata of the clip. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. time -- Must be a PyTime. If not specified, the current clip time is used. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. import_subtitles_file import_subtitles_file import_subtitles_file( (PySequence)arg1, (str)file_name [, (object)file_type=None [, (bool)align_first_event_to_clip_start=False [, (object)convert_from_frame_rate=None]]]) -> object : Import a subtitles file into a new Subtitles Track. Return the new PySubtitleTrack. Keyword arguments: file_name -- The path and name of the file to import. file_type -- The type of subtitle if it is not the file extension (srt or txt). align_first_event_to_clip_start -- Force the first event to be aligned with the clip start. convert_from_frame_rate -- frame rate of the imported file (for txt files only). insert insert insert( (PySequence)arg1, (PyClip)source_clip [, (PyTime)insert_time=None [, (PyTrack)destination_track=None]]) -> bool : Creates a new PySequenceGroup. The group name must be supplied as argument. is_rendered is_rendered is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool : Return if a Clip is rendered. The following attributes can be defined: top_only, render_quality. lift_selection_to_media_panel lift_selection_to_media_panel lift_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : Lift the selection from the sequence. Return the new PyClip created from the selection when a destination is supplied. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace). open open open( (PySequence)arg1) -> bool : Open the Sequence. open_as_sequence open_as_sequence open_as_sequence( (PyClip)arg1) -> object : Open the Clip as a Sequence. Mutates the PyClip object into a PySequence object. open_container open_container open_container( (PyClip)arg1) -> bool : Open the container timeline if the Clip is inside a container. overwrite overwrite overwrite( (PySequence)arg1, (PyClip)source_clip [, (PyTime)overwrite_time=None [, (PyTrack)destination_track=None]]) -> bool : Creates a new PySequenceGroup. The group name must be supplied as argument. reformat reformat reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None : Reformat the Clip to the specified format. Keywords arguments: width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. bit_depth -- Bit depth. (8, 10, 12, 16 or 32) scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) resize_mode -- Resize mode. (Letterbox, Crop Edges, Fill, Centre) render render render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool : Trigger a render of the Clip The following attributes can be defined: render_mode, render_option, render_quality, effect_type, effect_caching_mode and include_handles. save save save( (PyClip)arg1) -> bool : Save the Clip to the defined save destination.","title":"Class: PySequence"},{"location":"api/classes/PySequence/#class-pysequence","text":"Module : flame Inherits from : PyClip , PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PySequence"},{"location":"api/classes/PySequence/#description","text":"Object representing a Sequence.","title":"Description"},{"location":"api/classes/PySequence/#properties","text":"Name Description archive_date Return the Clip's last archive date. archive_error Return the Clip's last archive error. attributes The attributes of a python object. audio_tracks Return a list of the Clip's Audio Tracks. bit_depth Return the Clip's bit depth. cached Return the Clip's cache status. colour_primaries Deduce the Clip's 'colour primaries' export attribute. creation_date Return the Clip's creation date. duration Return the Clip's duration. essence_uid Return the Clip's essence uid. frame_rate Return the Clip's frame rate. groups Return a list of the sequence's PySequenceGroups. has_deliverables Return the existence of deliverables on the Clip. has_history Return the existence of history inside the Clip. height Return the Clip's height. markers Return a list of the Clip's Markers. matrix_coefficients Deduce the Clip's 'matrix coefficients' export attribute. original_source_uid Return the Clip's original source UID. parent The parent object of this object. proxy_resolution Return the Clip's proxy resolution if it has proxies. ratio Return the Clip's frame ratio. sample_rate Return the Clip's audio sample rate. scan_mode Return the Clip's scan mode. source_uid Return the Clip's source uid. start_frame Return the Clip's start frame. subtitles Return a list of the Clip's Subtitles Tracks. transfer_characteristics Deduce the Clip's 'transfer characteristics' export attribute. unlinked Return the Clip's unlinked status. versions Return a list of the Clip's versions. width Return the Clip's width.","title":"Properties"},{"location":"api/classes/PySequence/#methods","text":"","title":"Methods"},{"location":"api/classes/PySequence/#cache_media","text":"cache_media cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Cache the Clip's linked media. Keyword argument: mode -- Determine the version to cache (currently selected or all versions). All Versions is only useful with to multi-version clips (Current, All Versions)","title":"cache_media"},{"location":"api/classes/PySequence/#change_dominance","text":"change_dominance change_dominance( (PyClip)arg1, (str)scan_mode) -> None : Change the Clip's dominance. Changes only the clip's metadata. Keyword argument: scan_mode -- Field dominance. (P, F1, F2)","title":"change_dominance"},{"location":"api/classes/PySequence/#change_start_frame","text":"change_start_frame change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : Modify the start frame of a source Clip. Keywords argument: start_frame -- New start frame of the clip. use_segment_connections -- Sync the start frame of connected segments.","title":"change_start_frame"},{"location":"api/classes/PySequence/#clear_cache_media","text":"clear_cache_media clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current)","title":"clear_cache_media"},{"location":"api/classes/PySequence/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PySequence/#clear_renders","text":"clear_renders clear_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders.","title":"clear_renders"},{"location":"api/classes/PySequence/#close_container","text":"close_container close_container( (PyClip)arg1) -> None : Close the container timeline if the Clip is inside a container.","title":"close_container"},{"location":"api/classes/PySequence/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PySequence/#copy_selection_to_media_panel","text":"copy_selection_to_media_panel copy_selection_to_media_panel( (PySequence)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip by copying the currently selected segments. Return the new PyClip. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace).","title":"copy_selection_to_media_panel"},{"location":"api/classes/PySequence/#create_audio","text":"create_audio create_audio( (PySequence)arg1 [, (bool)stereo=False]) -> object : Add an Audio Track to the Sequence.","title":"create_audio"},{"location":"api/classes/PySequence/#create_container","text":"create_container create_container( (PySequence)arg1) -> object : Create a container with the selected segments or between the in and out marks.","title":"create_container"},{"location":"api/classes/PySequence/#create_group","text":"create_group create_group( (PySequence)arg1, (str)name) -> object : Creates a new PySequenceGroup. The group name must be supplied as argument.","title":"create_group"},{"location":"api/classes/PySequence/#create_marker","text":"create_marker create_marker( (PyClip)arg1, (object)location) -> object : Add a Marker to the Clip.Keyword argument: location -- The frame where the marker gets created.","title":"create_marker"},{"location":"api/classes/PySequence/#create_subtitle","text":"create_subtitle create_subtitle( (PySequence)arg1) -> object : Add a Subtitle Track to the Sequence.","title":"create_subtitle"},{"location":"api/classes/PySequence/#create_version","text":"create_version create_version( (PySequence)arg1 [, (bool)stereo=False]) -> object : Add a Version to the Sequence.","title":"create_version"},{"location":"api/classes/PySequence/#cut","text":"cut cut( (PyClip)arg1, (PyTime)cut_time) -> None : Cut all tracks of the Clip.","title":"cut"},{"location":"api/classes/PySequence/#extract_selection_to_media_panel","text":"extract_selection_to_media_panel extract_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : Extract the selection from the sequence. Return the new PyClip created from the selection when a destination is supplied. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace).","title":"extract_selection_to_media_panel"},{"location":"api/classes/PySequence/#flush_cache_media","text":"flush_cache_media flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current)(Deprecated: use 'clear_cache_media' instead.)","title":"flush_cache_media"},{"location":"api/classes/PySequence/#flush_renders","text":"flush_renders flush_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders.(Deprecated: use 'clear_renders' instead.)","title":"flush_renders"},{"location":"api/classes/PySequence/#get_colour_space","text":"get_colour_space get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str : Return the colour space at the requested time. Use current_time when no time is supplied.","title":"get_colour_space"},{"location":"api/classes/PySequence/#get_metadata","text":"get_metadata get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : Return the metadata of the clip. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. time -- Must be a PyTime. If not specified, the current clip time is used.","title":"get_metadata"},{"location":"api/classes/PySequence/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PySequence/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PySequence/#import_subtitles_file","text":"import_subtitles_file import_subtitles_file( (PySequence)arg1, (str)file_name [, (object)file_type=None [, (bool)align_first_event_to_clip_start=False [, (object)convert_from_frame_rate=None]]]) -> object : Import a subtitles file into a new Subtitles Track. Return the new PySubtitleTrack. Keyword arguments: file_name -- The path and name of the file to import. file_type -- The type of subtitle if it is not the file extension (srt or txt). align_first_event_to_clip_start -- Force the first event to be aligned with the clip start. convert_from_frame_rate -- frame rate of the imported file (for txt files only).","title":"import_subtitles_file"},{"location":"api/classes/PySequence/#insert","text":"insert insert( (PySequence)arg1, (PyClip)source_clip [, (PyTime)insert_time=None [, (PyTrack)destination_track=None]]) -> bool : Creates a new PySequenceGroup. The group name must be supplied as argument.","title":"insert"},{"location":"api/classes/PySequence/#is_rendered","text":"is_rendered is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool : Return if a Clip is rendered. The following attributes can be defined: top_only, render_quality.","title":"is_rendered"},{"location":"api/classes/PySequence/#lift_selection_to_media_panel","text":"lift_selection_to_media_panel lift_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : Lift the selection from the sequence. Return the new PyClip created from the selection when a destination is supplied. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace).","title":"lift_selection_to_media_panel"},{"location":"api/classes/PySequence/#open","text":"open open( (PySequence)arg1) -> bool : Open the Sequence.","title":"open"},{"location":"api/classes/PySequence/#open_as_sequence","text":"open_as_sequence open_as_sequence( (PyClip)arg1) -> object : Open the Clip as a Sequence. Mutates the PyClip object into a PySequence object.","title":"open_as_sequence"},{"location":"api/classes/PySequence/#open_container","text":"open_container open_container( (PyClip)arg1) -> bool : Open the container timeline if the Clip is inside a container.","title":"open_container"},{"location":"api/classes/PySequence/#overwrite","text":"overwrite overwrite( (PySequence)arg1, (PyClip)source_clip [, (PyTime)overwrite_time=None [, (PyTrack)destination_track=None]]) -> bool : Creates a new PySequenceGroup. The group name must be supplied as argument.","title":"overwrite"},{"location":"api/classes/PySequence/#reformat","text":"reformat reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None : Reformat the Clip to the specified format. Keywords arguments: width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. bit_depth -- Bit depth. (8, 10, 12, 16 or 32) scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) resize_mode -- Resize mode. (Letterbox, Crop Edges, Fill, Centre)","title":"reformat"},{"location":"api/classes/PySequence/#render","text":"render render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool : Trigger a render of the Clip The following attributes can be defined: render_mode, render_option, render_quality, effect_type, effect_caching_mode and include_handles.","title":"render"},{"location":"api/classes/PySequence/#save","text":"save save( (PyClip)arg1) -> bool : Save the Clip to the defined save destination.","title":"save"},{"location":"api/classes/PySequenceGroup/","text":"Class: PySequenceGroup Module : flame Inherits from : PyFlameObject , instance, object Description Object representing a Group in a Sequence. Properties Name Description attributes The attributes of a python object. parent The parent object of this object. segments Return a list of the Group's PySegments. Methods add add add( (PySequenceGroup)arg1, (object)segments) -> None : Adds a PySegment or list of PySegments to the Group. remove remove remove( (PySequenceGroup)arg1, (object)segments) -> None : Remove a PySegment or list of PySegments from the Group.","title":"Class: PySequenceGroup"},{"location":"api/classes/PySequenceGroup/#class-pysequencegroup","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PySequenceGroup"},{"location":"api/classes/PySequenceGroup/#description","text":"Object representing a Group in a Sequence.","title":"Description"},{"location":"api/classes/PySequenceGroup/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. segments Return a list of the Group's PySegments.","title":"Properties"},{"location":"api/classes/PySequenceGroup/#methods","text":"","title":"Methods"},{"location":"api/classes/PySequenceGroup/#add","text":"add add( (PySequenceGroup)arg1, (object)segments) -> None : Adds a PySegment or list of PySegments to the Group.","title":"add"},{"location":"api/classes/PySequenceGroup/#remove","text":"remove remove( (PySequenceGroup)arg1, (object)segments) -> None : Remove a PySegment or list of PySegments from the Group.","title":"remove"},{"location":"api/classes/PySubtitleTrack/","text":"Class: PySubtitleTrack Module : flame Inherits from : PyTrack , PyFlameObject , instance, object Description Object representing a Subtitle Track. Properties Name Description attributes The attributes of a python object. parent The parent object of this object. segments Return a list of the Track's segments. transitions Return a list of the Track's transitions. Methods copy_to_media_panel copy_to_media_panel copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject. cut cut cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None : Cut the Track. export_as_srt_file export_as_srt_file export_as_srt_file( (PySubtitleTrack)arg1, (str)file_name [, (bool)character_based_attributes=True [, (bool)export_colours=False [, (str)exclude_colour='' [, (bool)use_original_colours=False [, (bool)use_original_alignment=False [, (bool)export_alignments=False [, (str)alignment_type='an' [, (str)exclude_alignment='' [, (str)start_timecode='Same as Clip']]]]]]]]]) -> None : Export the Subtitles Track as a SubRip (srt) file.Keyword arguments: file_name -- The path and name of the file to write. character_based_attributes -- Export the bold, italic, and underline attributes. export_colours -- Export colours. exclude_colour -- Specify a colour, in hexadecimal or CSS colour name, to ignore. use_original_colours -- Reuse hexadecimal or CSS colour names from the imported file. use_original_alignment -- Reuse alignment tokens from the imported file . export_alignments -- Export alignments. alignment_type -- Set to a or an alignment style tokens. exclude_alignment -- Specify an alignment to ignore. start_timecode -- Specify the timecode mode, Same as Clip or, Relative to Clip Start. insert_transition insert_transition insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object : Insert a Transition on the Track. Returns the new PyTransition if successful. Keywords argument: record_time -- Time at which the Transition is inserted. type -- Type of the new Transition. duration -- Duration of the new Transition in frames. alignment -- Alignment of the new Transition. in_offset -- Number of frames on left side of the cut in custom alignment. sync -- Perform the operation on all Tracks part of the sync group.","title":"Class: PySubtitleTrack"},{"location":"api/classes/PySubtitleTrack/#class-pysubtitletrack","text":"Module : flame Inherits from : PyTrack , PyFlameObject , instance, object","title":"Class: PySubtitleTrack"},{"location":"api/classes/PySubtitleTrack/#description","text":"Object representing a Subtitle Track.","title":"Description"},{"location":"api/classes/PySubtitleTrack/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. segments Return a list of the Track's segments. transitions Return a list of the Track's transitions.","title":"Properties"},{"location":"api/classes/PySubtitleTrack/#methods","text":"","title":"Methods"},{"location":"api/classes/PySubtitleTrack/#copy_to_media_panel","text":"copy_to_media_panel copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject.","title":"copy_to_media_panel"},{"location":"api/classes/PySubtitleTrack/#cut","text":"cut cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None : Cut the Track.","title":"cut"},{"location":"api/classes/PySubtitleTrack/#export_as_srt_file","text":"export_as_srt_file export_as_srt_file( (PySubtitleTrack)arg1, (str)file_name [, (bool)character_based_attributes=True [, (bool)export_colours=False [, (str)exclude_colour='' [, (bool)use_original_colours=False [, (bool)use_original_alignment=False [, (bool)export_alignments=False [, (str)alignment_type='an' [, (str)exclude_alignment='' [, (str)start_timecode='Same as Clip']]]]]]]]]) -> None : Export the Subtitles Track as a SubRip (srt) file.Keyword arguments: file_name -- The path and name of the file to write. character_based_attributes -- Export the bold, italic, and underline attributes. export_colours -- Export colours. exclude_colour -- Specify a colour, in hexadecimal or CSS colour name, to ignore. use_original_colours -- Reuse hexadecimal or CSS colour names from the imported file. use_original_alignment -- Reuse alignment tokens from the imported file . export_alignments -- Export alignments. alignment_type -- Set to a or an alignment style tokens. exclude_alignment -- Specify an alignment to ignore. start_timecode -- Specify the timecode mode, Same as Clip or, Relative to Clip Start.","title":"export_as_srt_file"},{"location":"api/classes/PySubtitleTrack/#insert_transition","text":"insert_transition insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object : Insert a Transition on the Track. Returns the new PyTransition if successful. Keywords argument: record_time -- Time at which the Transition is inserted. type -- Type of the new Transition. duration -- Duration of the new Transition in frames. alignment -- Alignment of the new Transition. in_offset -- Number of frames on left side of the cut in custom alignment. sync -- Perform the operation on all Tracks part of the sync group.","title":"insert_transition"},{"location":"api/classes/PyTime/","text":"Class: PyTime Module : flame Inherits from : instance, object Description Object representing a time unit PyTime(timecode, frame_rate) PyTime(relative_frame) PyTime(absolute_frame, frame_rate) Properties Name Description frame Return the absolute frame number. frame_rate Return the object frame rate. relative_frame Return the relative frame number. timecode Return the timecode.","title":"Class: PyTime"},{"location":"api/classes/PyTime/#class-pytime","text":"Module : flame Inherits from : instance, object","title":"Class: PyTime"},{"location":"api/classes/PyTime/#description","text":"Object representing a time unit PyTime(timecode, frame_rate) PyTime(relative_frame) PyTime(absolute_frame, frame_rate)","title":"Description"},{"location":"api/classes/PyTime/#properties","text":"Name Description frame Return the absolute frame number. frame_rate Return the object frame rate. relative_frame Return the relative frame number. timecode Return the timecode.","title":"Properties"},{"location":"api/classes/PyTimeline/","text":"Class: PyTimeline Module : flame Inherits from : instance, object Description This class represents the Timeline. Properties Name Description clip The associated PyClip or PySequence of the Timeline. current_effect The PyTimeline FX currently focused on the timeline. current_marker The PyMarker currently focused on the timeline. current_segment The PySegment currently focused on the timeline. current_transition The PyTransition currently focused on the timeline. type The type of Timeline currently focused.","title":"Class: PyTimeline"},{"location":"api/classes/PyTimeline/#class-pytimeline","text":"Module : flame Inherits from : instance, object","title":"Class: PyTimeline"},{"location":"api/classes/PyTimeline/#description","text":"This class represents the Timeline.","title":"Description"},{"location":"api/classes/PyTimeline/#properties","text":"Name Description clip The associated PyClip or PySequence of the Timeline. current_effect The PyTimeline FX currently focused on the timeline. current_marker The PyMarker currently focused on the timeline. current_segment The PySegment currently focused on the timeline. current_transition The PyTransition currently focused on the timeline. type The type of Timeline currently focused.","title":"Properties"},{"location":"api/classes/PyTimelineFX/","text":"Class: PyTimelineFX Module : flame Inherits from : PyFlameObject , instance, object Description Object representing a Timeline FX. Properties Name Description attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. parent The parent object of this object. type Return the type of the Timeline FX. Methods clear_maps_cache_media clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media. flush_maps_cache_media flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.) load_setup load_setup load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting. save_setup save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. slide_keyframes slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. sync_connected_segments sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"Class: PyTimelineFX"},{"location":"api/classes/PyTimelineFX/#class-pytimelinefx","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyTimelineFX"},{"location":"api/classes/PyTimelineFX/#description","text":"Object representing a Timeline FX.","title":"Description"},{"location":"api/classes/PyTimelineFX/#properties","text":"Name Description attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. parent The parent object of this object. type Return the type of the Timeline FX.","title":"Properties"},{"location":"api/classes/PyTimelineFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTimelineFX/#clear_maps_cache_media","text":"clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.","title":"clear_maps_cache_media"},{"location":"api/classes/PyTimelineFX/#flush_maps_cache_media","text":"flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.)","title":"flush_maps_cache_media"},{"location":"api/classes/PyTimelineFX/#load_setup","text":"load_setup load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_setup"},{"location":"api/classes/PyTimelineFX/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyTimelineFX/#save_setup","text":"save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_setup"},{"location":"api/classes/PyTimelineFX/#slide_keyframes","text":"slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.","title":"slide_keyframes"},{"location":"api/classes/PyTimelineFX/#sync_connected_segments","text":"sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"sync_connected_segments"},{"location":"api/classes/PyTimewarpNode/","text":"Class: PyTimewarpNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Object representing a Timewarp node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_duration_timing get_duration_timing get_duration_timing( (PyTimewarpNode)arg1, (float)frame) -> float : Return the timing value for the current frame while in the duration mode. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. get_speed get_speed get_speed( (PyTimewarpNode)arg1, (float)frame) -> float : Return the speed attribute at the requested frame. get_speed_timing get_speed_timing get_speed_timing( (PyTimewarpNode)arg1, (float)frame) -> float : The timing value for the current frame while in the speed mode. get_timing get_timing get_timing( (PyTimewarpNode)arg1, (float)frame) -> float : Return the timing value at the requested frame. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments. set_speed set_speed set_speed( (PyTimewarpNode)arg1, (float)frame, (float)new_speed) -> None : Set the speed at the requested frame. set_timing set_timing set_timing( (PyTimewarpNode)arg1, (float)frame, (float)new_timing) -> None : Set the timing at the requested frame.","title":"Class: PyTimewarpNode"},{"location":"api/classes/PyTimewarpNode/#class-pytimewarpnode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyTimewarpNode"},{"location":"api/classes/PyTimewarpNode/#description","text":"Object representing a Timewarp node.","title":"Description"},{"location":"api/classes/PyTimewarpNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyTimewarpNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTimewarpNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyTimewarpNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyTimewarpNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyTimewarpNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyTimewarpNode/#get_duration_timing","text":"get_duration_timing get_duration_timing( (PyTimewarpNode)arg1, (float)frame) -> float : Return the timing value for the current frame while in the duration mode.","title":"get_duration_timing"},{"location":"api/classes/PyTimewarpNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyTimewarpNode/#get_speed","text":"get_speed get_speed( (PyTimewarpNode)arg1, (float)frame) -> float : Return the speed attribute at the requested frame.","title":"get_speed"},{"location":"api/classes/PyTimewarpNode/#get_speed_timing","text":"get_speed_timing get_speed_timing( (PyTimewarpNode)arg1, (float)frame) -> float : The timing value for the current frame while in the speed mode.","title":"get_speed_timing"},{"location":"api/classes/PyTimewarpNode/#get_timing","text":"get_timing get_timing( (PyTimewarpNode)arg1, (float)frame) -> float : Return the timing value at the requested frame.","title":"get_timing"},{"location":"api/classes/PyTimewarpNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyTimewarpNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyTimewarpNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyTimewarpNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyTimewarpNode/#set_speed","text":"set_speed set_speed( (PyTimewarpNode)arg1, (float)frame, (float)new_speed) -> None : Set the speed at the requested frame.","title":"set_speed"},{"location":"api/classes/PyTimewarpNode/#set_timing","text":"set_timing set_timing( (PyTimewarpNode)arg1, (float)frame, (float)new_timing) -> None : Set the timing at the requested frame.","title":"set_timing"},{"location":"api/classes/PyTimewarpTimelineFX/","text":"Class: PyTimewarpTimelineFX Module : flame Inherits from : PyTimelineFX , PyFlameObject , instance, object Description Object representing a Timewarp node. Properties Name Description attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. parent The parent object of this object. type Return the type of the Timeline FX. Methods clear_maps_cache_media clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media. flush_maps_cache_media flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.) get_duration_timing get_duration_timing get_duration_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the timing value for the current frame while in the duration mode. get_speed get_speed get_speed( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the speed attribute at the requested frame. get_speed_timing get_speed_timing get_speed_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : The timing value for the current frame while in the speed mode. get_timing get_timing get_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the timing value at the requested frame. load_setup load_setup load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting. save_setup save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_speed set_speed set_speed( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_speed) -> None : Set the speed at the requested frame. set_timing set_timing set_timing( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_timing) -> None : Set the timing at the requested frame. slide_keyframes slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. sync_connected_segments sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"Class: PyTimewarpTimelineFX"},{"location":"api/classes/PyTimewarpTimelineFX/#class-pytimewarptimelinefx","text":"Module : flame Inherits from : PyTimelineFX , PyFlameObject , instance, object","title":"Class: PyTimewarpTimelineFX"},{"location":"api/classes/PyTimewarpTimelineFX/#description","text":"Object representing a Timewarp node.","title":"Description"},{"location":"api/classes/PyTimewarpTimelineFX/#properties","text":"Name Description attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. parent The parent object of this object. type Return the type of the Timeline FX.","title":"Properties"},{"location":"api/classes/PyTimewarpTimelineFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTimewarpTimelineFX/#clear_maps_cache_media","text":"clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.","title":"clear_maps_cache_media"},{"location":"api/classes/PyTimewarpTimelineFX/#flush_maps_cache_media","text":"flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.)","title":"flush_maps_cache_media"},{"location":"api/classes/PyTimewarpTimelineFX/#get_duration_timing","text":"get_duration_timing get_duration_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the timing value for the current frame while in the duration mode.","title":"get_duration_timing"},{"location":"api/classes/PyTimewarpTimelineFX/#get_speed","text":"get_speed get_speed( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the speed attribute at the requested frame.","title":"get_speed"},{"location":"api/classes/PyTimewarpTimelineFX/#get_speed_timing","text":"get_speed_timing get_speed_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : The timing value for the current frame while in the speed mode.","title":"get_speed_timing"},{"location":"api/classes/PyTimewarpTimelineFX/#get_timing","text":"get_timing get_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the timing value at the requested frame.","title":"get_timing"},{"location":"api/classes/PyTimewarpTimelineFX/#load_setup","text":"load_setup load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_setup"},{"location":"api/classes/PyTimewarpTimelineFX/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyTimewarpTimelineFX/#save_setup","text":"save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_setup"},{"location":"api/classes/PyTimewarpTimelineFX/#set_speed","text":"set_speed set_speed( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_speed) -> None : Set the speed at the requested frame.","title":"set_speed"},{"location":"api/classes/PyTimewarpTimelineFX/#set_timing","text":"set_timing set_timing( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_timing) -> None : Set the timing at the requested frame.","title":"set_timing"},{"location":"api/classes/PyTimewarpTimelineFX/#slide_keyframes","text":"slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.","title":"slide_keyframes"},{"location":"api/classes/PyTimewarpTimelineFX/#sync_connected_segments","text":"sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"sync_connected_segments"},{"location":"api/classes/PyTrack/","text":"Class: PyTrack Module : flame Inherits from : PyFlameObject , instance, object Description Object representing a Track. Properties Name Description attributes The attributes of a python object. parent The parent object of this object. segments Return a list of the Track's segments. transitions Return a list of the Track's transitions. Methods copy_to_media_panel copy_to_media_panel copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject. cut cut cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None : Cut the Track. insert_transition insert_transition insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object : Insert a Transition on the Track. Returns the new PyTransition if successful. Keywords argument: record_time -- Time at which the Transition is inserted. type -- Type of the new Transition. duration -- Duration of the new Transition in frames. alignment -- Alignment of the new Transition. in_offset -- Number of frames on left side of the cut in custom alignment. sync -- Perform the operation on all Tracks part of the sync group.","title":"Class: PyTrack"},{"location":"api/classes/PyTrack/#class-pytrack","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyTrack"},{"location":"api/classes/PyTrack/#description","text":"Object representing a Track.","title":"Description"},{"location":"api/classes/PyTrack/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. segments Return a list of the Track's segments. transitions Return a list of the Track's transitions.","title":"Properties"},{"location":"api/classes/PyTrack/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTrack/#copy_to_media_panel","text":"copy_to_media_panel copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject.","title":"copy_to_media_panel"},{"location":"api/classes/PyTrack/#cut","text":"cut cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None : Cut the Track.","title":"cut"},{"location":"api/classes/PyTrack/#insert_transition","text":"insert_transition insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object : Insert a Transition on the Track. Returns the new PyTransition if successful. Keywords argument: record_time -- Time at which the Transition is inserted. type -- Type of the new Transition. duration -- Duration of the new Transition in frames. alignment -- Alignment of the new Transition. in_offset -- Number of frames on left side of the cut in custom alignment. sync -- Perform the operation on all Tracks part of the sync group.","title":"insert_transition"},{"location":"api/classes/PyTransition/","text":"Class: PyTransition Module : flame Inherits from : PyFlameObject , instance, object Description Object representing a Transition. Properties Name Description attributes The attributes of a python object. in_offset Return the in offset of the Transition. parent The parent object of this object. record_time Return the record time of Transition focus. type Return the Transition type. Methods set_dissolve_to_from_colour set_dissolve_to_from_colour set_dissolve_to_from_colour( (PyTransition)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : Make a dissolve transition dissolve to/from a colour. set_fade_to_from_silence set_fade_to_from_silence set_fade_to_from_silence( (PyTransition)arg1) -> None : Make a fade dip to/from silence. set_transition set_transition set_transition( (PyTransition)arg1, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0]]]) -> object : Replace the Transition with another type of Transition. Returns the new PyTransition if successful. Keywords argument: type -- Type of the new Transition. duration -- Duration of the new Transition in frames. alignment -- Alignment of the new Transition. in_offset -- Number of frames on left side of the cut in custom alignment. slide slide slide( (PyTransition)arg1, (int)offset [, (bool)sync=False]) -> bool : Slide the Transition. Keywords argument: offset -- Amount of frames to slide the Transition with. sync -- Enable to perform the same operation on transitions that belong to the same sync group as the current PyTransition.","title":"Class: PyTransition"},{"location":"api/classes/PyTransition/#class-pytransition","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyTransition"},{"location":"api/classes/PyTransition/#description","text":"Object representing a Transition.","title":"Description"},{"location":"api/classes/PyTransition/#properties","text":"Name Description attributes The attributes of a python object. in_offset Return the in offset of the Transition. parent The parent object of this object. record_time Return the record time of Transition focus. type Return the Transition type.","title":"Properties"},{"location":"api/classes/PyTransition/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTransition/#set_dissolve_to_from_colour","text":"set_dissolve_to_from_colour set_dissolve_to_from_colour( (PyTransition)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : Make a dissolve transition dissolve to/from a colour.","title":"set_dissolve_to_from_colour"},{"location":"api/classes/PyTransition/#set_fade_to_from_silence","text":"set_fade_to_from_silence set_fade_to_from_silence( (PyTransition)arg1) -> None : Make a fade dip to/from silence.","title":"set_fade_to_from_silence"},{"location":"api/classes/PyTransition/#set_transition","text":"set_transition set_transition( (PyTransition)arg1, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0]]]) -> object : Replace the Transition with another type of Transition. Returns the new PyTransition if successful. Keywords argument: type -- Type of the new Transition. duration -- Duration of the new Transition in frames. alignment -- Alignment of the new Transition. in_offset -- Number of frames on left side of the cut in custom alignment.","title":"set_transition"},{"location":"api/classes/PyTransition/#slide","text":"slide slide( (PyTransition)arg1, (int)offset [, (bool)sync=False]) -> bool : Slide the Transition. Keywords argument: offset -- Amount of frames to slide the Transition with. sync -- Enable to perform the same operation on transitions that belong to the same sync group as the current PyTransition.","title":"slide"},{"location":"api/classes/PyTypeFX/","text":"Class: PyTypeFX Module : flame Inherits from : PyTimelineFX , PyFlameObject , instance, object Description Object representing a Type Timeline FX. Properties Name Description attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. layers Return the layers list. parent The parent object of this object. type Return the type of the Timeline FX. Methods add_layer add_layer add_layer( (PyTypeFX)arg1 [, (str)layer_type='Centre']) -> object : Create a new layer. Keyword argument: layer_type -- Must be one of Left, Centre(default), Right, Roll, or Crawl. append_type_setup append_type_setup append_type_setup( (PyTypeFX)arg1, (str)file_name) -> bool : Append a setup to the current Type setup. clear_maps_cache_media clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media. flush_maps_cache_media flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.) load_setup load_setup load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting. save_setup save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. slide_keyframes slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. sync_connected_segments sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"Class: PyTypeFX"},{"location":"api/classes/PyTypeFX/#class-pytypefx","text":"Module : flame Inherits from : PyTimelineFX , PyFlameObject , instance, object","title":"Class: PyTypeFX"},{"location":"api/classes/PyTypeFX/#description","text":"Object representing a Type Timeline FX.","title":"Description"},{"location":"api/classes/PyTypeFX/#properties","text":"Name Description attributes The attributes of a python object. has_maps_cache_media Return whether the Timeline FX has Maps or ML cached media. layers Return the layers list. parent The parent object of this object. type Return the type of the Timeline FX.","title":"Properties"},{"location":"api/classes/PyTypeFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTypeFX/#add_layer","text":"add_layer add_layer( (PyTypeFX)arg1 [, (str)layer_type='Centre']) -> object : Create a new layer. Keyword argument: layer_type -- Must be one of Left, Centre(default), Right, Roll, or Crawl.","title":"add_layer"},{"location":"api/classes/PyTypeFX/#append_type_setup","text":"append_type_setup append_type_setup( (PyTypeFX)arg1, (str)file_name) -> bool : Append a setup to the current Type setup.","title":"append_type_setup"},{"location":"api/classes/PyTypeFX/#clear_maps_cache_media","text":"clear_maps_cache_media clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.","title":"clear_maps_cache_media"},{"location":"api/classes/PyTypeFX/#flush_maps_cache_media","text":"flush_maps_cache_media flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.)","title":"flush_maps_cache_media"},{"location":"api/classes/PyTypeFX/#load_setup","text":"load_setup load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_setup"},{"location":"api/classes/PyTypeFX/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyTypeFX/#save_setup","text":"save_setup save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_setup"},{"location":"api/classes/PyTypeFX/#slide_keyframes","text":"slide_keyframes slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.","title":"slide_keyframes"},{"location":"api/classes/PyTypeFX/#sync_connected_segments","text":"sync_connected_segments sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments.","title":"sync_connected_segments"},{"location":"api/classes/PyTypeLayer/","text":"Class: PyTypeLayer Module : flame Inherits from : PyFlameObject , instance, object Description Object representing a Type Layer. Properties Name Description attributes The attributes of a python object. parent The parent object of this object. type The layer type: Text, Roll, Crawl, or On Path.","title":"Class: PyTypeLayer"},{"location":"api/classes/PyTypeLayer/#class-pytypelayer","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyTypeLayer"},{"location":"api/classes/PyTypeLayer/#description","text":"Object representing a Type Layer.","title":"Description"},{"location":"api/classes/PyTypeLayer/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. type The layer type: Text, Roll, Crawl, or On Path.","title":"Properties"},{"location":"api/classes/PyTypeNode/","text":"Class: PyTypeNode Module : flame Inherits from : PyNode , PyFlameObject , instance, object Description Object representing a Type node. Properties Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. layers Return the layers list. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods add_layer add_layer add_layer( (PyTypeNode)arg1 [, (str)layer_type='Centre']) -> object : Create a new layer. Keyword argument: layer_type -- Must be one of Left, Centre(default), Right, Roll, or Crawl. append_type_setup append_type_setup append_type_setup( (PyTypeNode)arg1, (str)file_name) -> bool : Append a setup to the current Type setup. cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"Class: PyTypeNode"},{"location":"api/classes/PyTypeNode/#class-pytypenode","text":"Module : flame Inherits from : PyNode , PyFlameObject , instance, object","title":"Class: PyTypeNode"},{"location":"api/classes/PyTypeNode/#description","text":"Object representing a Type node.","title":"Description"},{"location":"api/classes/PyTypeNode/#properties","text":"Name Description attributes The attributes of a python object. input_sockets Return a list of the node input sockets names. layers Return the layers list. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyTypeNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTypeNode/#add_layer","text":"add_layer add_layer( (PyTypeNode)arg1 [, (str)layer_type='Centre']) -> object : Create a new layer. Keyword argument: layer_type -- Must be one of Left, Centre(default), Right, Roll, or Crawl.","title":"add_layer"},{"location":"api/classes/PyTypeNode/#append_type_setup","text":"append_type_setup append_type_setup( (PyTypeNode)arg1, (str)file_name) -> bool : Append a setup to the current Type setup.","title":"append_type_setup"},{"location":"api/classes/PyTypeNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyTypeNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyTypeNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyTypeNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyTypeNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyTypeNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyTypeNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyTypeNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyTypeNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyUser/","text":"Class: PyUser Module : flame Inherits from : instance, object Description Object representing a User. Properties Name Description name User name. nickname User nickname. shortcuts_profile Keyboard Shortcuts profile. Possible values are: - Flame - Smoke Classic - Smoke (FCP 7) - Lustre","title":"Class: PyUser"},{"location":"api/classes/PyUser/#class-pyuser","text":"Module : flame Inherits from : instance, object","title":"Class: PyUser"},{"location":"api/classes/PyUser/#description","text":"Object representing a User.","title":"Description"},{"location":"api/classes/PyUser/#properties","text":"Name Description name User name. nickname User nickname. shortcuts_profile Keyboard Shortcuts profile. Possible values are: - Flame - Smoke Classic - Smoke (FCP 7) - Lustre","title":"Properties"},{"location":"api/classes/PyUsers/","text":"Class: PyUsers Module : flame Inherits from : instance, object Description Object representing the User manager. Properties Name Description current_user The PyUser linked to the current User.","title":"Class: PyUsers"},{"location":"api/classes/PyUsers/#class-pyusers","text":"Module : flame Inherits from : instance, object","title":"Class: PyUsers"},{"location":"api/classes/PyUsers/#description","text":"Object representing the User manager.","title":"Description"},{"location":"api/classes/PyUsers/#properties","text":"Name Description current_user The PyUser linked to the current User.","title":"Properties"},{"location":"api/classes/PyVersion/","text":"Class: PyVersion Module : flame Inherits from : PyFlameObject , instance, object Description Object representing a Version. Properties Name Description attributes The attributes of a python object. parent The parent object of this object. stereo Return whether or not the Version is stereo. tracks Return a list of the Version's Tracks. Methods copy_to_media_panel copy_to_media_panel copy_to_media_panel( (PyVersion)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject. create_track create_track create_track( (PyVersion)arg1 [, (int)track_index=-1 [, (bool)hdr=False]]) -> object : Add a track to the Version.Keywords arguments: track_index -- Index to insert the new track at, -1 to append at the top. hdr -- Set to True to create an HDR track. import_DolbyVision_xml import_DolbyVision_xml import_DolbyVision_xml( (PyVersion)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)track_index=-1]]) -> object : Add a track to the Version.Keywords arguments: track_index -- Index to insert the new track at, -1 to append at the top. hdr -- Set to True to create an HDR track.","title":"Class: PyVersion"},{"location":"api/classes/PyVersion/#class-pyversion","text":"Module : flame Inherits from : PyFlameObject , instance, object","title":"Class: PyVersion"},{"location":"api/classes/PyVersion/#description","text":"Object representing a Version.","title":"Description"},{"location":"api/classes/PyVersion/#properties","text":"Name Description attributes The attributes of a python object. parent The parent object of this object. stereo Return whether or not the Version is stereo. tracks Return a list of the Version's Tracks.","title":"Properties"},{"location":"api/classes/PyVersion/#methods","text":"","title":"Methods"},{"location":"api/classes/PyVersion/#copy_to_media_panel","text":"copy_to_media_panel copy_to_media_panel( (PyVersion)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject.","title":"copy_to_media_panel"},{"location":"api/classes/PyVersion/#create_track","text":"create_track create_track( (PyVersion)arg1 [, (int)track_index=-1 [, (bool)hdr=False]]) -> object : Add a track to the Version.Keywords arguments: track_index -- Index to insert the new track at, -1 to append at the top. hdr -- Set to True to create an HDR track.","title":"create_track"},{"location":"api/classes/PyVersion/#import_dolbyvision_xml","text":"import_DolbyVision_xml import_DolbyVision_xml( (PyVersion)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)track_index=-1]]) -> object : Add a track to the Version.Keywords arguments: track_index -- Index to insert the new track at, -1 to append at the top. hdr -- Set to True to create an HDR track.","title":"import_DolbyVision_xml"},{"location":"api/classes/PyWorkspace/","text":"Class: PyWorkspace Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object Description Object representing a Workspace. Properties Name Description attributes The attributes of a python object. desktop Return the current Desktop. libraries Return the Workspace Libraries. parent The parent object of this object. Methods clear_colour clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel. commit commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. create_library create_library create_library( (PyWorkspace)arg1, (str)name) -> object : Create a new Library in a Workspace. get_wiretap_node_id get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. get_wiretap_storage_id get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. replace_desktop replace_desktop replace_desktop( (PyWorkspace)arg1, (PyDesktop)desktop) -> bool : Replace the Workspace active Desktop with another one. set_desktop_reels set_desktop_reels set_desktop_reels( (PyWorkspace)arg1 [, (object)group=None]) -> bool : Set the Desktop Reels view mode. set_freeform set_freeform set_freeform( (PyWorkspace)arg1 [, (object)reel=None]) -> bool : Set the Freeform view mode.","title":"Class: PyWorkspace"},{"location":"api/classes/PyWorkspace/#class-pyworkspace","text":"Module : flame Inherits from : PyArchiveEntry , PyFlameObject , instance, object","title":"Class: PyWorkspace"},{"location":"api/classes/PyWorkspace/#description","text":"Object representing a Workspace.","title":"Description"},{"location":"api/classes/PyWorkspace/#properties","text":"Name Description attributes The attributes of a python object. desktop Return the current Desktop. libraries Return the Workspace Libraries. parent The parent object of this object.","title":"Properties"},{"location":"api/classes/PyWorkspace/#methods","text":"","title":"Methods"},{"location":"api/classes/PyWorkspace/#clear_colour","text":"clear_colour clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"clear_colour"},{"location":"api/classes/PyWorkspace/#commit","text":"commit commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible.","title":"commit"},{"location":"api/classes/PyWorkspace/#create_library","text":"create_library create_library( (PyWorkspace)arg1, (str)name) -> object : Create a new Library in a Workspace.","title":"create_library"},{"location":"api/classes/PyWorkspace/#get_wiretap_node_id","text":"get_wiretap_node_id get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_node_id"},{"location":"api/classes/PyWorkspace/#get_wiretap_storage_id","text":"get_wiretap_storage_id get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel.","title":"get_wiretap_storage_id"},{"location":"api/classes/PyWorkspace/#replace_desktop","text":"replace_desktop replace_desktop( (PyWorkspace)arg1, (PyDesktop)desktop) -> bool : Replace the Workspace active Desktop with another one.","title":"replace_desktop"},{"location":"api/classes/PyWorkspace/#set_desktop_reels","text":"set_desktop_reels set_desktop_reels( (PyWorkspace)arg1 [, (object)group=None]) -> bool : Set the Desktop Reels view mode.","title":"set_desktop_reels"},{"location":"api/classes/PyWorkspace/#set_freeform","text":"set_freeform set_freeform( (PyWorkspace)arg1 [, (object)reel=None]) -> bool : Set the Freeform view mode.","title":"set_freeform"},{"location":"api/classes/PyWriteFileNode/","text":"Class: PyWriteFileNode Module : flame Inherits from : PyRenderNode , PyNode , PyFlameObject , instance, object Description Class derived from PyRenderNode. This class represents a WriteFile node. Properties Name Description attributes The attributes of a python object. channels The channels attribute is a list of tuples, where each tuple is made of a socket name and its channel name. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections. Methods cache_range cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. clear_schematic_colour clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. delete delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. get_metadata get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. get_resolved_media_path get_resolved_media_path get_resolved_media_path( (PyWriteFileNode)arg1 [, (bool)show_extension=True [, (bool)translate_path=True [, (object)frame=None]]]) -> object : Return the resolved media path. Keyword arguments: show_extension -- Set True to display the extension. translate_path -- Set True to apply the Media Location Path Translation. frame -- Pass a frame number, between range_start and range_end, to get the path for that frame. load_node_setup load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. output_channel_as_metadata_key output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting. save_node_setup save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. set_channel_name set_channel_name set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None : Rename a channel, using its index or front channel name as the index key. Keyword arguments: channel -- The channel to rename. Can be the channel index or the current name of the channel's front socket. name -- The new name of the channel. The type is either a string or a tuple. A Write File node always takes a string. A Render node takes a string or a tuple. In a Render node, a string only sets the name of the channel's front socket; the function creates the name of the matte socket by appending '_alpha' to 'name'. In the UI, the channel is flagged 'Sync'. A Write File node has only one socket per channel, and requires only a string to set a socket name. In a Render node, a tuple sets the names of the front and matte sockets. In the UI, the channel is not flagged 'Sync'. A Write File node does not accept a tuple. set_context set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments. set_metadata_discarded set_metadata_discarded set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key. set_metadata_key set_metadata_key set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value. set_metadata_value set_metadata_value set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. is_dynamic -- Set the Metadata value to be resolved dynamically if it contains tokens.","title":"Class: PyWriteFileNode"},{"location":"api/classes/PyWriteFileNode/#class-pywritefilenode","text":"Module : flame Inherits from : PyRenderNode , PyNode , PyFlameObject , instance, object","title":"Class: PyWriteFileNode"},{"location":"api/classes/PyWriteFileNode/#description","text":"Class derived from PyRenderNode. This class represents a WriteFile node.","title":"Description"},{"location":"api/classes/PyWriteFileNode/#properties","text":"Name Description attributes The attributes of a python object. channels The channels attribute is a list of tuples, where each tuple is made of a socket name and its channel name. input_sockets Return a list of the node input sockets names. output_sockets Return a list of the node output sockets names. parent The parent object of this object. sockets Return a dictionary of the input/output sockets names and their connections.","title":"Properties"},{"location":"api/classes/PyWriteFileNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyWriteFileNode/#cache_range","text":"cache_range cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified.","title":"cache_range"},{"location":"api/classes/PyWriteFileNode/#clear_schematic_colour","text":"clear_schematic_colour clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node.","title":"clear_schematic_colour"},{"location":"api/classes/PyWriteFileNode/#delete","text":"delete delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node.","title":"delete"},{"location":"api/classes/PyWriteFileNode/#duplicate","text":"duplicate duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node.","title":"duplicate"},{"location":"api/classes/PyWriteFileNode/#get_metadata","text":"get_metadata get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified.","title":"get_metadata"},{"location":"api/classes/PyWriteFileNode/#get_resolved_media_path","text":"get_resolved_media_path get_resolved_media_path( (PyWriteFileNode)arg1 [, (bool)show_extension=True [, (bool)translate_path=True [, (object)frame=None]]]) -> object : Return the resolved media path. Keyword arguments: show_extension -- Set True to display the extension. translate_path -- Set True to apply the Media Location Path Translation. frame -- Pass a frame number, between range_start and range_end, to get the path for that frame.","title":"get_resolved_media_path"},{"location":"api/classes/PyWriteFileNode/#load_node_setup","text":"load_node_setup load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments.","title":"load_node_setup"},{"location":"api/classes/PyWriteFileNode/#output_channel_as_metadata_key","text":"output_channel_as_metadata_key output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"output_channel_as_metadata_key"},{"location":"api/classes/PyWriteFileNode/#save_node_setup","text":"save_node_setup save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments.","title":"save_node_setup"},{"location":"api/classes/PyWriteFileNode/#set_channel_name","text":"set_channel_name set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None : Rename a channel, using its index or front channel name as the index key. Keyword arguments: channel -- The channel to rename. Can be the channel index or the current name of the channel's front socket. name -- The new name of the channel. The type is either a string or a tuple. A Write File node always takes a string. A Render node takes a string or a tuple. In a Render node, a string only sets the name of the channel's front socket; the function creates the name of the matte socket by appending '_alpha' to 'name'. In the UI, the channel is flagged 'Sync'. A Write File node has only one socket per channel, and requires only a string to set a socket name. In a Render node, a tuple sets the names of the front and matte sockets. In the UI, the channel is not flagged 'Sync'. A Write File node does not accept a tuple.","title":"set_channel_name"},{"location":"api/classes/PyWriteFileNode/#set_context","text":"set_context set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments.","title":"set_context"},{"location":"api/classes/PyWriteFileNode/#set_metadata_discarded","text":"set_metadata_discarded set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key.","title":"set_metadata_discarded"},{"location":"api/classes/PyWriteFileNode/#set_metadata_key","text":"set_metadata_key set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value.","title":"set_metadata_key"},{"location":"api/classes/PyWriteFileNode/#set_metadata_value","text":"set_metadata_value set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. is_dynamic -- Set the Metadata value to be resolved dynamically if it contains tokens.","title":"set_metadata_value"},{"location":"goals/flame-mcp-creation/","text":"Goal: The Flame-MCP Bridge Vision To evolve VSCODE-CONNECT-TO-FLAME from a developer-centric toolset into an AI-native ecosystem . By implementing a Model Context Protocol (MCP) server, we allow Large Language Models (LLMs) to interact with Autodesk Flame as if they were a local user, enabling autonomous scripting, live inspection, and real-time debugging. 1. Architecture: The Bridge Pattern The implementation will follow a \"Relay\" architecture, utilizing the existing infrastructure. AI Client: (Claude Desktop, Cursor, Gemini) sends a request. MCP Server (New): A Python process using fastmcp that interprets the AI's intent and translates it into Flame-specific commands. Flame Listener (Existing): Receives the Python code from the MCP server and executes it safely on Flame's main thread. Autodesk Flame: The host environment performing the actual work. graph LR A[AI Client] --> B[MCP Server] B --> C[Flame Listener] C --> D[Flame API] 2. Implementation Strategy A. Technology Stack Language: Python 3.9+ (matching Flame's environment). Framework: fastmcp for rapid tool definition. Communication: requests or httpx to talk to the existing flame-listener REST/Socket endpoint. B. Core Toolset (Phase 1) The AI should have access to these primary \"skills\": Tool Name Description Example AI Use Case flame_exec Executes raw Python code in Flame. \"Fix the indentation in the current script.\" get_context Returns current Project/User/Workspace. \"Which project am I currently working in?\" list_media Lists clips in the current Desktop/Batch. \"Find all clips labeled 'RETAKE'.\" inspect_api Queries Flame's internal dir() for symbols. \"What properties does a PySegment have?\" 3. High-Level Implementation Plan Step 1: Scaffold the MCP Server Create a dedicated directory flame-mcp/ containing a server.py . This server will run independently of Flame but on the same network. Step 2: Define the \"Relay\" Logic Implement a standard execution wrapper that sends code to the listener: def relay_to_flame(code: str): # Sends code to localhost:5555 # Returns stdout/stderr Step 3: Tool Exposure Decorate functions with @mcp.tool() to make them visible to the LLM. 4. Key Benefits Autonomous Refactoring Instead of the developer copying code from an AI chat into a file and then running it, the AI can: 1. Read the current script from Flame. 2. Rewrite it for optimization. 3. Push it back into Flame and run it to verify success. Intelligent API Discovery Since the Flame API is proprietary and sometimes poorly documented, the AI can \"explore\" the API live. If it's unsure how to delete a marker, it can run a tool to inspect the flame.PyMarker class dynamically. Visual Reasoning (Future) By adding a take_screenshot tool, the AI can \"see\" the Flame UI, allowing it to assist with UI-heavy tasks like layout alignment or finding specific buttons in the Batch schematic. 5. Security & Safety (HITL) To ensure the AI doesn't accidentally delete a whole project, we will maintain a Human-In-The-Loop (HITL) approach: * The MCP server will log every command it sends to Flame. * Destructive commands (e.g., flame.delete ) will require a confirmation flag or be restricted to specific \"Sandbox\" volumes.","title":"Goal: The Flame-MCP Bridge"},{"location":"goals/flame-mcp-creation/#goal-the-flame-mcp-bridge","text":"","title":"Goal: The Flame-MCP Bridge"},{"location":"goals/flame-mcp-creation/#vision","text":"To evolve VSCODE-CONNECT-TO-FLAME from a developer-centric toolset into an AI-native ecosystem . By implementing a Model Context Protocol (MCP) server, we allow Large Language Models (LLMs) to interact with Autodesk Flame as if they were a local user, enabling autonomous scripting, live inspection, and real-time debugging.","title":"Vision"},{"location":"goals/flame-mcp-creation/#1-architecture-the-bridge-pattern","text":"The implementation will follow a \"Relay\" architecture, utilizing the existing infrastructure. AI Client: (Claude Desktop, Cursor, Gemini) sends a request. MCP Server (New): A Python process using fastmcp that interprets the AI's intent and translates it into Flame-specific commands. Flame Listener (Existing): Receives the Python code from the MCP server and executes it safely on Flame's main thread. Autodesk Flame: The host environment performing the actual work. graph LR A[AI Client] --> B[MCP Server] B --> C[Flame Listener] C --> D[Flame API]","title":"1. Architecture: The Bridge Pattern"},{"location":"goals/flame-mcp-creation/#2-implementation-strategy","text":"","title":"2. Implementation Strategy"},{"location":"goals/flame-mcp-creation/#a-technology-stack","text":"Language: Python 3.9+ (matching Flame's environment). Framework: fastmcp for rapid tool definition. Communication: requests or httpx to talk to the existing flame-listener REST/Socket endpoint.","title":"A. Technology Stack"},{"location":"goals/flame-mcp-creation/#b-core-toolset-phase-1","text":"The AI should have access to these primary \"skills\": Tool Name Description Example AI Use Case flame_exec Executes raw Python code in Flame. \"Fix the indentation in the current script.\" get_context Returns current Project/User/Workspace. \"Which project am I currently working in?\" list_media Lists clips in the current Desktop/Batch. \"Find all clips labeled 'RETAKE'.\" inspect_api Queries Flame's internal dir() for symbols. \"What properties does a PySegment have?\"","title":"B. Core Toolset (Phase 1)"},{"location":"goals/flame-mcp-creation/#3-high-level-implementation-plan","text":"","title":"3. High-Level Implementation Plan"},{"location":"goals/flame-mcp-creation/#step-1-scaffold-the-mcp-server","text":"Create a dedicated directory flame-mcp/ containing a server.py . This server will run independently of Flame but on the same network.","title":"Step 1: Scaffold the MCP Server"},{"location":"goals/flame-mcp-creation/#step-2-define-the-relay-logic","text":"Implement a standard execution wrapper that sends code to the listener: def relay_to_flame(code: str): # Sends code to localhost:5555 # Returns stdout/stderr","title":"Step 2: Define the \"Relay\" Logic"},{"location":"goals/flame-mcp-creation/#step-3-tool-exposure","text":"Decorate functions with @mcp.tool() to make them visible to the LLM.","title":"Step 3: Tool Exposure"},{"location":"goals/flame-mcp-creation/#4-key-benefits","text":"","title":"4. Key Benefits"},{"location":"goals/flame-mcp-creation/#autonomous-refactoring","text":"Instead of the developer copying code from an AI chat into a file and then running it, the AI can: 1. Read the current script from Flame. 2. Rewrite it for optimization. 3. Push it back into Flame and run it to verify success.","title":"Autonomous Refactoring"},{"location":"goals/flame-mcp-creation/#intelligent-api-discovery","text":"Since the Flame API is proprietary and sometimes poorly documented, the AI can \"explore\" the API live. If it's unsure how to delete a marker, it can run a tool to inspect the flame.PyMarker class dynamically.","title":"Intelligent API Discovery"},{"location":"goals/flame-mcp-creation/#visual-reasoning-future","text":"By adding a take_screenshot tool, the AI can \"see\" the Flame UI, allowing it to assist with UI-heavy tasks like layout alignment or finding specific buttons in the Batch schematic.","title":"Visual Reasoning (Future)"},{"location":"goals/flame-mcp-creation/#5-security-safety-hitl","text":"To ensure the AI doesn't accidentally delete a whole project, we will maintain a Human-In-The-Loop (HITL) approach: * The MCP server will log every command it sends to Flame. * Destructive commands (e.g., flame.delete ) will require a confirmation flag or be restricted to specific \"Sandbox\" volumes.","title":"5. Security &amp; Safety (HITL)"},{"location":"insight/adsk/python/insight-archive_hook/","text":"Insight: Monitoring Archive Operations This document explains the archive_hook.py file. It shows how Flame can notify your Python scripts about the status of backups and restores. Target Audience: Novice Python programmers interested in data safety and system monitoring. 1. What is an Archive Hook? In Flame, \"Archiving\" is the process of backing up your project to a server or a tape. Because archives can take a long time, you might not want to sit and watch the progress bar. The Solution: Archive Hooks. These are \"Event Listeners\" that run automatically when an archive starts, finishes, or hits a milestone. 2. Key Events (Hooks) The script defines several empty placeholders (functions) that Flame will fill with data: A. archive_completed Flame runs this as soon as a backup is 100% finished. - Use case: Send an email to the producer saying: \"The backup for 'Project_X' is done!\" B. archive_restored Runs when you successfully bring a project back from an archive. - Use case: Log that a project was reopened for auditing purposes. C. archive_segment_completed Archives are often broken into smaller \"segments\" (files). This hook runs every time one of those small files is finished. - Why? It tells you the status . If it's not zero, something went wrong! You can catch errors early instead of waiting for the very end. D. archive_selection_updated Runs when you select clips to be archived. It gives you technical data like num_frames and data_size (in MB). - Use case: Warn the artist if they are trying to archive more data than is available on the backup drive. 3. Why is this useful? Automation: You can trigger external scripts (like database updates) based on archive success. Error Handling: You get immediate, detailed feedback if a backup fails. Reporting: You can build a history of how much data your studio is archiving every day. 4. Key Takeaway for Beginners Hooks are like \"Automatic Notifications\" for your code. Instead of your script constantly asking Flame \"Are you done yet?\" , Flame simply \"calls\" your script's function when the event happens and hands over all the relevant information (like the archive name and path).","title":"Insight: Monitoring Archive Operations"},{"location":"insight/adsk/python/insight-archive_hook/#insight-monitoring-archive-operations","text":"This document explains the archive_hook.py file. It shows how Flame can notify your Python scripts about the status of backups and restores. Target Audience: Novice Python programmers interested in data safety and system monitoring.","title":"Insight: Monitoring Archive Operations"},{"location":"insight/adsk/python/insight-archive_hook/#1-what-is-an-archive-hook","text":"In Flame, \"Archiving\" is the process of backing up your project to a server or a tape. Because archives can take a long time, you might not want to sit and watch the progress bar. The Solution: Archive Hooks. These are \"Event Listeners\" that run automatically when an archive starts, finishes, or hits a milestone.","title":"1. What is an Archive Hook?"},{"location":"insight/adsk/python/insight-archive_hook/#2-key-events-hooks","text":"The script defines several empty placeholders (functions) that Flame will fill with data:","title":"2. Key Events (Hooks)"},{"location":"insight/adsk/python/insight-archive_hook/#a-archive_completed","text":"Flame runs this as soon as a backup is 100% finished. - Use case: Send an email to the producer saying: \"The backup for 'Project_X' is done!\"","title":"A. archive_completed"},{"location":"insight/adsk/python/insight-archive_hook/#b-archive_restored","text":"Runs when you successfully bring a project back from an archive. - Use case: Log that a project was reopened for auditing purposes.","title":"B. archive_restored"},{"location":"insight/adsk/python/insight-archive_hook/#c-archive_segment_completed","text":"Archives are often broken into smaller \"segments\" (files). This hook runs every time one of those small files is finished. - Why? It tells you the status . If it's not zero, something went wrong! You can catch errors early instead of waiting for the very end.","title":"C. archive_segment_completed"},{"location":"insight/adsk/python/insight-archive_hook/#d-archive_selection_updated","text":"Runs when you select clips to be archived. It gives you technical data like num_frames and data_size (in MB). - Use case: Warn the artist if they are trying to archive more data than is available on the backup drive.","title":"D. archive_selection_updated"},{"location":"insight/adsk/python/insight-archive_hook/#3-why-is-this-useful","text":"Automation: You can trigger external scripts (like database updates) based on archive success. Error Handling: You get immediate, detailed feedback if a backup fails. Reporting: You can build a history of how much data your studio is archiving every day.","title":"3. Why is this useful?"},{"location":"insight/adsk/python/insight-archive_hook/#4-key-takeaway-for-beginners","text":"Hooks are like \"Automatic Notifications\" for your code. Instead of your script constantly asking Flame \"Are you done yet?\" , Flame simply \"calls\" your script's function when the event happens and hands over all the relevant information (like the archive name and path).","title":"4. Key Takeaway for Beginners"},{"location":"insight/adsk/python/insight-batch_hook/","text":"Insight: Mastering the Batch Lifecycle This document explains the batch_hook.py file. It covers every stage of the Batch process\u2014from saving your work to rendering the final images. Target Audience: Novice Python programmers learning about render pipelines and automation. 1. What is a Batch Hook? Batch is Flame's node-based compositing environment. Because Batch is where most of the \"Heavy Lifting\" (rendering) happens, it has many hooks to help you track progress and prevent mistakes. 2. Key Lifecycle Stages The script breaks the Batch workflow into three main parts: A. Setup Management ( batch_setup_loaded / saved ) These run when you open or save your Batch schematic. - Use case: Keep a log of who is opening which Batch setup and when. B. Iterations ( batch_setup_iterated_pre / post ) In Flame, an \"Iteration\" is a versioned save. - The \"Pre\" Hook: Runs before the save happens. You can use this to Abort the save if the file name doesn't match studio standards. - The \"Post\" Hook: Runs after the save. It tells you if it was successful. C. Rendering & Exporting ( begin / end hooks) This is where the images are actually created. - batch_render_begin : Runs before a local render. - batch_burn_begin : Runs before sending a job to a \"Burn\" render node. - batch_export_begin : Runs before a \"Write File\" node starts exporting to disk. 3. The info and userData Pattern Almost all these functions use two special parameters: info [Dictionary]: This is a read-only (and sometimes modifiable) \"ID Card\" for the task. It contains paths, frame rates, resolution, and job names. userData [Dictionary]: This is like a \"Sticky Note.\" You can write something on it in the _begin hook (like a timestamp), and Flame will hand that same sticky note back to you in the _end hook. It's the best way to track how long a job took! 4. Why is this useful? Quality Control: Use the begin hooks to check if the render settings (like resolution) are correct before wasting hours on a render. Custom Notifications: Use the end hooks to trigger a Slack message or email when a long render is finished. Path Redirection: Use the batch_export_begin hook to dynamically change where files are saved based on the project name. 5. Key Takeaway for Beginners Batch hooks allow you to \"Sandwich\" Flame's built-in actions with your own code. By putting logic at the \"Start\" and \"End\" of a render, you can build a highly controlled and intelligent production pipeline.","title":"Insight: Mastering the Batch Lifecycle"},{"location":"insight/adsk/python/insight-batch_hook/#insight-mastering-the-batch-lifecycle","text":"This document explains the batch_hook.py file. It covers every stage of the Batch process\u2014from saving your work to rendering the final images. Target Audience: Novice Python programmers learning about render pipelines and automation.","title":"Insight: Mastering the Batch Lifecycle"},{"location":"insight/adsk/python/insight-batch_hook/#1-what-is-a-batch-hook","text":"Batch is Flame's node-based compositing environment. Because Batch is where most of the \"Heavy Lifting\" (rendering) happens, it has many hooks to help you track progress and prevent mistakes.","title":"1. What is a Batch Hook?"},{"location":"insight/adsk/python/insight-batch_hook/#2-key-lifecycle-stages","text":"The script breaks the Batch workflow into three main parts:","title":"2. Key Lifecycle Stages"},{"location":"insight/adsk/python/insight-batch_hook/#a-setup-management-batch_setup_loaded-saved","text":"These run when you open or save your Batch schematic. - Use case: Keep a log of who is opening which Batch setup and when.","title":"A. Setup Management (batch_setup_loaded / saved)"},{"location":"insight/adsk/python/insight-batch_hook/#b-iterations-batch_setup_iterated_pre-post","text":"In Flame, an \"Iteration\" is a versioned save. - The \"Pre\" Hook: Runs before the save happens. You can use this to Abort the save if the file name doesn't match studio standards. - The \"Post\" Hook: Runs after the save. It tells you if it was successful.","title":"B. Iterations (batch_setup_iterated_pre / post)"},{"location":"insight/adsk/python/insight-batch_hook/#c-rendering-exporting-begin-end-hooks","text":"This is where the images are actually created. - batch_render_begin : Runs before a local render. - batch_burn_begin : Runs before sending a job to a \"Burn\" render node. - batch_export_begin : Runs before a \"Write File\" node starts exporting to disk.","title":"C. Rendering &amp; Exporting (begin / end hooks)"},{"location":"insight/adsk/python/insight-batch_hook/#3-the-info-and-userdata-pattern","text":"Almost all these functions use two special parameters: info [Dictionary]: This is a read-only (and sometimes modifiable) \"ID Card\" for the task. It contains paths, frame rates, resolution, and job names. userData [Dictionary]: This is like a \"Sticky Note.\" You can write something on it in the _begin hook (like a timestamp), and Flame will hand that same sticky note back to you in the _end hook. It's the best way to track how long a job took!","title":"3. The info and userData Pattern"},{"location":"insight/adsk/python/insight-batch_hook/#4-why-is-this-useful","text":"Quality Control: Use the begin hooks to check if the render settings (like resolution) are correct before wasting hours on a render. Custom Notifications: Use the end hooks to trigger a Slack message or email when a long render is finished. Path Redirection: Use the batch_export_begin hook to dynamically change where files are saved based on the project name.","title":"4. Why is this useful?"},{"location":"insight/adsk/python/insight-batch_hook/#5-key-takeaway-for-beginners","text":"Batch hooks allow you to \"Sandwich\" Flame's built-in actions with your own code. By putting logic at the \"Start\" and \"End\" of a render, you can build a highly controlled and intelligent production pipeline.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python/insight-custom_actions_hook/","text":"Insight: Creating Custom Right-Click Menus This document explains the custom_actions_hook.py file. It is the \"Master List\" of where and how you can add your own buttons to the Flame interface. Target Audience: Novice Python programmers who want to customize the Flame UI. 1. What are Custom Actions? In Flame, almost every area (the Media Panel, the Timeline, the Batch Schematic) has a right-click menu. A Custom Action is your way of adding a new button to those menus that runs your own Python code. 2. Where can you add Menus? The script lists many functions, each corresponding to a different \"Home\" in Flame: get_media_panel_custom_ui_actions : Right-clicking on clips or folders in the browser. get_main_menu_custom_ui_actions : The top Flame menu. get_timeline_custom_ui_actions : Right-clicking on segments in the timeline. get_batch_custom_ui_actions : Right-clicking in the Batch schematic. get_mediahub_files_custom_ui_actions : Right-clicking on files you are about to import. 3. How to Define an Action Each action is a Dictionary (a list of settings). Here are the most important settings: name : The text that appears in the menu. execute : The name of the Python function to run when the user clicks the button. isVisible : A \"Gatekeeper.\" If this is False, the button stays hidden. Tip: Use this to only show \"Timeline\" tools when the user is actually on the Timeline. isEnabled : Similar to isVisible , but it makes the button greyed-out (disabled) instead of hiding it. 4. Organizing with Groups You don't just add single buttons; you add Groups . - A Group is like a folder in the menu. - This keeps your tools organized (e.g., all your \"Export\" tools inside one \"My Studio / Exports\" group). 5. Key Takeaway for Beginners Think of custom_actions_hook.py as the \"Registry\" of your tools. It doesn't usually contain the logic of what the tool does; it just tells Flame where to put the button and which script to wake up when that button is pressed.","title":"Insight: Creating Custom Right-Click Menus"},{"location":"insight/adsk/python/insight-custom_actions_hook/#insight-creating-custom-right-click-menus","text":"This document explains the custom_actions_hook.py file. It is the \"Master List\" of where and how you can add your own buttons to the Flame interface. Target Audience: Novice Python programmers who want to customize the Flame UI.","title":"Insight: Creating Custom Right-Click Menus"},{"location":"insight/adsk/python/insight-custom_actions_hook/#1-what-are-custom-actions","text":"In Flame, almost every area (the Media Panel, the Timeline, the Batch Schematic) has a right-click menu. A Custom Action is your way of adding a new button to those menus that runs your own Python code.","title":"1. What are Custom Actions?"},{"location":"insight/adsk/python/insight-custom_actions_hook/#2-where-can-you-add-menus","text":"The script lists many functions, each corresponding to a different \"Home\" in Flame: get_media_panel_custom_ui_actions : Right-clicking on clips or folders in the browser. get_main_menu_custom_ui_actions : The top Flame menu. get_timeline_custom_ui_actions : Right-clicking on segments in the timeline. get_batch_custom_ui_actions : Right-clicking in the Batch schematic. get_mediahub_files_custom_ui_actions : Right-clicking on files you are about to import.","title":"2. Where can you add Menus?"},{"location":"insight/adsk/python/insight-custom_actions_hook/#3-how-to-define-an-action","text":"Each action is a Dictionary (a list of settings). Here are the most important settings: name : The text that appears in the menu. execute : The name of the Python function to run when the user clicks the button. isVisible : A \"Gatekeeper.\" If this is False, the button stays hidden. Tip: Use this to only show \"Timeline\" tools when the user is actually on the Timeline. isEnabled : Similar to isVisible , but it makes the button greyed-out (disabled) instead of hiding it.","title":"3. How to Define an Action"},{"location":"insight/adsk/python/insight-custom_actions_hook/#4-organizing-with-groups","text":"You don't just add single buttons; you add Groups . - A Group is like a folder in the menu. - This keeps your tools organized (e.g., all your \"Export\" tools inside one \"My Studio / Exports\" group).","title":"4. Organizing with Groups"},{"location":"insight/adsk/python/insight-custom_actions_hook/#5-key-takeaway-for-beginners","text":"Think of custom_actions_hook.py as the \"Registry\" of your tools. It doesn't usually contain the logic of what the tool does; it just tells Flame where to put the button and which script to wake up when that button is pressed.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python/insight-export_hook/","text":"Insight: Customizing the Export Pipeline This document explains the export_hook.py file. It is one of the most powerful and complex hook files in Flame, allowing you to control exactly what happens when media is saved to disk. Target Audience: Novice Python programmers interested in complex automation and data management. 1. The Export \"Sandwich\" Exporting a clip in Flame isn't just one single action; it's a sequence of events. Flame allows you to \"sandwich\" your own code at every layer of this process. The Execution Order: pre_export : Runs once at the very beginning of the whole export job. pre_export_sequence : Runs for every Sequence in your export list. pre_export_asset : Runs for every individual file (Video, Audio, OpenClip) being created. post_export_asset : Runs as soon as a file is finished. post_export_sequence : Runs when all assets in a sequence are done. post_export : Runs once everything is finished. 2. Key Features A. The \"Abort\" Switch Most pre_ hooks allow you to cancel the export if something is wrong. if info[\"destinationPath\"] == \"/forbidden/path\": info[\"abort\"] = True info[\"abort_message\"] = \"You cannot export to this server!\" B. Overwriting Files The export_overwrite_file hook lets you decide what happens if a file already exists. - You can tell Flame to always \"overwrite\" , \"skip\" , or \"ask\" the user. This is perfect for avoiding those annoying pop-up boxes! C. userData Sharing Like the Batch hooks, Export hooks use a userData dictionary. You can put info in at the pre_export stage and read it back at post_export . This is how you track total export time or gather a list of every file created. 3. Why is this useful? Custom Naming: You can use pre_export_asset to dynamically change the filename ( info[\"resolvedPath\"] ) based on the shot name or project code. Post-Processing: Use post_export_asset to automatically trigger an external transcode (like making a low-res H.264 for the web) as soon as the high-res file is ready. Security: Ensure that exports only go to approved storage locations. 4. Key Takeaway for Beginners The export pipeline is granular. If you want to change something for the whole job , use pre_export . If you want to change something for one specific clip , use pre_export_asset . Understanding this hierarchy is the key to building a professional studio pipeline.","title":"Insight: Customizing the Export Pipeline"},{"location":"insight/adsk/python/insight-export_hook/#insight-customizing-the-export-pipeline","text":"This document explains the export_hook.py file. It is one of the most powerful and complex hook files in Flame, allowing you to control exactly what happens when media is saved to disk. Target Audience: Novice Python programmers interested in complex automation and data management.","title":"Insight: Customizing the Export Pipeline"},{"location":"insight/adsk/python/insight-export_hook/#1-the-export-sandwich","text":"Exporting a clip in Flame isn't just one single action; it's a sequence of events. Flame allows you to \"sandwich\" your own code at every layer of this process.","title":"1. The Export \"Sandwich\""},{"location":"insight/adsk/python/insight-export_hook/#the-execution-order","text":"pre_export : Runs once at the very beginning of the whole export job. pre_export_sequence : Runs for every Sequence in your export list. pre_export_asset : Runs for every individual file (Video, Audio, OpenClip) being created. post_export_asset : Runs as soon as a file is finished. post_export_sequence : Runs when all assets in a sequence are done. post_export : Runs once everything is finished.","title":"The Execution Order:"},{"location":"insight/adsk/python/insight-export_hook/#2-key-features","text":"","title":"2. Key Features"},{"location":"insight/adsk/python/insight-export_hook/#a-the-abort-switch","text":"Most pre_ hooks allow you to cancel the export if something is wrong. if info[\"destinationPath\"] == \"/forbidden/path\": info[\"abort\"] = True info[\"abort_message\"] = \"You cannot export to this server!\"","title":"A. The \"Abort\" Switch"},{"location":"insight/adsk/python/insight-export_hook/#b-overwriting-files","text":"The export_overwrite_file hook lets you decide what happens if a file already exists. - You can tell Flame to always \"overwrite\" , \"skip\" , or \"ask\" the user. This is perfect for avoiding those annoying pop-up boxes!","title":"B. Overwriting Files"},{"location":"insight/adsk/python/insight-export_hook/#c-userdata-sharing","text":"Like the Batch hooks, Export hooks use a userData dictionary. You can put info in at the pre_export stage and read it back at post_export . This is how you track total export time or gather a list of every file created.","title":"C. userData Sharing"},{"location":"insight/adsk/python/insight-export_hook/#3-why-is-this-useful","text":"Custom Naming: You can use pre_export_asset to dynamically change the filename ( info[\"resolvedPath\"] ) based on the shot name or project code. Post-Processing: Use post_export_asset to automatically trigger an external transcode (like making a low-res H.264 for the web) as soon as the high-res file is ready. Security: Ensure that exports only go to approved storage locations.","title":"3. Why is this useful?"},{"location":"insight/adsk/python/insight-export_hook/#4-key-takeaway-for-beginners","text":"The export pipeline is granular. If you want to change something for the whole job , use pre_export . If you want to change something for one specific clip , use pre_export_asset . Understanding this hierarchy is the key to building a professional studio pipeline.","title":"4. Key Takeaway for Beginners"},{"location":"insight/adsk/python/insight-hook/","text":"Insight: Global Application Hooks This document explains the hook.py file. These are the \"Global\" events that happen at the highest level of Autodesk Flame. Target Audience: Novice Python programmers interested in general automation and default settings. 1. What is a Global Hook? While most hooks are about specific tasks (like rendering or exporting), Global Hooks are about the Application itself. They run when Flame starts, when you switch projects, or when you log in as a different user. 2. Key Global Events A. Lifecycle Hooks ( app_initialized / app_exited ) app_initialized : Runs as soon as Flame is ready for work. Use case: Automatically open a specific library or print a \"Welcome\" message to the console. app_exited : Runs when you quit Flame. Use case: Clean up temporary files or save a log of how long you worked. B. User Changes ( user_changed ) Flame runs this when you switch from \"Editor A\" to \"Editor B.\" - Use case: Automatically load the user's preferred hotkeys or window layouts via Python. C. Default Naming Hooks Flame uses several hooks to decide what the \"Default Name\" should be for things like Markers and Shots: - timeline_default_shot_name - timeline_default_marker_name - default_reference_name Instead of every shot being named \"Shot 1\", \"Shot 2\", you can write a script that names them based on the Date and the Project Name automatically. 3. Monitoring Performance The render_ended hook in this file is different from the Batch render hook. It triggers for any render in Flame (Timeline, Effects, etc.) and tells you exactly how many seconds it took. - Use case: Build a report showing which modules (like \"Action\" or \"GMask\") are taking the most time to render across your project. 4. Why is this useful? Consistency: You can enforce studio-wide naming standards for markers and shots so everyone's projects look the same. Environment Setup: You can prepare the Flame environment (like setting the Video Preview device) automatically every time the software starts. 5. Key Takeaway for Beginners Global hooks are for \"Set it and Forget it\" logic. Once you write a hook here, it works across every project and every user, making it the best place for infrastructure-level automation.","title":"Insight: Global Application Hooks"},{"location":"insight/adsk/python/insight-hook/#insight-global-application-hooks","text":"This document explains the hook.py file. These are the \"Global\" events that happen at the highest level of Autodesk Flame. Target Audience: Novice Python programmers interested in general automation and default settings.","title":"Insight: Global Application Hooks"},{"location":"insight/adsk/python/insight-hook/#1-what-is-a-global-hook","text":"While most hooks are about specific tasks (like rendering or exporting), Global Hooks are about the Application itself. They run when Flame starts, when you switch projects, or when you log in as a different user.","title":"1. What is a Global Hook?"},{"location":"insight/adsk/python/insight-hook/#2-key-global-events","text":"","title":"2. Key Global Events"},{"location":"insight/adsk/python/insight-hook/#a-lifecycle-hooks-app_initialized-app_exited","text":"app_initialized : Runs as soon as Flame is ready for work. Use case: Automatically open a specific library or print a \"Welcome\" message to the console. app_exited : Runs when you quit Flame. Use case: Clean up temporary files or save a log of how long you worked.","title":"A. Lifecycle Hooks (app_initialized / app_exited)"},{"location":"insight/adsk/python/insight-hook/#b-user-changes-user_changed","text":"Flame runs this when you switch from \"Editor A\" to \"Editor B.\" - Use case: Automatically load the user's preferred hotkeys or window layouts via Python.","title":"B. User Changes (user_changed)"},{"location":"insight/adsk/python/insight-hook/#c-default-naming-hooks","text":"Flame uses several hooks to decide what the \"Default Name\" should be for things like Markers and Shots: - timeline_default_shot_name - timeline_default_marker_name - default_reference_name Instead of every shot being named \"Shot 1\", \"Shot 2\", you can write a script that names them based on the Date and the Project Name automatically.","title":"C. Default Naming Hooks"},{"location":"insight/adsk/python/insight-hook/#3-monitoring-performance","text":"The render_ended hook in this file is different from the Batch render hook. It triggers for any render in Flame (Timeline, Effects, etc.) and tells you exactly how many seconds it took. - Use case: Build a report showing which modules (like \"Action\" or \"GMask\") are taking the most time to render across your project.","title":"3. Monitoring Performance"},{"location":"insight/adsk/python/insight-hook/#4-why-is-this-useful","text":"Consistency: You can enforce studio-wide naming standards for markers and shots so everyone's projects look the same. Environment Setup: You can prepare the Flame environment (like setting the Video Preview device) automatically every time the software starts.","title":"4. Why is this useful?"},{"location":"insight/adsk/python/insight-hook/#5-key-takeaway-for-beginners","text":"Global hooks are for \"Set it and Forget it\" logic. Once you write a hook here, it works across every project and every user, making it the best place for infrastructure-level automation.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python/insight-otio_reader/","text":"Insight: The OTIO Translation Engine This document explains the otio_reader.py script. While the \"Hook\" script starts the process, this is the \"Brain\" that does the actual work of turning an OTIO file into a Flame sequence. Target Audience: Novice Python programmers interested in object-oriented programming (OOP) and \"Data Mapping.\" 1. What is a \"Reader\" Class? This script uses a Class called FlameOTIOReader . - The Concept: Think of this class as a professional translator. It reads a book in one language (OTIO) and writes a new one in another language (Flame API). 2. Key Translation Steps The script doesn't just \"copy\" the file. It has to map every OTIO concept to a Flame concept: A. The Timeline Map OTIO Timeline becomes a Flame Sequence . OTIO Track becomes a Flame Track (Video or Audio). OTIO Clip becomes a Flame Segment . B. Frame Rate Conversion OTIO might say \"23.98 fps,\" but Flame expects exactly \"23.976 fps\" . The function _otio_rate_to_frame handles this tricky math so the timing stays perfect. C. Finding Media OTIO files often use \"Relative Paths\" (e.g., ../media/shot.mov ). The script is smart enough to find the real file on your hard drive by looking at where the OTIO file itself is saved. 3. Advanced Feature: \"Pre\" and \"Post\" Hooks The reader is designed to be extensible. It uses its own internal hooks: - pre_hook_Clip : Runs just before a clip is created. - post_hook_Clip : Runs after the clip is in Flame. This allows other programmers to add custom logic (like adding a specific Color FX) without changing the main reader code. 4. Why is this useful? Robustness: By putting all the logic in one Class, the code is easier to test and fix. Complexity: It handles nested structures (like stacks and gaps) that a simple script couldn't manage. Accuracy: It ensures that metadata, markers, and transitions are preserved during the move between software. 5. Key Takeaway for Beginners Mapping data from one format to another is a common job for Python. The secret is to break the big problem into small pieces: first translate the Timeline, then the Tracks, then the Clips, then the Markers.","title":"Insight: The OTIO Translation Engine"},{"location":"insight/adsk/python/insight-otio_reader/#insight-the-otio-translation-engine","text":"This document explains the otio_reader.py script. While the \"Hook\" script starts the process, this is the \"Brain\" that does the actual work of turning an OTIO file into a Flame sequence. Target Audience: Novice Python programmers interested in object-oriented programming (OOP) and \"Data Mapping.\"","title":"Insight: The OTIO Translation Engine"},{"location":"insight/adsk/python/insight-otio_reader/#1-what-is-a-reader-class","text":"This script uses a Class called FlameOTIOReader . - The Concept: Think of this class as a professional translator. It reads a book in one language (OTIO) and writes a new one in another language (Flame API).","title":"1. What is a \"Reader\" Class?"},{"location":"insight/adsk/python/insight-otio_reader/#2-key-translation-steps","text":"The script doesn't just \"copy\" the file. It has to map every OTIO concept to a Flame concept:","title":"2. Key Translation Steps"},{"location":"insight/adsk/python/insight-otio_reader/#a-the-timeline-map","text":"OTIO Timeline becomes a Flame Sequence . OTIO Track becomes a Flame Track (Video or Audio). OTIO Clip becomes a Flame Segment .","title":"A. The Timeline Map"},{"location":"insight/adsk/python/insight-otio_reader/#b-frame-rate-conversion","text":"OTIO might say \"23.98 fps,\" but Flame expects exactly \"23.976 fps\" . The function _otio_rate_to_frame handles this tricky math so the timing stays perfect.","title":"B. Frame Rate Conversion"},{"location":"insight/adsk/python/insight-otio_reader/#c-finding-media","text":"OTIO files often use \"Relative Paths\" (e.g., ../media/shot.mov ). The script is smart enough to find the real file on your hard drive by looking at where the OTIO file itself is saved.","title":"C. Finding Media"},{"location":"insight/adsk/python/insight-otio_reader/#3-advanced-feature-pre-and-post-hooks","text":"The reader is designed to be extensible. It uses its own internal hooks: - pre_hook_Clip : Runs just before a clip is created. - post_hook_Clip : Runs after the clip is in Flame. This allows other programmers to add custom logic (like adding a specific Color FX) without changing the main reader code.","title":"3. Advanced Feature: \"Pre\" and \"Post\" Hooks"},{"location":"insight/adsk/python/insight-otio_reader/#4-why-is-this-useful","text":"Robustness: By putting all the logic in one Class, the code is easier to test and fix. Complexity: It handles nested structures (like stacks and gaps) that a simple script couldn't manage. Accuracy: It ensures that metadata, markers, and transitions are preserved during the move between software.","title":"4. Why is this useful?"},{"location":"insight/adsk/python/insight-otio_reader/#5-key-takeaway-for-beginners","text":"Mapping data from one format to another is a common job for Python. The secret is to break the big problem into small pieces: first translate the Timeline, then the Tracks, then the Clips, then the Markers.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python/insight-otio_reader_hook/","text":"Insight: Importing OpenTimelineIO (OTIO) This document explains the otio_reader_hook.py file. It shows how Flame can understand \"OTIO\" files\u2014a universal format for sharing movie timelines between different software. Target Audience: Novice Python programmers interested in cross-software compatibility. 1. What is OTIO? Imagine you edited a video in Adobe Premiere or DaVinci Resolve and you want to bring that exact timeline (all the clips in the right order) into Flame. Usually, you would use an XML or AAF file. OpenTimelineIO (OTIO) is a modern, open-source way to do this. It's more reliable and easier for programmers to use. 2. How the Hook Works This script acts as a \"Bridge.\" The Trigger: When you try to import an OTIO file, Flame runs the import_otio function. The Engine: It calls another script ( otio_reader.py ) to do the heavy lifting. The Translation: It takes the \"Clips\" and \"Tracks\" from the OTIO file and recreates them inside Flame as PySequence and PySegment objects. 3. Error Handling Importing timelines is messy. Clips might be missing, or files might be corrupted. The script uses a try...except block: try: otio.read_otio_file(file_path, first_sel) except Exception as e: return f\"Caught exception: {e}\" This ensures that if the import fails, Flame doesn't crash. Instead, it \"catches\" the error and shows a helpful message to the user. 4. Why is this useful? Interoperability: It allows Flame to sit in the middle of a pipeline with many different editing tools. Customization: Because it's written in Python, you can customize how the import happens\u2014for example, automatically looking for missing media in a specific studio folder. 5. Key Takeaway for Beginners Hooks aren't just for small tasks; they can be used to add Entire New Features to Flame. By writing a reader hook, you are teaching Flame how to understand a file format it didn't know about when it was first built!","title":"Insight: Importing OpenTimelineIO (OTIO)"},{"location":"insight/adsk/python/insight-otio_reader_hook/#insight-importing-opentimelineio-otio","text":"This document explains the otio_reader_hook.py file. It shows how Flame can understand \"OTIO\" files\u2014a universal format for sharing movie timelines between different software. Target Audience: Novice Python programmers interested in cross-software compatibility.","title":"Insight: Importing OpenTimelineIO (OTIO)"},{"location":"insight/adsk/python/insight-otio_reader_hook/#1-what-is-otio","text":"Imagine you edited a video in Adobe Premiere or DaVinci Resolve and you want to bring that exact timeline (all the clips in the right order) into Flame. Usually, you would use an XML or AAF file. OpenTimelineIO (OTIO) is a modern, open-source way to do this. It's more reliable and easier for programmers to use.","title":"1. What is OTIO?"},{"location":"insight/adsk/python/insight-otio_reader_hook/#2-how-the-hook-works","text":"This script acts as a \"Bridge.\" The Trigger: When you try to import an OTIO file, Flame runs the import_otio function. The Engine: It calls another script ( otio_reader.py ) to do the heavy lifting. The Translation: It takes the \"Clips\" and \"Tracks\" from the OTIO file and recreates them inside Flame as PySequence and PySegment objects.","title":"2. How the Hook Works"},{"location":"insight/adsk/python/insight-otio_reader_hook/#3-error-handling","text":"Importing timelines is messy. Clips might be missing, or files might be corrupted. The script uses a try...except block: try: otio.read_otio_file(file_path, first_sel) except Exception as e: return f\"Caught exception: {e}\" This ensures that if the import fails, Flame doesn't crash. Instead, it \"catches\" the error and shows a helpful message to the user.","title":"3. Error Handling"},{"location":"insight/adsk/python/insight-otio_reader_hook/#4-why-is-this-useful","text":"Interoperability: It allows Flame to sit in the middle of a pipeline with many different editing tools. Customization: Because it's written in Python, you can customize how the import happens\u2014for example, automatically looking for missing media in a specific studio folder.","title":"4. Why is this useful?"},{"location":"insight/adsk/python/insight-otio_reader_hook/#5-key-takeaway-for-beginners","text":"Hooks aren't just for small tasks; they can be used to add Entire New Features to Flame. By writing a reader hook, you are teaching Flame how to understand a file format it didn't know about when it was first built!","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python/insight-project_hook/","text":"Insight: Automating the Project Lifecycle This document explains the project_hook.py file. It gives you total control over how Flame projects are created, saved, and managed. Target Audience: Novice Python programmers interested in project management and data safety. 1. What is a Project Hook? In Flame, a \"Project\" is the container for all your work. Because projects are so important, Flame gives you hooks for every possible change that can happen to one. 2. Key Lifecycle Events A. Creation & Setup ( project_init_creation / pre_creation ) project_init_creation : Runs as soon as you open the \"New Project\" window. Use case: Automatically fill in the Project Description or Nickname based on today's date. project_pre_creation : Runs right before the project is actually built. Use case: Abort the creation if the name doesn't follow studio rules (e.g., must start with a job number). B. Project Changes ( project_changed / project_saved ) project_changed : Runs when you switch from Project A to Project B. project_saved : Runs every time you save. Tip: It even tells you if it was an \"Auto-Save\" or a manual save by the artist! C. Conversion & Migration ( project_pre_conversion ) When you upgrade Flame, you often have to convert old projects. - Use case: Log which projects have been migrated to the new version for auditing. D. Deletion & Protection ( project_pre_delete ) This is the \"Security Guard\" hook. - Use case: Prevent anyone from deleting a project if it's currently marked as \"Active\" in your studio database. 3. The \"Abort\" Power Just like Export hooks, Project hooks allow you to set info[\"abort\"] = True . This is the ultimate safety feature. It stops Flame from doing anything until the project data meets your studio's standards. 4. Why is this useful? Organization: Ensure every project has a consistent folder structure and naming convention. Safety: Prevent accidental deletion of \"Master\" projects. Automation: Automatically link Flame projects to external systems like ShotGrid as soon as they are created. 5. Key Takeaway for Beginners Project hooks are about \"Governance.\" They allow you to turn Flame from a standalone tool into a part of a larger, managed studio ecosystem where rules are enforced automatically by code.","title":"Insight: Automating the Project Lifecycle"},{"location":"insight/adsk/python/insight-project_hook/#insight-automating-the-project-lifecycle","text":"This document explains the project_hook.py file. It gives you total control over how Flame projects are created, saved, and managed. Target Audience: Novice Python programmers interested in project management and data safety.","title":"Insight: Automating the Project Lifecycle"},{"location":"insight/adsk/python/insight-project_hook/#1-what-is-a-project-hook","text":"In Flame, a \"Project\" is the container for all your work. Because projects are so important, Flame gives you hooks for every possible change that can happen to one.","title":"1. What is a Project Hook?"},{"location":"insight/adsk/python/insight-project_hook/#2-key-lifecycle-events","text":"","title":"2. Key Lifecycle Events"},{"location":"insight/adsk/python/insight-project_hook/#a-creation-setup-project_init_creation-pre_creation","text":"project_init_creation : Runs as soon as you open the \"New Project\" window. Use case: Automatically fill in the Project Description or Nickname based on today's date. project_pre_creation : Runs right before the project is actually built. Use case: Abort the creation if the name doesn't follow studio rules (e.g., must start with a job number).","title":"A. Creation &amp; Setup (project_init_creation / pre_creation)"},{"location":"insight/adsk/python/insight-project_hook/#b-project-changes-project_changed-project_saved","text":"project_changed : Runs when you switch from Project A to Project B. project_saved : Runs every time you save. Tip: It even tells you if it was an \"Auto-Save\" or a manual save by the artist!","title":"B. Project Changes (project_changed / project_saved)"},{"location":"insight/adsk/python/insight-project_hook/#c-conversion-migration-project_pre_conversion","text":"When you upgrade Flame, you often have to convert old projects. - Use case: Log which projects have been migrated to the new version for auditing.","title":"C. Conversion &amp; Migration (project_pre_conversion)"},{"location":"insight/adsk/python/insight-project_hook/#d-deletion-protection-project_pre_delete","text":"This is the \"Security Guard\" hook. - Use case: Prevent anyone from deleting a project if it's currently marked as \"Active\" in your studio database.","title":"D. Deletion &amp; Protection (project_pre_delete)"},{"location":"insight/adsk/python/insight-project_hook/#3-the-abort-power","text":"Just like Export hooks, Project hooks allow you to set info[\"abort\"] = True . This is the ultimate safety feature. It stops Flame from doing anything until the project data meets your studio's standards.","title":"3. The \"Abort\" Power"},{"location":"insight/adsk/python/insight-project_hook/#4-why-is-this-useful","text":"Organization: Ensure every project has a consistent folder structure and naming convention. Safety: Prevent accidental deletion of \"Master\" projects. Automation: Automatically link Flame projects to external systems like ShotGrid as soon as they are created.","title":"4. Why is this useful?"},{"location":"insight/adsk/python/insight-project_hook/#5-key-takeaway-for-beginners","text":"Project hooks are about \"Governance.\" They allow you to turn Flame from a standalone tool into a part of a larger, managed studio ecosystem where rules are enforced automatically by code.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python/insight-tokens_hook/","text":"Insight: Creating Custom Naming Tokens This document explains the tokens_hook.py file. It shows how to add your own \"Magic Words\" (Tokens) to Flame's naming and export windows. Target Audience: Novice Python programmers interested in dynamic naming and string manipulation. 1. What are Tokens? You've probably seen tokens in Flame like <shot_name> or {width} . When you use them, Flame automatically replaces the token with the real name or resolution of the clip. The Goal: Add your own custom tokens, like <artist_name> or <job_number> , so you don't have to type them manually in every export window. 2. Two Steps to Custom Tokens Adding a token is a two-part process: Step 1: Listing the Token ( get_hook_token_list ) You first have to tell Flame that your token exists so it shows up in the \"Add Token\" dropdown menu. - Contexts: You can add tokens for Browsing (MediaHub), Clips (Export), or Segments (Timeline). Step 2: Resolving the Token ( resolve_hook_token ) This is the \"Search and Replace\" part. When Flame sees your token, it runs this function to find out what the real value should be. def resolve_hook_token(context, context_info, token_name, hint): if token_name == \"<my_custom_token>\": return \"Real_Value_123\" 3. Advanced Trick: The \"Cache\" If you have a token that is hard to calculate (like asking a website for a job number), you don't want Flame to do that 1,000 times for 1,000 clips. The script shows an example of a TTL Cache (Time-To-Live). It calculates the value once and then \"remembers\" it for 5 seconds. This keeps Flame feeling fast and responsive. 4. Why is this useful? Dynamic Exporting: You can create an export path that automatically includes the current artist's name and the date without ever typing it. Project Context: Pull information from external files or databases and inject it directly into Flame's file naming. Consistency: Ensures that everyone in the studio uses the exact same naming format for their renders. 5. Key Takeaway for Beginners Tokens are like Variables for your filenames. By defining them in tokens_hook.py , you are creating a shortcut that turns complex, dynamic data into simple words that any Flame artist can use.","title":"Insight: Creating Custom Naming Tokens"},{"location":"insight/adsk/python/insight-tokens_hook/#insight-creating-custom-naming-tokens","text":"This document explains the tokens_hook.py file. It shows how to add your own \"Magic Words\" (Tokens) to Flame's naming and export windows. Target Audience: Novice Python programmers interested in dynamic naming and string manipulation.","title":"Insight: Creating Custom Naming Tokens"},{"location":"insight/adsk/python/insight-tokens_hook/#1-what-are-tokens","text":"You've probably seen tokens in Flame like <shot_name> or {width} . When you use them, Flame automatically replaces the token with the real name or resolution of the clip. The Goal: Add your own custom tokens, like <artist_name> or <job_number> , so you don't have to type them manually in every export window.","title":"1. What are Tokens?"},{"location":"insight/adsk/python/insight-tokens_hook/#2-two-steps-to-custom-tokens","text":"Adding a token is a two-part process:","title":"2. Two Steps to Custom Tokens"},{"location":"insight/adsk/python/insight-tokens_hook/#step-1-listing-the-token-get_hook_token_list","text":"You first have to tell Flame that your token exists so it shows up in the \"Add Token\" dropdown menu. - Contexts: You can add tokens for Browsing (MediaHub), Clips (Export), or Segments (Timeline).","title":"Step 1: Listing the Token (get_hook_token_list)"},{"location":"insight/adsk/python/insight-tokens_hook/#step-2-resolving-the-token-resolve_hook_token","text":"This is the \"Search and Replace\" part. When Flame sees your token, it runs this function to find out what the real value should be. def resolve_hook_token(context, context_info, token_name, hint): if token_name == \"<my_custom_token>\": return \"Real_Value_123\"","title":"Step 2: Resolving the Token (resolve_hook_token)"},{"location":"insight/adsk/python/insight-tokens_hook/#3-advanced-trick-the-cache","text":"If you have a token that is hard to calculate (like asking a website for a job number), you don't want Flame to do that 1,000 times for 1,000 clips. The script shows an example of a TTL Cache (Time-To-Live). It calculates the value once and then \"remembers\" it for 5 seconds. This keeps Flame feeling fast and responsive.","title":"3. Advanced Trick: The \"Cache\""},{"location":"insight/adsk/python/insight-tokens_hook/#4-why-is-this-useful","text":"Dynamic Exporting: You can create an export path that automatically includes the current artist's name and the date without ever typing it. Project Context: Pull information from external files or databases and inject it directly into Flame's file naming. Consistency: Ensures that everyone in the studio uses the exact same naming format for their renders.","title":"4. Why is this useful?"},{"location":"insight/adsk/python/insight-tokens_hook/#5-key-takeaway-for-beginners","text":"Tokens are like Variables for your filenames. By defining them in tokens_hook.py , you are creating a shortcut that turns complex, dynamic data into simple words that any Flame artist can use.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/","text":"Insight: Automating OCIO Context Variables in Flame This document explains the context_variables.py example script. It is designed to help you understand how to automate OpenColorIO (OCIO) Context Variables using the Autodesk Flame Python API. Target Audience: Novice Python programmers getting started with Flame automation. 1. What is the Goal? In modern color pipelines, we often use OCIO (OpenColorIO) to manage color spaces. A powerful feature of OCIO is Context Variables . Imagine you have a specific Color Correction file ( .cc or .lut ) for every single shot in your movie. Instead of manually loading shot_010.cc for Shot 010 and shot_020.cc for Shot 020, you can tell Flame: \"Look for a file named ${SHOT}.cc .\" Then, you just need to tell Flame what ${SHOT} equals for each clip. This script automates that second part. It takes the Shot Name of your clip (e.g., \"sh010\") and automatically plugs it into the SHOT Context Variable in the Color Management settings. 2. Key Functions Breakdown The script provides two main ways to do this: one for the Timeline and one for Batch . A. Timeline Workflow: add_cmfx_with_shot_based_cc This function adds a Source Colour Management Timeline FX to your segments. Selection Handling: First, it looks at what you selected. If you selected Segments , it uses them directly. If you selected Sequences , it finds all the segments inside them. Safety Check: It checks if you already have a Color Management effect. If yes, it pops up a dialog box asking: \"Do you want to overwrite the existing effect?\" This is great practice! It prevents your script from accidentally destroying previous work. The \"Magic\" Loop: It goes through each segment one by one: ```python # 1. Get the Shot Name shot_name = segment.shot_name.get_value() 2. Create the Effect clmgt = segment.create_effect(\"Source Colour Mgmt\") 3. Configure the Effect clmgt.mode = \"View Transform\" clmgt.view = \"Shot Based CC\" # This view expects a variable! 4. Set the Variable clmgt.set_context_variable(\"SHOT\", shot_name) `` **Result:** The effect is created, and the ${SHOT}` variable is now equal to \"sh010\" (or whatever your shot is named). B. Batch Workflow: add_cmnode_with_shot_based_cc This function works in the Batch schematic (Flame's node-based compositor). Selection Handling: It looks for Clip Nodes in your selection or inside selected Batch Groups. Node Creation: For every clip: It creates a new Colour Mgmt node. It connects it to the Clip node automatically. Tip: batch.connect_nodes(clip_node, \"Default\", clmgt, \"Default\") is how you wire things together with code. Setting the Variable: Just like the timeline version, it takes the shot_name from the clip and feeds it into clmgt.set_context_variable(\"SHOT\", shot_name) . 3. How does it appear in Flame? The functions at the bottom ( get_timeline_custom_ui_actions , etc.) tell Flame where to put this script in the menu. Context: You will see a new menu item \"Examples / Context Variables\" when you right-click on the Timeline, in Batch, or in the Media Panel. Visibility: The isVisible filters ensure you only see the \"Batch\" command when you are actually in Batch, and the \"Timeline\" command when you are on the Timeline. This keeps the menus clean. 4. Why is this useful? Without this script, you would have to: 1. Add a Color Mgmt node. 2. Open it. 3. Type the shot name into the Context Variable tab. 4. Repeat 100 times for 100 shots. With this script, you click one button, and it's done for all 100 shots instantly. 5. Next Steps for You Try modifying the script! - Challenge: Can you change it to use a different variable name, like SEQUENCE instead of SHOT ? - Hint: Look for the line clmgt.set_context_variable(\"SHOT\", shot_name) and change \"SHOT\" to \"SEQUENCE\" .","title":"Insight: Automating OCIO Context Variables in Flame"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#insight-automating-ocio-context-variables-in-flame","text":"This document explains the context_variables.py example script. It is designed to help you understand how to automate OpenColorIO (OCIO) Context Variables using the Autodesk Flame Python API. Target Audience: Novice Python programmers getting started with Flame automation.","title":"Insight: Automating OCIO Context Variables in Flame"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#1-what-is-the-goal","text":"In modern color pipelines, we often use OCIO (OpenColorIO) to manage color spaces. A powerful feature of OCIO is Context Variables . Imagine you have a specific Color Correction file ( .cc or .lut ) for every single shot in your movie. Instead of manually loading shot_010.cc for Shot 010 and shot_020.cc for Shot 020, you can tell Flame: \"Look for a file named ${SHOT}.cc .\" Then, you just need to tell Flame what ${SHOT} equals for each clip. This script automates that second part. It takes the Shot Name of your clip (e.g., \"sh010\") and automatically plugs it into the SHOT Context Variable in the Color Management settings.","title":"1. What is the Goal?"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#2-key-functions-breakdown","text":"The script provides two main ways to do this: one for the Timeline and one for Batch .","title":"2. Key Functions Breakdown"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#a-timeline-workflow-add_cmfx_with_shot_based_cc","text":"This function adds a Source Colour Management Timeline FX to your segments. Selection Handling: First, it looks at what you selected. If you selected Segments , it uses them directly. If you selected Sequences , it finds all the segments inside them. Safety Check: It checks if you already have a Color Management effect. If yes, it pops up a dialog box asking: \"Do you want to overwrite the existing effect?\" This is great practice! It prevents your script from accidentally destroying previous work. The \"Magic\" Loop: It goes through each segment one by one: ```python # 1. Get the Shot Name shot_name = segment.shot_name.get_value()","title":"A. Timeline Workflow: add_cmfx_with_shot_based_cc"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#2-create-the-effect","text":"clmgt = segment.create_effect(\"Source Colour Mgmt\")","title":"2. Create the Effect"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#3-configure-the-effect","text":"clmgt.mode = \"View Transform\" clmgt.view = \"Shot Based CC\" # This view expects a variable!","title":"3. Configure the Effect"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#4-set-the-variable","text":"clmgt.set_context_variable(\"SHOT\", shot_name) `` **Result:** The effect is created, and the ${SHOT}` variable is now equal to \"sh010\" (or whatever your shot is named).","title":"4. Set the Variable"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#b-batch-workflow-add_cmnode_with_shot_based_cc","text":"This function works in the Batch schematic (Flame's node-based compositor). Selection Handling: It looks for Clip Nodes in your selection or inside selected Batch Groups. Node Creation: For every clip: It creates a new Colour Mgmt node. It connects it to the Clip node automatically. Tip: batch.connect_nodes(clip_node, \"Default\", clmgt, \"Default\") is how you wire things together with code. Setting the Variable: Just like the timeline version, it takes the shot_name from the clip and feeds it into clmgt.set_context_variable(\"SHOT\", shot_name) .","title":"B. Batch Workflow: add_cmnode_with_shot_based_cc"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#3-how-does-it-appear-in-flame","text":"The functions at the bottom ( get_timeline_custom_ui_actions , etc.) tell Flame where to put this script in the menu. Context: You will see a new menu item \"Examples / Context Variables\" when you right-click on the Timeline, in Batch, or in the Media Panel. Visibility: The isVisible filters ensure you only see the \"Batch\" command when you are actually in Batch, and the \"Timeline\" command when you are on the Timeline. This keeps the menus clean.","title":"3. How does it appear in Flame?"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#4-why-is-this-useful","text":"Without this script, you would have to: 1. Add a Color Mgmt node. 2. Open it. 3. Type the shot name into the Context Variable tab. 4. Repeat 100 times for 100 shots. With this script, you click one button, and it's done for all 100 shots instantly.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/examples/insight-context_variables/#5-next-steps-for-you","text":"Try modifying the script! - Challenge: Can you change it to use a different variable name, like SEQUENCE instead of SHOT ? - Hint: Look for the line clmgt.set_context_variable(\"SHOT\", shot_name) and change \"SHOT\" to \"SEQUENCE\" .","title":"5. Next Steps for You"},{"location":"insight/adsk/python_utilities/examples/insight-conversion_description/","text":"Insight: Customizing Project Conversion in Flame This document explains the conversion_description.py example script. It is a simple but powerful example of using Hooks to automate tasks when upgrading projects in Autodesk Flame. Target Audience: Novice Python programmers interested in project management automation. 1. What is the Goal? When you upgrade Autodesk Flame to a new major version (e.g., from 2025 to 2026), your existing projects often need to be \"converted\" to work with the new software. Normally, this just happens. But what if you want to leave a \"paper trail\" or tag these projects so you know they have been changed? This script automates that tagging. - It automatically adds \" (Converted)\" to the end of the project's name. - It changes the project's description to say exactly when the conversion happened. 2. Key Concepts A. The \"Hook\" The core of this script is a special function name: project_init_conversion . Flame looks for this specific function name. If it finds it in a loaded script, it runs it right before the conversion process starts. B. The info Dictionary When Flame runs this function, it passes a variable called info to it. Think of info as a container (a Python dictionary) that holds the project's ID card: - info[\"project_name\"] : The name of the project. - info[\"project_description\"] : The description text you see in the startup screen. By changing the data inside this container, you change what Flame writes to the database. 3. Code Breakdown Let's look at the code line by line: import datetime def project_init_conversion(info): # 1. Modify the Name info[\"project_name\"] = info[\"project_name\"] + \" (Converted)\" # 2. Modify the Description timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") info[\"project_description\"] = \"Converted on {0}\".format(timestamp) import datetime : This imports a standard Python tool for working with dates and times. info[\"project_name\"] = ... : It takes the current name (e.g., \"MyCommercial\") and adds text to it. The new name becomes \"MyCommercial (Converted)\". info[\"project_description\"] = ... : datetime.datetime.now() gets the current moment. .strftime(...) formats it into a readable string like \"2026-01-29 14:30:00\". It overwrites the old description with this new timestamp. 4. Why is this useful? This is a perfect example of Workflow Safety . - Organization: You can instantly tell which projects have been migrated just by looking at the list. - Audit Trail: You know exactly when the migration happened. - Automation: You don't have to remember to type this in manually for every single project. 5. Next Steps for You Try customizing it! - Challenge: Instead of overwriting the description, can you append the date to the existing description so you don't lose the original text? - Hint: python # Try this instead: info[\"project_description\"] = info[\"project_description\"] + \" | Converted on: \" + timestamp","title":"Insight: Customizing Project Conversion in Flame"},{"location":"insight/adsk/python_utilities/examples/insight-conversion_description/#insight-customizing-project-conversion-in-flame","text":"This document explains the conversion_description.py example script. It is a simple but powerful example of using Hooks to automate tasks when upgrading projects in Autodesk Flame. Target Audience: Novice Python programmers interested in project management automation.","title":"Insight: Customizing Project Conversion in Flame"},{"location":"insight/adsk/python_utilities/examples/insight-conversion_description/#1-what-is-the-goal","text":"When you upgrade Autodesk Flame to a new major version (e.g., from 2025 to 2026), your existing projects often need to be \"converted\" to work with the new software. Normally, this just happens. But what if you want to leave a \"paper trail\" or tag these projects so you know they have been changed? This script automates that tagging. - It automatically adds \" (Converted)\" to the end of the project's name. - It changes the project's description to say exactly when the conversion happened.","title":"1. What is the Goal?"},{"location":"insight/adsk/python_utilities/examples/insight-conversion_description/#2-key-concepts","text":"","title":"2. Key Concepts"},{"location":"insight/adsk/python_utilities/examples/insight-conversion_description/#a-the-hook","text":"The core of this script is a special function name: project_init_conversion . Flame looks for this specific function name. If it finds it in a loaded script, it runs it right before the conversion process starts.","title":"A. The \"Hook\""},{"location":"insight/adsk/python_utilities/examples/insight-conversion_description/#b-the-info-dictionary","text":"When Flame runs this function, it passes a variable called info to it. Think of info as a container (a Python dictionary) that holds the project's ID card: - info[\"project_name\"] : The name of the project. - info[\"project_description\"] : The description text you see in the startup screen. By changing the data inside this container, you change what Flame writes to the database.","title":"B. The info Dictionary"},{"location":"insight/adsk/python_utilities/examples/insight-conversion_description/#3-code-breakdown","text":"Let's look at the code line by line: import datetime def project_init_conversion(info): # 1. Modify the Name info[\"project_name\"] = info[\"project_name\"] + \" (Converted)\" # 2. Modify the Description timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\") info[\"project_description\"] = \"Converted on {0}\".format(timestamp) import datetime : This imports a standard Python tool for working with dates and times. info[\"project_name\"] = ... : It takes the current name (e.g., \"MyCommercial\") and adds text to it. The new name becomes \"MyCommercial (Converted)\". info[\"project_description\"] = ... : datetime.datetime.now() gets the current moment. .strftime(...) formats it into a readable string like \"2026-01-29 14:30:00\". It overwrites the old description with this new timestamp.","title":"3. Code Breakdown"},{"location":"insight/adsk/python_utilities/examples/insight-conversion_description/#4-why-is-this-useful","text":"This is a perfect example of Workflow Safety . - Organization: You can instantly tell which projects have been migrated just by looking at the list. - Audit Trail: You know exactly when the migration happened. - Automation: You don't have to remember to type this in manually for every single project.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/examples/insight-conversion_description/#5-next-steps-for-you","text":"Try customizing it! - Challenge: Instead of overwriting the description, can you append the date to the existing description so you don't lose the original text? - Hint: python # Try this instead: info[\"project_description\"] = info[\"project_description\"] + \" | Converted on: \" + timestamp","title":"5. Next Steps for You"},{"location":"insight/adsk/python_utilities/examples/insight-custom_action_object/","text":"Insight: Using Callable Objects for Custom Actions This document explains the custom_action_object.py example script. It shows an advanced but very efficient way to create many similar menu items without writing a separate function for each one. Target Audience: Novice Python programmers learning about Classes and \"Callables.\" 1. The Problem: Repeating Yourself Imagine you want 4 menu items: \"Action 1\", \"Action 2\", \"Action 3\", and \"Action 4\". All of them should do basically the same thing, but they need to know which button was clicked. The \"old\" way would be to write 4 separate functions. That's a lot of copying and pasting! 2. The Solution: The \"Callable\" Object In Python, you can create a Class that acts like a function. This is called making an object \"callable.\" How it works: Look at the Action class inside the script: class Action(object): def __init__(self, action_id): self._action_id = action_id # Remember which ID I am def __call__(self, selection): # This makes the object act like a function! return action_on_selection(self._action_id, selection) __init__ : When we create Action(\"Action1\") , it saves \"Action1\" inside itself. __call__ : This is a special Python magic method. It tells Python: \"If someone tries to run this object like a function (using parentheses), run this code.\" 3. Why is this powerful? Look at how the menu is built in the loop: action_ids = [\"Action1\", \"Action2\", \"Action3\", \"Action4\"] for action_id in action_ids: # We create a NEW object for each ID actions[\"actions\"].append({ \"name\": action_id, \"execute\": Action(action_id) # Pass the object as the command }) By using this trick, you can generate hundreds of menu items dynamically (for example, one for every preset file in a folder) while only writing the logic once . 4. Key Takeaway for Beginners If you find yourself writing function1() , function2() , function3() that all look identical, consider using a Callable Class . It keeps your code clean, short, and much easier to fix if you need to change the logic later!","title":"Insight: Using Callable Objects for Custom Actions"},{"location":"insight/adsk/python_utilities/examples/insight-custom_action_object/#insight-using-callable-objects-for-custom-actions","text":"This document explains the custom_action_object.py example script. It shows an advanced but very efficient way to create many similar menu items without writing a separate function for each one. Target Audience: Novice Python programmers learning about Classes and \"Callables.\"","title":"Insight: Using Callable Objects for Custom Actions"},{"location":"insight/adsk/python_utilities/examples/insight-custom_action_object/#1-the-problem-repeating-yourself","text":"Imagine you want 4 menu items: \"Action 1\", \"Action 2\", \"Action 3\", and \"Action 4\". All of them should do basically the same thing, but they need to know which button was clicked. The \"old\" way would be to write 4 separate functions. That's a lot of copying and pasting!","title":"1. The Problem: Repeating Yourself"},{"location":"insight/adsk/python_utilities/examples/insight-custom_action_object/#2-the-solution-the-callable-object","text":"In Python, you can create a Class that acts like a function. This is called making an object \"callable.\"","title":"2. The Solution: The \"Callable\" Object"},{"location":"insight/adsk/python_utilities/examples/insight-custom_action_object/#how-it-works","text":"Look at the Action class inside the script: class Action(object): def __init__(self, action_id): self._action_id = action_id # Remember which ID I am def __call__(self, selection): # This makes the object act like a function! return action_on_selection(self._action_id, selection) __init__ : When we create Action(\"Action1\") , it saves \"Action1\" inside itself. __call__ : This is a special Python magic method. It tells Python: \"If someone tries to run this object like a function (using parentheses), run this code.\"","title":"How it works:"},{"location":"insight/adsk/python_utilities/examples/insight-custom_action_object/#3-why-is-this-powerful","text":"Look at how the menu is built in the loop: action_ids = [\"Action1\", \"Action2\", \"Action3\", \"Action4\"] for action_id in action_ids: # We create a NEW object for each ID actions[\"actions\"].append({ \"name\": action_id, \"execute\": Action(action_id) # Pass the object as the command }) By using this trick, you can generate hundreds of menu items dynamically (for example, one for every preset file in a folder) while only writing the logic once .","title":"3. Why is this powerful?"},{"location":"insight/adsk/python_utilities/examples/insight-custom_action_object/#4-key-takeaway-for-beginners","text":"If you find yourself writing function1() , function2() , function3() that all look identical, consider using a Callable Class . It keeps your code clean, short, and much easier to fix if you need to change the logic later!","title":"4. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-custom_menu_structure/","text":"Insight: Designing Complex Menus in Flame This document explains the custom_menu_structure.py example script. It shows how to organize your Python scripts into clean, professional submenus within the Flame interface. Target Audience: Novice Python programmers who want to improve the \"Look and Feel\" of their tools. 1. Organizing Your Tools When you start writing many scripts, putting them all in one long list makes the Flame UI messy. Professional tools use Submenus , Ordering , and Separators . 2. The \"Modern\" Way (Flame 2023.2+) In newer versions of Flame, the API gives you precise control over the menu layout using three key attributes: A. hierarchy This tells Flame where to put your menu item. - hierarchy: [] means \"put this in the main right-click menu.\" - hierarchy: [\"Example / Add Nodes\"] means \"put this inside the 'Add Nodes' folder.\" B. order Normally, Flame lists things alphabetically. order lets you force a specific sequence. - An item with order: 1 will always appear above order: 2 . C. separator Use \"separator\": \"below\" to draw a thin line in the menu. This is great for grouping related tools together (e.g., separating \"Import\" tools from \"Export\" tools). 3. Code Example Breakdown The script creates a main category called \"Example / Add Nodes\" . Inside that, it creates two sub-folders: Tools: Contains \"Add Resize\" and \"Add Mono\". Outputs: Contains \"Add Render\" and \"Add Write File\". { \"name\": \"Tools\", \"hierarchy\": [\"Example / Add Nodes\"], # Put inside the main folder \"order\": 1, # Show this folder first \"separator\": \"below\", # Put a line under this folder \"actions\": [...] # The actual buttons } 4. Supporting Older Versions The script also shows how to use maximumVersion . - If a user is on an old version of Flame that doesn't support submenus, the script provides a \"flat list\" instead. - Why? This ensures your script doesn't crash if a colleague is using an older version of the software. 5. Key Takeaway for Beginners Good code isn't just about what it does ; it's about how easy it is for a human to use . Taking five minutes to organize your menus makes your tools feel like a built-in part of Flame!","title":"Insight: Designing Complex Menus in Flame"},{"location":"insight/adsk/python_utilities/examples/insight-custom_menu_structure/#insight-designing-complex-menus-in-flame","text":"This document explains the custom_menu_structure.py example script. It shows how to organize your Python scripts into clean, professional submenus within the Flame interface. Target Audience: Novice Python programmers who want to improve the \"Look and Feel\" of their tools.","title":"Insight: Designing Complex Menus in Flame"},{"location":"insight/adsk/python_utilities/examples/insight-custom_menu_structure/#1-organizing-your-tools","text":"When you start writing many scripts, putting them all in one long list makes the Flame UI messy. Professional tools use Submenus , Ordering , and Separators .","title":"1. Organizing Your Tools"},{"location":"insight/adsk/python_utilities/examples/insight-custom_menu_structure/#2-the-modern-way-flame-20232","text":"In newer versions of Flame, the API gives you precise control over the menu layout using three key attributes:","title":"2. The \"Modern\" Way (Flame 2023.2+)"},{"location":"insight/adsk/python_utilities/examples/insight-custom_menu_structure/#a-hierarchy","text":"This tells Flame where to put your menu item. - hierarchy: [] means \"put this in the main right-click menu.\" - hierarchy: [\"Example / Add Nodes\"] means \"put this inside the 'Add Nodes' folder.\"","title":"A. hierarchy"},{"location":"insight/adsk/python_utilities/examples/insight-custom_menu_structure/#b-order","text":"Normally, Flame lists things alphabetically. order lets you force a specific sequence. - An item with order: 1 will always appear above order: 2 .","title":"B. order"},{"location":"insight/adsk/python_utilities/examples/insight-custom_menu_structure/#c-separator","text":"Use \"separator\": \"below\" to draw a thin line in the menu. This is great for grouping related tools together (e.g., separating \"Import\" tools from \"Export\" tools).","title":"C. separator"},{"location":"insight/adsk/python_utilities/examples/insight-custom_menu_structure/#3-code-example-breakdown","text":"The script creates a main category called \"Example / Add Nodes\" . Inside that, it creates two sub-folders: Tools: Contains \"Add Resize\" and \"Add Mono\". Outputs: Contains \"Add Render\" and \"Add Write File\". { \"name\": \"Tools\", \"hierarchy\": [\"Example / Add Nodes\"], # Put inside the main folder \"order\": 1, # Show this folder first \"separator\": \"below\", # Put a line under this folder \"actions\": [...] # The actual buttons }","title":"3. Code Example Breakdown"},{"location":"insight/adsk/python_utilities/examples/insight-custom_menu_structure/#4-supporting-older-versions","text":"The script also shows how to use maximumVersion . - If a user is on an old version of Flame that doesn't support submenus, the script provides a \"flat list\" instead. - Why? This ensures your script doesn't crash if a colleague is using an older version of the software.","title":"4. Supporting Older Versions"},{"location":"insight/adsk/python_utilities/examples/insight-custom_menu_structure/#5-key-takeaway-for-beginners","text":"Good code isn't just about what it does ; it's about how easy it is for a human to use . Taking five minutes to organize your menus makes your tools feel like a built-in part of Flame!","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-import_file_using_custom_dialog/","text":"Insight: Custom File Browsers in Flame This document explains the import_file_using_custom_dialog.py example script. It shows two different ways to let a user pick files from their computer using Python. Target Audience: Novice Python programmers interested in User Interface (UI) design. 1. Why Not Just Hardcode Paths? If you write a script that always imports C:\\Media\\shot.mov , it only works once. To make a tool useful, you need to let the user browse and select the files they want. 2. Two Different Approaches This script shows two ways to do this: A. The \"Standard Computer\" Way (Qt / PySide6) This uses PySide6 , which is the industry-standard way to make windows and buttons in Python. - Pros: It looks like a normal Windows or Mac folder window. It's familiar to everyone. - How it works: python from PySide6 import QtWidgets dlg = QtWidgets.QFileDialog() # Create a window if dlg.exec(): # Show the window and wait for the user to click OK files = dlg.selectedFiles() # Get the list of chosen files B. The \"Flame Native\" Way ( flame.browser ) Flame has its own built-in file browser. - Pros: It looks exactly like Flame. It understands Flame-specific things like \"Clips\" and \"Frame Sequences.\" - How it works: python import flame flame.browser.show(title=\"Select Clips\", multi_selection=True) # The user's choice is saved in flame.browser.selection flame.batch.import_clips(flame.browser.selection, ...) 3. Scoping: Making the Menu Context-Aware The script uses a clever trick to make sure the \"Import\" buttons only appear when you right-click on the background of the Batch schematic: def scope_background(selection): return len(selection) == 0 # Only True if NOTHING is selected If you right-click on a clip node, this menu won't show up. This prevents clutter and ensures you don't try to \"import into a clip.\" 4. Key Takeaway for Beginners Use PySide6 if you want a standard OS feeling or need special filters (like \"only show .jpg\"). Use flame.browser if you want your tool to feel like a native part of the Flame experience. Both ways ultimately give you a Path (a string of text like /Users/pman/Desktop/video.mov ) which you then pass to Flame's import_clip() command.","title":"Insight: Custom File Browsers in Flame"},{"location":"insight/adsk/python_utilities/examples/insight-import_file_using_custom_dialog/#insight-custom-file-browsers-in-flame","text":"This document explains the import_file_using_custom_dialog.py example script. It shows two different ways to let a user pick files from their computer using Python. Target Audience: Novice Python programmers interested in User Interface (UI) design.","title":"Insight: Custom File Browsers in Flame"},{"location":"insight/adsk/python_utilities/examples/insight-import_file_using_custom_dialog/#1-why-not-just-hardcode-paths","text":"If you write a script that always imports C:\\Media\\shot.mov , it only works once. To make a tool useful, you need to let the user browse and select the files they want.","title":"1. Why Not Just Hardcode Paths?"},{"location":"insight/adsk/python_utilities/examples/insight-import_file_using_custom_dialog/#2-two-different-approaches","text":"This script shows two ways to do this:","title":"2. Two Different Approaches"},{"location":"insight/adsk/python_utilities/examples/insight-import_file_using_custom_dialog/#a-the-standard-computer-way-qt-pyside6","text":"This uses PySide6 , which is the industry-standard way to make windows and buttons in Python. - Pros: It looks like a normal Windows or Mac folder window. It's familiar to everyone. - How it works: python from PySide6 import QtWidgets dlg = QtWidgets.QFileDialog() # Create a window if dlg.exec(): # Show the window and wait for the user to click OK files = dlg.selectedFiles() # Get the list of chosen files","title":"A. The \"Standard Computer\" Way (Qt / PySide6)"},{"location":"insight/adsk/python_utilities/examples/insight-import_file_using_custom_dialog/#b-the-flame-native-way-flamebrowser","text":"Flame has its own built-in file browser. - Pros: It looks exactly like Flame. It understands Flame-specific things like \"Clips\" and \"Frame Sequences.\" - How it works: python import flame flame.browser.show(title=\"Select Clips\", multi_selection=True) # The user's choice is saved in flame.browser.selection flame.batch.import_clips(flame.browser.selection, ...)","title":"B. The \"Flame Native\" Way (flame.browser)"},{"location":"insight/adsk/python_utilities/examples/insight-import_file_using_custom_dialog/#3-scoping-making-the-menu-context-aware","text":"The script uses a clever trick to make sure the \"Import\" buttons only appear when you right-click on the background of the Batch schematic: def scope_background(selection): return len(selection) == 0 # Only True if NOTHING is selected If you right-click on a clip node, this menu won't show up. This prevents clutter and ensures you don't try to \"import into a clip.\"","title":"3. Scoping: Making the Menu Context-Aware"},{"location":"insight/adsk/python_utilities/examples/insight-import_file_using_custom_dialog/#4-key-takeaway-for-beginners","text":"Use PySide6 if you want a standard OS feeling or need special filters (like \"only show .jpg\"). Use flame.browser if you want your tool to feel like a native part of the Flame experience. Both ways ultimately give you a Path (a string of text like /Users/pman/Desktop/video.mov ) which you then pass to Flame's import_clip() command.","title":"4. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-object_scoping/","text":"Insight: Scoping Tools to Specific Objects This document explains the object_scoping.py example script. It shows how to make your Python tools \"smart\" so they only appear when they are actually useful. Target Audience: Novice Python programmers who want to clean up their Flame menus. 1. What is Scoping? If you write a script that \"Deletes All Render Nodes,\" you don't want that script to show up when you right-click on a Clip or an Audio Track . Scoping is the process of checking what the user has selected before showing the menu. 2. Three Common Scoping Patterns The script shows three ways to filter your selection: A. Background Scoping (Nothing Selected) Use this for tools that create new things from scratch, like \"Import Media\" or \"Create New Reel.\" def scope_background(selection): return len(selection) == 0 # True only if the background was clicked B. Object Type Scoping (Is it a Node?) Use this if your script only works on specific types of Flame objects. def scope_object(selection): for item in selection: if isinstance(item, flame.PyNode): # Is this a Batch Node? return True return False C. Specific Node Scoping (Is it a 'Comp' Node?) This is the most precise. It checks the specific kind of node. def scope_node(selection): for item in selection: if isinstance(item, flame.PyNode) and item.type == \"Comp\": return True return False 3. How to use it in your Menu Once you've written your scoping function, you simply plug it into your menu definition using the isVisible or isEnabled key: { \"name\": \"My Smart Tool\", \"isVisible\": scope_node, # Flame runs this function automatically! \"execute\": my_main_function } 4. Why is this useful? Prevent Errors: Users can't run a \"Batch\" script on a \"Timeline\" segment by mistake. Cleaner UI: Your right-click menu stays short and relevant to what you are doing. Professionalism: This is how built-in Flame tools work. 5. Key Takeaway for Beginners Think of scoping as an \"If Statement\" for your menu. Before you write the logic for what your tool does , first decide exactly where it belongs!","title":"Insight: Scoping Tools to Specific Objects"},{"location":"insight/adsk/python_utilities/examples/insight-object_scoping/#insight-scoping-tools-to-specific-objects","text":"This document explains the object_scoping.py example script. It shows how to make your Python tools \"smart\" so they only appear when they are actually useful. Target Audience: Novice Python programmers who want to clean up their Flame menus.","title":"Insight: Scoping Tools to Specific Objects"},{"location":"insight/adsk/python_utilities/examples/insight-object_scoping/#1-what-is-scoping","text":"If you write a script that \"Deletes All Render Nodes,\" you don't want that script to show up when you right-click on a Clip or an Audio Track . Scoping is the process of checking what the user has selected before showing the menu.","title":"1. What is Scoping?"},{"location":"insight/adsk/python_utilities/examples/insight-object_scoping/#2-three-common-scoping-patterns","text":"The script shows three ways to filter your selection:","title":"2. Three Common Scoping Patterns"},{"location":"insight/adsk/python_utilities/examples/insight-object_scoping/#a-background-scoping-nothing-selected","text":"Use this for tools that create new things from scratch, like \"Import Media\" or \"Create New Reel.\" def scope_background(selection): return len(selection) == 0 # True only if the background was clicked","title":"A. Background Scoping (Nothing Selected)"},{"location":"insight/adsk/python_utilities/examples/insight-object_scoping/#b-object-type-scoping-is-it-a-node","text":"Use this if your script only works on specific types of Flame objects. def scope_object(selection): for item in selection: if isinstance(item, flame.PyNode): # Is this a Batch Node? return True return False","title":"B. Object Type Scoping (Is it a Node?)"},{"location":"insight/adsk/python_utilities/examples/insight-object_scoping/#c-specific-node-scoping-is-it-a-comp-node","text":"This is the most precise. It checks the specific kind of node. def scope_node(selection): for item in selection: if isinstance(item, flame.PyNode) and item.type == \"Comp\": return True return False","title":"C. Specific Node Scoping (Is it a 'Comp' Node?)"},{"location":"insight/adsk/python_utilities/examples/insight-object_scoping/#3-how-to-use-it-in-your-menu","text":"Once you've written your scoping function, you simply plug it into your menu definition using the isVisible or isEnabled key: { \"name\": \"My Smart Tool\", \"isVisible\": scope_node, # Flame runs this function automatically! \"execute\": my_main_function }","title":"3. How to use it in your Menu"},{"location":"insight/adsk/python_utilities/examples/insight-object_scoping/#4-why-is-this-useful","text":"Prevent Errors: Users can't run a \"Batch\" script on a \"Timeline\" segment by mistake. Cleaner UI: Your right-click menu stays short and relevant to what you are doing. Professionalism: This is how built-in Flame tools work.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/examples/insight-object_scoping/#5-key-takeaway-for-beginners","text":"Think of scoping as an \"If Statement\" for your menu. Before you write the logic for what your tool does , first decide exactly where it belongs!","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_asset_after_snapshot/","text":"Insight: Automating Snapshots with Post-Export Hooks This document explains the post_export_asset_using_snapshot.py example script. It shows how Flame can \"watch\" its own export process and perform an action immediately after a file is saved. Target Audience: Novice Python programmers interested in workflow automation and \"Self-Healing\" pipelines. 1. What is an \"Export Snapshot\"? In Flame, a Snapshot is a quick way to save a single frame or a short clip as a file on your hard drive. Usually, once you hit export, the process is finished. The Goal: Every time you take a snapshot in the Player, Flame should automatically re-import that file back onto your Desktop reels. 2. The post_export_asset Hook Flame has a special \"event\" called post_export_asset . Every time any export finishes, Flame shouts: \"Hey! I just finished exporting something. Does anyone want to do anything with it?\" Our script listens for that shout. 3. How the Script Works The script follows three logic steps: Step 1: Filter the Noise Since this hook runs for every export (even big renders), we first check if this was actually a Snapshot: if info[\"isSnapshot\"]: # Is this a snapshot, or a regular export? Step 2: Find the Destination The script looks at your project and finds the first reel on your Desktop: reel = flame.projects.current_project.current_workspace.desktop.reel_groups[0].reels[0] Step 3: Re-Import the File Flame tells the script exactly where the file was saved using info[\"destinationPath\"] . The script then tells Flame to import that path: clip_path = os.path.join(info[\"destinationPath\"], info[\"resolvedPath\"]) flame.import_clips(clip_path, reel) 4. Why is this powerful? This creates a Loop . You can stay in the Player, take snapshots of different versions of a shot, and when you look back at your Desktop, they are all waiting for you in a neat reel. It eliminates the tedious manual task of: 1. Exporting. 2. Opening the MediaHub. 3. Browsing to the folder. 4. Dragging the file in. 5. Key Takeaway for Beginners Hooks like post_export_asset allow Flame to talk to itself. By using the information Flame provides in the info dictionary, you can bridge the gap between \"Saving a File\" and \"Using a File.\"","title":"Insight: Automating Snapshots with Post-Export Hooks"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_asset_after_snapshot/#insight-automating-snapshots-with-post-export-hooks","text":"This document explains the post_export_asset_using_snapshot.py example script. It shows how Flame can \"watch\" its own export process and perform an action immediately after a file is saved. Target Audience: Novice Python programmers interested in workflow automation and \"Self-Healing\" pipelines.","title":"Insight: Automating Snapshots with Post-Export Hooks"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_asset_after_snapshot/#1-what-is-an-export-snapshot","text":"In Flame, a Snapshot is a quick way to save a single frame or a short clip as a file on your hard drive. Usually, once you hit export, the process is finished. The Goal: Every time you take a snapshot in the Player, Flame should automatically re-import that file back onto your Desktop reels.","title":"1. What is an \"Export Snapshot\"?"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_asset_after_snapshot/#2-the-post_export_asset-hook","text":"Flame has a special \"event\" called post_export_asset . Every time any export finishes, Flame shouts: \"Hey! I just finished exporting something. Does anyone want to do anything with it?\" Our script listens for that shout.","title":"2. The post_export_asset Hook"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_asset_after_snapshot/#3-how-the-script-works","text":"The script follows three logic steps:","title":"3. How the Script Works"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_asset_after_snapshot/#step-1-filter-the-noise","text":"Since this hook runs for every export (even big renders), we first check if this was actually a Snapshot: if info[\"isSnapshot\"]: # Is this a snapshot, or a regular export?","title":"Step 1: Filter the Noise"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_asset_after_snapshot/#step-2-find-the-destination","text":"The script looks at your project and finds the first reel on your Desktop: reel = flame.projects.current_project.current_workspace.desktop.reel_groups[0].reels[0]","title":"Step 2: Find the Destination"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_asset_after_snapshot/#step-3-re-import-the-file","text":"Flame tells the script exactly where the file was saved using info[\"destinationPath\"] . The script then tells Flame to import that path: clip_path = os.path.join(info[\"destinationPath\"], info[\"resolvedPath\"]) flame.import_clips(clip_path, reel)","title":"Step 3: Re-Import the File"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_asset_after_snapshot/#4-why-is-this-powerful","text":"This creates a Loop . You can stay in the Player, take snapshots of different versions of a shot, and when you look back at your Desktop, they are all waiting for you in a neat reel. It eliminates the tedious manual task of: 1. Exporting. 2. Opening the MediaHub. 3. Browsing to the folder. 4. Dragging the file in.","title":"4. Why is this powerful?"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_asset_after_snapshot/#5-key-takeaway-for-beginners","text":"Hooks like post_export_asset allow Flame to talk to itself. By using the information Flame provides in the info dictionary, you can bridge the gap between \"Saving a File\" and \"Using a File.\"","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_dependency/","text":"Insight: Chaining Complex Jobs with Export Dependencies This document explains the post_export_dependency.py example script. This is an advanced script that shows how to make multiple tasks happen in a specific order, even if they take a long time. Target Audience: Novice Python programmers interested in \"Pipeline Engineering.\" 1. The Concept: \"Wait For Me\" Sometimes, exporting a clip is only the first step. You might want to: 1. Export a clip as a sequence of images. 2. THEN Zip those images into one file. 3. THEN Send an email saying it's done. The problem? Step 2 cannot start until Step 1 is 100% finished. If Step 1 is happening on Backburner (in the background), your script needs a way to wait. 2. Using Backburner Dependencies The \"Magic\" in this script is the Job ID . When Flame sends an export to Backburner, it gets back a unique ID number (e.g., Job #1234). Our script tells Backburner: \"I want to run a Zip command, but DO NOT START until Job #1234 is finished successfully.\" This is called a Dependency . 3. Key Workflows in the Script The script demonstrates several \"Chain Reactions\": A. Export & Zip It exports files and then automatically sends a command to the computer's zip tool. B. Export & Transcode (FFmpeg) It exports high-quality images and then triggers FFmpeg (a famous video tool) to create a small preview movie automatically. - Tip: Look for cmd = \"/usr/local/bin/ffmpeg ...\" . This is how Flame talks to other software on your computer! C. Export & Re-Import This is the most advanced. It uses an Idle Loop ( flame.schedule_idle_event ). - The script checks every 1 second: \"Is the background job done yet?\" - As soon as the answer is \"Yes\" , it automatically imports the file back into Batch. 4. Why Use flame.execute_command ? The script mentions a special function flame.execute_command . - Beginner Tip: In regular Python, people use os.system or subprocess . - Flame Tip: In Flame, using flame.execute_command is much safer and faster because it doesn't \"fork\" (copy) the entire memory of Flame just to run a tiny command. 5. Key Takeaway for Beginners This script shows that Flame isn't just a creative tool; it can be the \"Brain\" of your whole studio. By chaining jobs together using Dependencies, you can build complex, automated workflows that run while you sleep!","title":"Insight: Chaining Complex Jobs with Export Dependencies"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_dependency/#insight-chaining-complex-jobs-with-export-dependencies","text":"This document explains the post_export_dependency.py example script. This is an advanced script that shows how to make multiple tasks happen in a specific order, even if they take a long time. Target Audience: Novice Python programmers interested in \"Pipeline Engineering.\"","title":"Insight: Chaining Complex Jobs with Export Dependencies"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_dependency/#1-the-concept-wait-for-me","text":"Sometimes, exporting a clip is only the first step. You might want to: 1. Export a clip as a sequence of images. 2. THEN Zip those images into one file. 3. THEN Send an email saying it's done. The problem? Step 2 cannot start until Step 1 is 100% finished. If Step 1 is happening on Backburner (in the background), your script needs a way to wait.","title":"1. The Concept: \"Wait For Me\""},{"location":"insight/adsk/python_utilities/examples/insight-post_export_dependency/#2-using-backburner-dependencies","text":"The \"Magic\" in this script is the Job ID . When Flame sends an export to Backburner, it gets back a unique ID number (e.g., Job #1234). Our script tells Backburner: \"I want to run a Zip command, but DO NOT START until Job #1234 is finished successfully.\" This is called a Dependency .","title":"2. Using Backburner Dependencies"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_dependency/#3-key-workflows-in-the-script","text":"The script demonstrates several \"Chain Reactions\":","title":"3. Key Workflows in the Script"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_dependency/#a-export-zip","text":"It exports files and then automatically sends a command to the computer's zip tool.","title":"A. Export &amp; Zip"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_dependency/#b-export-transcode-ffmpeg","text":"It exports high-quality images and then triggers FFmpeg (a famous video tool) to create a small preview movie automatically. - Tip: Look for cmd = \"/usr/local/bin/ffmpeg ...\" . This is how Flame talks to other software on your computer!","title":"B. Export &amp; Transcode (FFmpeg)"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_dependency/#c-export-re-import","text":"This is the most advanced. It uses an Idle Loop ( flame.schedule_idle_event ). - The script checks every 1 second: \"Is the background job done yet?\" - As soon as the answer is \"Yes\" , it automatically imports the file back into Batch.","title":"C. Export &amp; Re-Import"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_dependency/#4-why-use-flameexecute_command","text":"The script mentions a special function flame.execute_command . - Beginner Tip: In regular Python, people use os.system or subprocess . - Flame Tip: In Flame, using flame.execute_command is much safer and faster because it doesn't \"fork\" (copy) the entire memory of Flame just to run a tiny command.","title":"4. Why Use flame.execute_command?"},{"location":"insight/adsk/python_utilities/examples/insight-post_export_dependency/#5-key-takeaway-for-beginners","text":"This script shows that Flame isn't just a creative tool; it can be the \"Brain\" of your whole studio. By chaining jobs together using Dependencies, you can build complex, automated workflows that run while you sleep!","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-project_protection/","text":"Insight: Protecting Your Projects with Hooks This document explains the project_protection.py example script. It shows how to create \"Safety Locks\" that prevent people from accidentally editing or deleting important Flame projects. Target Audience: Novice Python programmers interested in system administration and data safety. 1. What is Project Protection? In a busy studio, you might have a project named \"Final_Master_Render\". You don't want a junior artist or a tired editor to accidentally delete it or change its settings. The Solution: A script that automatically blocks certain actions if the project name matches a \"Restricted\" list. 2. The \"Abort\" Mechanism Flame has hooks that run before a project is edited, deleted, or converted: - project_pre_edition - project_pre_delete - project_pre_conversion These hooks are special because they allow you to Cancel the action before it happens. 3. How the Script Works The script defines a list of \"Danger\" names: restricted_project_names = [\"final\", \"final_final\"] Then, it creates a check function that looks at the current project: def check(info): # If the name is in our list, set 'abort' to True info[\"abort\"] = info[\"project_name\"] in restricted_project_names # Give the user a reason why it failed info[\"abort_message\"] = \"This project is flagged as restricted.\" When info[\"abort\"] is set to True , Flame stops whatever it was doing and pops up a message box with your abort_message . 4. Why is this useful? Zero Accidents: It's impossible to delete a \"protected\" project while this script is active. Workflow Control: You can ensure that only specific projects (like those following a naming convention) can be modified. Peace of Mind: You don't have to rely on \"Common Sense\" when you have a script enforcing the rules! 5. Key Takeaway for Beginners Hooks with an abort option are like Security Guards . They stand at the door and check IDs before letting anyone change your important data.","title":"Insight: Protecting Your Projects with Hooks"},{"location":"insight/adsk/python_utilities/examples/insight-project_protection/#insight-protecting-your-projects-with-hooks","text":"This document explains the project_protection.py example script. It shows how to create \"Safety Locks\" that prevent people from accidentally editing or deleting important Flame projects. Target Audience: Novice Python programmers interested in system administration and data safety.","title":"Insight: Protecting Your Projects with Hooks"},{"location":"insight/adsk/python_utilities/examples/insight-project_protection/#1-what-is-project-protection","text":"In a busy studio, you might have a project named \"Final_Master_Render\". You don't want a junior artist or a tired editor to accidentally delete it or change its settings. The Solution: A script that automatically blocks certain actions if the project name matches a \"Restricted\" list.","title":"1. What is Project Protection?"},{"location":"insight/adsk/python_utilities/examples/insight-project_protection/#2-the-abort-mechanism","text":"Flame has hooks that run before a project is edited, deleted, or converted: - project_pre_edition - project_pre_delete - project_pre_conversion These hooks are special because they allow you to Cancel the action before it happens.","title":"2. The \"Abort\" Mechanism"},{"location":"insight/adsk/python_utilities/examples/insight-project_protection/#3-how-the-script-works","text":"The script defines a list of \"Danger\" names: restricted_project_names = [\"final\", \"final_final\"] Then, it creates a check function that looks at the current project: def check(info): # If the name is in our list, set 'abort' to True info[\"abort\"] = info[\"project_name\"] in restricted_project_names # Give the user a reason why it failed info[\"abort_message\"] = \"This project is flagged as restricted.\" When info[\"abort\"] is set to True , Flame stops whatever it was doing and pops up a message box with your abort_message .","title":"3. How the Script Works"},{"location":"insight/adsk/python_utilities/examples/insight-project_protection/#4-why-is-this-useful","text":"Zero Accidents: It's impossible to delete a \"protected\" project while this script is active. Workflow Control: You can ensure that only specific projects (like those following a naming convention) can be modified. Peace of Mind: You don't have to rely on \"Common Sense\" when you have a script enforcing the rules!","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/examples/insight-project_protection/#5-key-takeaway-for-beginners","text":"Hooks with an abort option are like Security Guards . They stand at the door and check IDs before letting anyone change your important data.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-show_messages/","text":"Insight: Talking to the User (Console vs. Dialogs) This document explains the show_messages.py example script. It shows how your Python script can \"talk\" back to the person using Flame, either quietly in the corner or with a pop-up window. Target Audience: Novice Python programmers interested in User Experience (UX). 1. Two Ways to Communicate When your script runs, it often needs to tell the user something. Flame provides two main channels for this: A. The Console / Message Bar ( show_in_console ) This is the small text bar at the bottom of the Flame screen. Use this for non-critical info that doesn't need to stop the user's flow. - Example: A countdown or a status update. - Code: python flame.messages.show_in_console(\"Processing clip...\", \"info\", duration=5) - Types: You can use \"info\" , \"warning\" , or \"error\" to change the color/priority. B. The Dialog Box ( show_in_dialog ) This is a \"modal\" pop-up. It stops everything and waits for the user to click a button. Use this for critical errors or when you need the user to make a choice. - Example: Telling the user they forgot to select a clip. - Code: python flame.messages.show_in_dialog( title=\"Error\", message=\"Please select a clip first!\", type=\"error\", buttons=[\"OK\"] ) 2. Practical Examples in the Script The Countdown The countdown function shows how you can update the console in real-time. It uses time.sleep(1) to wait one second between numbers. The Disk Space Checker The freespace function uses a standard Python tool ( shutil ) to check your hard drive. - If you have plenty of space, it shows an Info message (usually green/white). - If space is low, it shows a Warning message (usually yellow/orange). The Error Catcher The set_batch_duration function tries to set the length of a Batch group. If it fails (because there's no clip), it uses a Dialog Box to explain exactly what went wrong. 3. Key Takeaway for Beginners Use the Console for \"FYI\" messages (Status updates, progress). Use Dialogs for \"STOP\" messages (Errors, confirmations, questions). Always try to give the user helpful information. A script that fails silently is frustrating; a script that says \"No Clip Found\" is helpful!","title":"Insight: Talking to the User (Console vs. Dialogs)"},{"location":"insight/adsk/python_utilities/examples/insight-show_messages/#insight-talking-to-the-user-console-vs-dialogs","text":"This document explains the show_messages.py example script. It shows how your Python script can \"talk\" back to the person using Flame, either quietly in the corner or with a pop-up window. Target Audience: Novice Python programmers interested in User Experience (UX).","title":"Insight: Talking to the User (Console vs. Dialogs)"},{"location":"insight/adsk/python_utilities/examples/insight-show_messages/#1-two-ways-to-communicate","text":"When your script runs, it often needs to tell the user something. Flame provides two main channels for this:","title":"1. Two Ways to Communicate"},{"location":"insight/adsk/python_utilities/examples/insight-show_messages/#a-the-console-message-bar-show_in_console","text":"This is the small text bar at the bottom of the Flame screen. Use this for non-critical info that doesn't need to stop the user's flow. - Example: A countdown or a status update. - Code: python flame.messages.show_in_console(\"Processing clip...\", \"info\", duration=5) - Types: You can use \"info\" , \"warning\" , or \"error\" to change the color/priority.","title":"A. The Console / Message Bar (show_in_console)"},{"location":"insight/adsk/python_utilities/examples/insight-show_messages/#b-the-dialog-box-show_in_dialog","text":"This is a \"modal\" pop-up. It stops everything and waits for the user to click a button. Use this for critical errors or when you need the user to make a choice. - Example: Telling the user they forgot to select a clip. - Code: python flame.messages.show_in_dialog( title=\"Error\", message=\"Please select a clip first!\", type=\"error\", buttons=[\"OK\"] )","title":"B. The Dialog Box (show_in_dialog)"},{"location":"insight/adsk/python_utilities/examples/insight-show_messages/#2-practical-examples-in-the-script","text":"","title":"2. Practical Examples in the Script"},{"location":"insight/adsk/python_utilities/examples/insight-show_messages/#the-countdown","text":"The countdown function shows how you can update the console in real-time. It uses time.sleep(1) to wait one second between numbers.","title":"The Countdown"},{"location":"insight/adsk/python_utilities/examples/insight-show_messages/#the-disk-space-checker","text":"The freespace function uses a standard Python tool ( shutil ) to check your hard drive. - If you have plenty of space, it shows an Info message (usually green/white). - If space is low, it shows a Warning message (usually yellow/orange).","title":"The Disk Space Checker"},{"location":"insight/adsk/python_utilities/examples/insight-show_messages/#the-error-catcher","text":"The set_batch_duration function tries to set the length of a Batch group. If it fails (because there's no clip), it uses a Dialog Box to explain exactly what went wrong.","title":"The Error Catcher"},{"location":"insight/adsk/python_utilities/examples/insight-show_messages/#3-key-takeaway-for-beginners","text":"Use the Console for \"FYI\" messages (Status updates, progress). Use Dialogs for \"STOP\" messages (Errors, confirmations, questions). Always try to give the user helpful information. A script that fails silently is frustrating; a script that says \"No Clip Found\" is helpful!","title":"3. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-version_scoping_hooks/","text":"Insight: Managing Version Compatibility This document explains the version_scoping_hooks.py example script. It shows how to ensure your Python tools only appear in versions of Flame where they actually work. Target Audience: Novice Python programmers sharing scripts with a team. 1. The Version Headache Sometimes, Autodesk adds a new feature to Flame 2026 that didn't exist in 2024. If you write a script using that new feature and give it to a friend using the older version, the script might crash or cause errors. The Solution: Version Scoping. You can tell Flame: \"Only show this menu item if the software version is between X and Y.\" 2. Two Ways to Set Limits The script shows two different places where you can set version limits: A. Inside the Menu Dictionary ( minimumVersion ) This is the most common way. You add it directly to the button definition. { \"name\": \"Super New Tool\", \"execute\": my_function, \"minimumVersion\": \"2026.1\" # Only shows up in 2026.1 or newer } B. On the Function Itself ( minimum_version ) This is a more \"global\" way to block an entire set of tools. You set it after the function is defined: def get_batch_custom_ui_actions(): ... get_batch_custom_ui_actions.minimum_version = \"2023.0\" 3. How Version Numbers Work Flame version numbers follow a specific pattern: Year.Minor.Patch - 2026 : Works for any version of 2026. - 2026.1 : Only works for 2026 Update 1 or newer. - 2026.1.2 : Only works for a very specific bug-fix release. 4. Why is this useful? Prevent Crashes: You don't have to worry about old versions of Flame trying to run code they don't understand. Easy Maintenance: You can keep one \"Super Script\" that has different buttons for different versions of the software. Professionalism: Your tools feel reliable and well-tested across the whole studio. 5. Key Takeaway for Beginners Think of Version Scoping as a \"System Requirement\" for your script. By setting these limits, you are protecting your users from seeing tools that won't work on their specific version of Flame.","title":"Insight: Managing Version Compatibility"},{"location":"insight/adsk/python_utilities/examples/insight-version_scoping_hooks/#insight-managing-version-compatibility","text":"This document explains the version_scoping_hooks.py example script. It shows how to ensure your Python tools only appear in versions of Flame where they actually work. Target Audience: Novice Python programmers sharing scripts with a team.","title":"Insight: Managing Version Compatibility"},{"location":"insight/adsk/python_utilities/examples/insight-version_scoping_hooks/#1-the-version-headache","text":"Sometimes, Autodesk adds a new feature to Flame 2026 that didn't exist in 2024. If you write a script using that new feature and give it to a friend using the older version, the script might crash or cause errors. The Solution: Version Scoping. You can tell Flame: \"Only show this menu item if the software version is between X and Y.\"","title":"1. The Version Headache"},{"location":"insight/adsk/python_utilities/examples/insight-version_scoping_hooks/#2-two-ways-to-set-limits","text":"The script shows two different places where you can set version limits:","title":"2. Two Ways to Set Limits"},{"location":"insight/adsk/python_utilities/examples/insight-version_scoping_hooks/#a-inside-the-menu-dictionary-minimumversion","text":"This is the most common way. You add it directly to the button definition. { \"name\": \"Super New Tool\", \"execute\": my_function, \"minimumVersion\": \"2026.1\" # Only shows up in 2026.1 or newer }","title":"A. Inside the Menu Dictionary (minimumVersion)"},{"location":"insight/adsk/python_utilities/examples/insight-version_scoping_hooks/#b-on-the-function-itself-minimum_version","text":"This is a more \"global\" way to block an entire set of tools. You set it after the function is defined: def get_batch_custom_ui_actions(): ... get_batch_custom_ui_actions.minimum_version = \"2023.0\"","title":"B. On the Function Itself (minimum_version)"},{"location":"insight/adsk/python_utilities/examples/insight-version_scoping_hooks/#3-how-version-numbers-work","text":"Flame version numbers follow a specific pattern: Year.Minor.Patch - 2026 : Works for any version of 2026. - 2026.1 : Only works for 2026 Update 1 or newer. - 2026.1.2 : Only works for a very specific bug-fix release.","title":"3. How Version Numbers Work"},{"location":"insight/adsk/python_utilities/examples/insight-version_scoping_hooks/#4-why-is-this-useful","text":"Prevent Crashes: You don't have to worry about old versions of Flame trying to run code they don't understand. Easy Maintenance: You can keep one \"Super Script\" that has different buttons for different versions of the software. Professionalism: Your tools feel reliable and well-tested across the whole studio.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/examples/insight-version_scoping_hooks/#5-key-takeaway-for-beginners","text":"Think of Version Scoping as a \"System Requirement\" for your script. By setting these limits, you are protecting your users from seeing tools that won't work on their specific version of Flame.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-wait_cursor/","text":"Insight: Managing the Wait Cursor This document explains the wait_cursor.py example script. It shows how to control that spinning \"loading\" icon so your users don't get frustrated when using your tools. Target Audience: Novice Python programmers interested in User Experience (UX). 1. What is the Wait Cursor? In Flame, when a script is running, the mouse cursor usually turns into a \"Wait\" icon (a spinning circle or watch). This tells the user: \"The computer is busy, please don't click anything.\" 2. When to Hide It Sometimes, you want the user to click something while your script is running! - Example: You pop up a window asking the user to \"Select a Folder.\" - The Problem: If the cursor is stuck in \"Wait\" mode, the user can't interact with your pop-up window properly. 3. How to Control It In your menu definition, you can use the waitCursor key: A. For Long Tasks ( waitCursor: True ) If your script is doing a lot of math or moving files, keep the wait cursor on. { \"name\": \"Process 1000 Clips\", \"execute\": my_long_function, \"waitCursor\": True # This is the default } B. For Interactive Tasks ( waitCursor: False ) If your script shows a window or asks a question, turn the wait cursor off so the mouse works normally. { \"name\": \"Show My Custom Window\", \"execute\": show_window_function, \"waitCursor\": False # Gives control back to the user } 4. Why is this useful? Reduced Frustration: There is nothing worse than a pop-up window you can't click because your mouse is \"stuck\" in a loading state. Clarity: It tells the user exactly when it's safe to interact with Flame and when they should wait. 5. Key Takeaway for Beginners If your script opens a window (using PySide6 or flame.messages.show_in_dialog ), you should almost always set \"waitCursor\": False . If your script runs in the background with no windows, keep it True .","title":"Insight: Managing the Wait Cursor"},{"location":"insight/adsk/python_utilities/examples/insight-wait_cursor/#insight-managing-the-wait-cursor","text":"This document explains the wait_cursor.py example script. It shows how to control that spinning \"loading\" icon so your users don't get frustrated when using your tools. Target Audience: Novice Python programmers interested in User Experience (UX).","title":"Insight: Managing the Wait Cursor"},{"location":"insight/adsk/python_utilities/examples/insight-wait_cursor/#1-what-is-the-wait-cursor","text":"In Flame, when a script is running, the mouse cursor usually turns into a \"Wait\" icon (a spinning circle or watch). This tells the user: \"The computer is busy, please don't click anything.\"","title":"1. What is the Wait Cursor?"},{"location":"insight/adsk/python_utilities/examples/insight-wait_cursor/#2-when-to-hide-it","text":"Sometimes, you want the user to click something while your script is running! - Example: You pop up a window asking the user to \"Select a Folder.\" - The Problem: If the cursor is stuck in \"Wait\" mode, the user can't interact with your pop-up window properly.","title":"2. When to Hide It"},{"location":"insight/adsk/python_utilities/examples/insight-wait_cursor/#3-how-to-control-it","text":"In your menu definition, you can use the waitCursor key:","title":"3. How to Control It"},{"location":"insight/adsk/python_utilities/examples/insight-wait_cursor/#a-for-long-tasks-waitcursor-true","text":"If your script is doing a lot of math or moving files, keep the wait cursor on. { \"name\": \"Process 1000 Clips\", \"execute\": my_long_function, \"waitCursor\": True # This is the default }","title":"A. For Long Tasks (waitCursor: True)"},{"location":"insight/adsk/python_utilities/examples/insight-wait_cursor/#b-for-interactive-tasks-waitcursor-false","text":"If your script shows a window or asks a question, turn the wait cursor off so the mouse works normally. { \"name\": \"Show My Custom Window\", \"execute\": show_window_function, \"waitCursor\": False # Gives control back to the user }","title":"B. For Interactive Tasks (waitCursor: False)"},{"location":"insight/adsk/python_utilities/examples/insight-wait_cursor/#4-why-is-this-useful","text":"Reduced Frustration: There is nothing worse than a pop-up window you can't click because your mouse is \"stuck\" in a loading state. Clarity: It tells the user exactly when it's safe to interact with Flame and when they should wait.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/examples/insight-wait_cursor/#5-key-takeaway-for-beginners","text":"If your script opens a window (using PySide6 or flame.messages.show_in_dialog ), you should almost always set \"waitCursor\": False . If your script runs in the background with no windows, keep it True .","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/examples/insight-watch_folder/","text":"Insight: Creating a \"Watch Folder\" in Flame This document explains the watch_folder.py example script. It shows how to make Flame perform background tasks without freezing the user interface. Target Audience: Novice Python programmers interested in automation and \"Background Tasks.\" 1. What is a \"Watch Folder\"? A Watch Folder is a folder on your computer that a script monitors. Whenever you drop a file into that folder, the script automatically \"wakes up\" and imports that file into Flame. 2. The Secret: schedule_idle_event If you write a simple Python script that says while True: look_for_files() , Flame will freeze . This is because Python is taking up 100% of Flame's attention. The Solution: Use Flame's \"Idle\" loop. Flame has a special feature called schedule_idle_event . It tells Flame: \"Hey, next time the artist is NOT clicking anything, run this function for a split second.\" 3. How the Script Works Start on Startup: The script uses the app_initialized hook to start looking for files as soon as Flame opens. The Check: It looks inside /var/tmp/watch_folder . The Import: If it finds a new file, it imports it into a library named \"Watch Folder.\" The Relay Race: After importing one file, the script doesn't just keep going. It says: \"I'm done for now. Flame, please call me again in 1 second.\" python flame.schedule_idle_event(do_watch_folder, delay=1) 4. Why is this powerful? Zero Lag: Because the script only runs during \"Idle\" time, the artist can keep working, editing, and color grading without noticing the script is running. Workflow Speed: You can have an external assistant or another software (like a 3D renderer) drop files into the folder, and they magically appear in Flame without any manual work. 5. Key Takeaway for Beginners In Flame, never use long while loops . Instead, use schedule_idle_event to break your big task into tiny pieces that run only when Flame isn't busy. This keeps the software responsive and your workflow smooth!","title":"Insight: Creating a \"Watch Folder\" in Flame"},{"location":"insight/adsk/python_utilities/examples/insight-watch_folder/#insight-creating-a-watch-folder-in-flame","text":"This document explains the watch_folder.py example script. It shows how to make Flame perform background tasks without freezing the user interface. Target Audience: Novice Python programmers interested in automation and \"Background Tasks.\"","title":"Insight: Creating a \"Watch Folder\" in Flame"},{"location":"insight/adsk/python_utilities/examples/insight-watch_folder/#1-what-is-a-watch-folder","text":"A Watch Folder is a folder on your computer that a script monitors. Whenever you drop a file into that folder, the script automatically \"wakes up\" and imports that file into Flame.","title":"1. What is a \"Watch Folder\"?"},{"location":"insight/adsk/python_utilities/examples/insight-watch_folder/#2-the-secret-schedule_idle_event","text":"If you write a simple Python script that says while True: look_for_files() , Flame will freeze . This is because Python is taking up 100% of Flame's attention. The Solution: Use Flame's \"Idle\" loop. Flame has a special feature called schedule_idle_event . It tells Flame: \"Hey, next time the artist is NOT clicking anything, run this function for a split second.\"","title":"2. The Secret: schedule_idle_event"},{"location":"insight/adsk/python_utilities/examples/insight-watch_folder/#3-how-the-script-works","text":"Start on Startup: The script uses the app_initialized hook to start looking for files as soon as Flame opens. The Check: It looks inside /var/tmp/watch_folder . The Import: If it finds a new file, it imports it into a library named \"Watch Folder.\" The Relay Race: After importing one file, the script doesn't just keep going. It says: \"I'm done for now. Flame, please call me again in 1 second.\" python flame.schedule_idle_event(do_watch_folder, delay=1)","title":"3. How the Script Works"},{"location":"insight/adsk/python_utilities/examples/insight-watch_folder/#4-why-is-this-powerful","text":"Zero Lag: Because the script only runs during \"Idle\" time, the artist can keep working, editing, and color grading without noticing the script is running. Workflow Speed: You can have an external assistant or another software (like a 3D renderer) drop files into the folder, and they magically appear in Flame without any manual work.","title":"4. Why is this powerful?"},{"location":"insight/adsk/python_utilities/examples/insight-watch_folder/#5-key-takeaway-for-beginners","text":"In Flame, never use long while loops . Instead, use schedule_idle_event to break your big task into tiny pieces that run only when Flame isn't busy. This keeps the software responsive and your workflow smooth!","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/scripts/insight-batch_write_file_quicktime/","text":"Insight: Automating QuickTime Transcoding from Batch This document explains the batch_write_file_quicktime.py script. It shows how to automatically create a QuickTime movie whenever a \"Write File\" node finishes rendering in Batch. Target Audience: Novice Python programmers interested in render automation. 1. What is the Goal? In Flame's Batch environment, a Write File node is often used to export image sequences (like OpenEXR). However, after the render is done, you might also need a QuickTime file for review. This script automates that second step. As soon as the Write File node finishes its work, this script picks up the images and converts them into a QuickTime movie. 2. Key Concepts A. The batch_export_end Hook This is the \"trigger.\" Flame runs this function automatically when a Batch export completes. It provides an info dictionary containing the path to the newly rendered files. B. Dynamic Preset Paths The script uses flame.PyExporter.get_presets_dir() . This is better than hardcoding a path because it asks Flame: \"Where do you keep your official Autodesk QuickTime presets?\" This makes the script work on any computer, regardless of where Flame is installed. 3. How the Script Works Find the Media: It uses os.path.join to combine the export folder and the filename into one full path. Import: It tells Flame to \"look\" at those new files using flame.import_clips(full_path) . Setup the Exporter: It creates an instance of flame.PyExporter . It sets exporter.foreground = True . This means Flame will focus entirely on making the QuickTime until it is finished. Export: It runs the export() command using the official \"8-bit Uncompressed\" preset. 4. Why is this useful? Saves Time: You don't have to manually create a new export job after every render. Consistency: Every render automatically gets a matching QuickTime file in the same folder. Simplicity: For the artist, they just hit \"Render\" in Batch, and both the image sequence and the movie appear. 5. Key Takeaway for Beginners This script is a perfect example of a \"Post-Process.\" By using the information provided by a hook ( info[\"exportPath\"] ), you can chain multiple Flame operations together into a single automated workflow.","title":"Insight: Automating QuickTime Transcoding from Batch"},{"location":"insight/adsk/python_utilities/scripts/insight-batch_write_file_quicktime/#insight-automating-quicktime-transcoding-from-batch","text":"This document explains the batch_write_file_quicktime.py script. It shows how to automatically create a QuickTime movie whenever a \"Write File\" node finishes rendering in Batch. Target Audience: Novice Python programmers interested in render automation.","title":"Insight: Automating QuickTime Transcoding from Batch"},{"location":"insight/adsk/python_utilities/scripts/insight-batch_write_file_quicktime/#1-what-is-the-goal","text":"In Flame's Batch environment, a Write File node is often used to export image sequences (like OpenEXR). However, after the render is done, you might also need a QuickTime file for review. This script automates that second step. As soon as the Write File node finishes its work, this script picks up the images and converts them into a QuickTime movie.","title":"1. What is the Goal?"},{"location":"insight/adsk/python_utilities/scripts/insight-batch_write_file_quicktime/#2-key-concepts","text":"","title":"2. Key Concepts"},{"location":"insight/adsk/python_utilities/scripts/insight-batch_write_file_quicktime/#a-the-batch_export_end-hook","text":"This is the \"trigger.\" Flame runs this function automatically when a Batch export completes. It provides an info dictionary containing the path to the newly rendered files.","title":"A. The batch_export_end Hook"},{"location":"insight/adsk/python_utilities/scripts/insight-batch_write_file_quicktime/#b-dynamic-preset-paths","text":"The script uses flame.PyExporter.get_presets_dir() . This is better than hardcoding a path because it asks Flame: \"Where do you keep your official Autodesk QuickTime presets?\" This makes the script work on any computer, regardless of where Flame is installed.","title":"B. Dynamic Preset Paths"},{"location":"insight/adsk/python_utilities/scripts/insight-batch_write_file_quicktime/#3-how-the-script-works","text":"Find the Media: It uses os.path.join to combine the export folder and the filename into one full path. Import: It tells Flame to \"look\" at those new files using flame.import_clips(full_path) . Setup the Exporter: It creates an instance of flame.PyExporter . It sets exporter.foreground = True . This means Flame will focus entirely on making the QuickTime until it is finished. Export: It runs the export() command using the official \"8-bit Uncompressed\" preset.","title":"3. How the Script Works"},{"location":"insight/adsk/python_utilities/scripts/insight-batch_write_file_quicktime/#4-why-is-this-useful","text":"Saves Time: You don't have to manually create a new export job after every render. Consistency: Every render automatically gets a matching QuickTime file in the same folder. Simplicity: For the artist, they just hit \"Render\" in Batch, and both the image sequence and the movie appear.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/scripts/insight-batch_write_file_quicktime/#5-key-takeaway-for-beginners","text":"This script is a perfect example of a \"Post-Process.\" By using the information provided by a hook ( info[\"exportPath\"] ), you can chain multiple Flame operations together into a single automated workflow.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/scripts/insight-cache_motion_vectors/","text":"Insight: Automating Motion Vector Caching This document explains the cache_motion_vectors.py script. It shows how to programmatically build a \"Node Tree\" in Batch to calculate and save motion vectors. Target Audience: Novice Python programmers learning how to manipulate the Batch Schematic. 1. What are Motion Vectors? Motion vectors are data that describe how pixels move from one frame to the next. In Flame, calculating this can be slow, so we often \"Cache\" (save) the results. The Goal: Instead of manually adding an \"Action\" node, adding a \"Motion Vectors Map,\" and clicking \"Cache,\" this script does it all in one click. 2. Key Concepts A. Node Creation & Positioning The script uses flame.batch.create_node(\"Action\") . - Coordinates: It uses pos_x and pos_y to place the nodes neatly in the schematic. It adds 400 to the X-position so the new node doesn't overlap the old one. B. Connecting Nodes To make the nodes work, they must be \"wired\" together. flame.batch.connect_nodes(clip, \"Default\", media, \"Default\") This is like dragging a line between two dots in the Batch interface. C. Caching a Range The script finds the start and end frame of the clip and tells the node to render exactly that range: motion_map.cache_range(start, end) 3. Two Ways to Use the Script In Batch: Right-click a clip node and select \"Cache Motion Vectors Map.\" From the Desktop: Right-click your Desktop and select \"Create Batch and Cache...\". This version is even more powerful! It opens a file browser, lets you pick a clip, creates a brand new Batch Group , imports the clip, and then sets up the motion vectors. 4. Why is this useful? Standardization: It ensures that every Motion Vector Map is set up exactly the same way every time. Speed: It handles all the tedious clicking and dragging of nodes automatically. Batch Processing: You can use the \"Desktop\" version to process a file without even having a Batch group open yet. 5. Key Takeaway for Beginners When you use the Python API, you are basically a \"Ghost Operator.\" Anything a human can do with a mouse (creating nodes, connecting them, clicking 'Cache'), you can do with code by calling the right functions.","title":"Insight: Automating Motion Vector Caching"},{"location":"insight/adsk/python_utilities/scripts/insight-cache_motion_vectors/#insight-automating-motion-vector-caching","text":"This document explains the cache_motion_vectors.py script. It shows how to programmatically build a \"Node Tree\" in Batch to calculate and save motion vectors. Target Audience: Novice Python programmers learning how to manipulate the Batch Schematic.","title":"Insight: Automating Motion Vector Caching"},{"location":"insight/adsk/python_utilities/scripts/insight-cache_motion_vectors/#1-what-are-motion-vectors","text":"Motion vectors are data that describe how pixels move from one frame to the next. In Flame, calculating this can be slow, so we often \"Cache\" (save) the results. The Goal: Instead of manually adding an \"Action\" node, adding a \"Motion Vectors Map,\" and clicking \"Cache,\" this script does it all in one click.","title":"1. What are Motion Vectors?"},{"location":"insight/adsk/python_utilities/scripts/insight-cache_motion_vectors/#2-key-concepts","text":"","title":"2. Key Concepts"},{"location":"insight/adsk/python_utilities/scripts/insight-cache_motion_vectors/#a-node-creation-positioning","text":"The script uses flame.batch.create_node(\"Action\") . - Coordinates: It uses pos_x and pos_y to place the nodes neatly in the schematic. It adds 400 to the X-position so the new node doesn't overlap the old one.","title":"A. Node Creation &amp; Positioning"},{"location":"insight/adsk/python_utilities/scripts/insight-cache_motion_vectors/#b-connecting-nodes","text":"To make the nodes work, they must be \"wired\" together. flame.batch.connect_nodes(clip, \"Default\", media, \"Default\") This is like dragging a line between two dots in the Batch interface.","title":"B. Connecting Nodes"},{"location":"insight/adsk/python_utilities/scripts/insight-cache_motion_vectors/#c-caching-a-range","text":"The script finds the start and end frame of the clip and tells the node to render exactly that range: motion_map.cache_range(start, end)","title":"C. Caching a Range"},{"location":"insight/adsk/python_utilities/scripts/insight-cache_motion_vectors/#3-two-ways-to-use-the-script","text":"In Batch: Right-click a clip node and select \"Cache Motion Vectors Map.\" From the Desktop: Right-click your Desktop and select \"Create Batch and Cache...\". This version is even more powerful! It opens a file browser, lets you pick a clip, creates a brand new Batch Group , imports the clip, and then sets up the motion vectors.","title":"3. Two Ways to Use the Script"},{"location":"insight/adsk/python_utilities/scripts/insight-cache_motion_vectors/#4-why-is-this-useful","text":"Standardization: It ensures that every Motion Vector Map is set up exactly the same way every time. Speed: It handles all the tedious clicking and dragging of nodes automatically. Batch Processing: You can use the \"Desktop\" version to process a file without even having a Batch group open yet.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/scripts/insight-cache_motion_vectors/#5-key-takeaway-for-beginners","text":"When you use the Python API, you are basically a \"Ghost Operator.\" Anything a human can do with a mouse (creating nodes, connecting them, clicking 'Cache'), you can do with code by calling the right functions.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/scripts/insight-clean_batch_iteration/","text":"Insight: Deep-Cleaning Project Iterations This document explains the clean_batch_iteration.py script. It shows how to save disk space by deleting old \"Iterations\" (saved versions) of your Batch work. Target Audience: Novice Python programmers interested in project maintenance and \"Recursion.\" 1. What are Batch Iterations? Every time you save your work in Batch, Flame creates an \"Iteration.\" Over a long project, these can add up to hundreds of files, taking up a lot of space on your storage. The Goal: A \"Nuclear Option\" to delete all iterations from a specific Folder, Library, or even your entire Desktop. 2. Key Concept: Recursion This script uses a very important programming technique called Recursion . Imagine a Library contains a Folder, which contains another Folder, which finally contains a Batch Group. To find that Batch Group, the script has to \"dig\" through the folders. The find_batch_group function does this: 1. It looks for Batch Groups in the current folder and cleans them. 2. It then looks for more folders inside the current one. 3. If it finds a folder, it calls itself to look inside that new folder. def find_batch_group(folder): # ... clean things here ... for folders in folder.folders: find_batch_group(folders) # Calling itself! 3. How the Script Works Multiple Scopes: The script is smart. It checks if you clicked on a Library, a Folder, or a Batch Group and uses the correct logic for each one. Silent Delete: It uses flame.delete(iteration, confirm=False) . Warning: Setting confirm=False means Flame won't ask \"Are you sure?\" It just deletes them instantly. This is fast, but dangerous! 4. Why is this useful? Storage Management: It's the fastest way to \"slim down\" a project before archiving it. Organization: It removes the clutter of old, failed experiments and keeps only the current work. Workflow Speed: Instead of opening 50 Batch Groups and deleting iterations manually, you click one button on the top-level Library. 5. Key Takeaway for Beginners Recursion is the best way to deal with \"Tree\" structures (like folders inside folders). Instead of writing complex logic to guess how deep the folders go, you just tell the function to keep digging until it hits the bottom.","title":"Insight: Deep-Cleaning Project Iterations"},{"location":"insight/adsk/python_utilities/scripts/insight-clean_batch_iteration/#insight-deep-cleaning-project-iterations","text":"This document explains the clean_batch_iteration.py script. It shows how to save disk space by deleting old \"Iterations\" (saved versions) of your Batch work. Target Audience: Novice Python programmers interested in project maintenance and \"Recursion.\"","title":"Insight: Deep-Cleaning Project Iterations"},{"location":"insight/adsk/python_utilities/scripts/insight-clean_batch_iteration/#1-what-are-batch-iterations","text":"Every time you save your work in Batch, Flame creates an \"Iteration.\" Over a long project, these can add up to hundreds of files, taking up a lot of space on your storage. The Goal: A \"Nuclear Option\" to delete all iterations from a specific Folder, Library, or even your entire Desktop.","title":"1. What are Batch Iterations?"},{"location":"insight/adsk/python_utilities/scripts/insight-clean_batch_iteration/#2-key-concept-recursion","text":"This script uses a very important programming technique called Recursion . Imagine a Library contains a Folder, which contains another Folder, which finally contains a Batch Group. To find that Batch Group, the script has to \"dig\" through the folders. The find_batch_group function does this: 1. It looks for Batch Groups in the current folder and cleans them. 2. It then looks for more folders inside the current one. 3. If it finds a folder, it calls itself to look inside that new folder. def find_batch_group(folder): # ... clean things here ... for folders in folder.folders: find_batch_group(folders) # Calling itself!","title":"2. Key Concept: Recursion"},{"location":"insight/adsk/python_utilities/scripts/insight-clean_batch_iteration/#3-how-the-script-works","text":"Multiple Scopes: The script is smart. It checks if you clicked on a Library, a Folder, or a Batch Group and uses the correct logic for each one. Silent Delete: It uses flame.delete(iteration, confirm=False) . Warning: Setting confirm=False means Flame won't ask \"Are you sure?\" It just deletes them instantly. This is fast, but dangerous!","title":"3. How the Script Works"},{"location":"insight/adsk/python_utilities/scripts/insight-clean_batch_iteration/#4-why-is-this-useful","text":"Storage Management: It's the fastest way to \"slim down\" a project before archiving it. Organization: It removes the clutter of old, failed experiments and keeps only the current work. Workflow Speed: Instead of opening 50 Batch Groups and deleting iterations manually, you click one button on the top-level Library.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/scripts/insight-clean_batch_iteration/#5-key-takeaway-for-beginners","text":"Recursion is the best way to deal with \"Tree\" structures (like folders inside folders). Instead of writing complex logic to guess how deep the folders go, you just tell the function to keep digging until it hits the bottom.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/scripts/insight-create_user_shared_library/","text":"Insight: Personalized Shared Libraries This document explains the create_user_shared_library.py script. It shows how to use the current user's name to automatically organize a project. Target Audience: Novice Python programmers interested in project management and user data. 1. What is the Goal? In a facility where many artists work on the same project, it's good practice for each artist to have their own Shared Library . This prevents people from accidentally overwriting each other's work. The Goal: Instead of manually creating a library and typing your name, this script finds out who is currently logged into Flame and builds a library for them automatically. 2. Key Concepts A. Fetching the Current User Flame always knows who is using it. You can access this information through: user_name = flame.users.current_user.name This returns a simple string, like \"JohnDoe\" . B. Creating a Shared Library A Shared Library is special because other people on the network can see it. flame.projects.current_project.create_shared_library(user_name) 3. Why is this useful? Zero Typos: The library name always matches the Flame user profile exactly. Speed: One click and your workspace is set up. Teamwork: It encourages everyone to use shared storage correctly from the start. 4. Key Takeaway for Beginners The flame module isn't just for clips and nodes; it also holds information about the Environment . By combining \"Environment Data\" (the User Name) with \"Project Actions\" (Creating a Library), you can build tools that feel personalized and intelligent.","title":"Insight: Personalized Shared Libraries"},{"location":"insight/adsk/python_utilities/scripts/insight-create_user_shared_library/#insight-personalized-shared-libraries","text":"This document explains the create_user_shared_library.py script. It shows how to use the current user's name to automatically organize a project. Target Audience: Novice Python programmers interested in project management and user data.","title":"Insight: Personalized Shared Libraries"},{"location":"insight/adsk/python_utilities/scripts/insight-create_user_shared_library/#1-what-is-the-goal","text":"In a facility where many artists work on the same project, it's good practice for each artist to have their own Shared Library . This prevents people from accidentally overwriting each other's work. The Goal: Instead of manually creating a library and typing your name, this script finds out who is currently logged into Flame and builds a library for them automatically.","title":"1. What is the Goal?"},{"location":"insight/adsk/python_utilities/scripts/insight-create_user_shared_library/#2-key-concepts","text":"","title":"2. Key Concepts"},{"location":"insight/adsk/python_utilities/scripts/insight-create_user_shared_library/#a-fetching-the-current-user","text":"Flame always knows who is using it. You can access this information through: user_name = flame.users.current_user.name This returns a simple string, like \"JohnDoe\" .","title":"A. Fetching the Current User"},{"location":"insight/adsk/python_utilities/scripts/insight-create_user_shared_library/#b-creating-a-shared-library","text":"A Shared Library is special because other people on the network can see it. flame.projects.current_project.create_shared_library(user_name)","title":"B. Creating a Shared Library"},{"location":"insight/adsk/python_utilities/scripts/insight-create_user_shared_library/#3-why-is-this-useful","text":"Zero Typos: The library name always matches the Flame user profile exactly. Speed: One click and your workspace is set up. Teamwork: It encourages everyone to use shared storage correctly from the start.","title":"3. Why is this useful?"},{"location":"insight/adsk/python_utilities/scripts/insight-create_user_shared_library/#4-key-takeaway-for-beginners","text":"The flame module isn't just for clips and nodes; it also holds information about the Environment . By combining \"Environment Data\" (the User Name) with \"Project Actions\" (Creating a Library), you can build tools that feel personalized and intelligent.","title":"4. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/scripts/insight-export_current_frame/","text":"Insight: Exporting the \"Current Frame\" This document explains the export_current_frame.py script. It shows how to grab exactly what you are looking at in the player and save it as a high-quality Jpeg. Target Audience: Novice Python programmers learning about non-destructive editing. 1. The Challenge: Single Frame Export Flame's exporter usually wants to export a whole clip. If you only want the frame your playhead is on, you have to be clever. The Strategy: 1. Find the current time. 2. Duplicate the clip (so we don't ruin the original). 3. Set the In/Out points of the duplicate to that single frame. 4. Export and then Delete the duplicate. 2. Key Concepts A. Clip Duplication duplicate_clip = flame.duplicate(clip) Why do this? If you change the In/Out marks on the original clip, the artist will lose their edit! Duplicating creates a \"disposable\" copy that we can change safely. B. Mark Manipulation duplicate_clip.in_mark = clip.current_time.get_value() duplicate_clip.out_mark = clip.current_time.get_value() + 1 This tells the duplicate clip: \"Your start is the current frame, and your end is one frame later.\" C. The try...finally Block This is a \"Safety Net.\" try: # Do the export... finally: flame.delete(duplicate_clip) The finally part runs no matter what \u2014even if the export crashes. This ensures that Flame's memory doesn't get cluttered with thousands of hidden duplicate clips. 3. Finding the Save Location The script uses a neat trick to find where to save the file. It tries to use the path you currently have open in the MediaHub . This is very intuitive for the user! 4. Key Takeaway for Beginners Always be Non-Destructive . If your script needs to change a clip's settings just for a moment, consider creating a duplicate, doing the work, and then cleaning up after yourself.","title":"Insight: Exporting the \"Current Frame\""},{"location":"insight/adsk/python_utilities/scripts/insight-export_current_frame/#insight-exporting-the-current-frame","text":"This document explains the export_current_frame.py script. It shows how to grab exactly what you are looking at in the player and save it as a high-quality Jpeg. Target Audience: Novice Python programmers learning about non-destructive editing.","title":"Insight: Exporting the \"Current Frame\""},{"location":"insight/adsk/python_utilities/scripts/insight-export_current_frame/#1-the-challenge-single-frame-export","text":"Flame's exporter usually wants to export a whole clip. If you only want the frame your playhead is on, you have to be clever. The Strategy: 1. Find the current time. 2. Duplicate the clip (so we don't ruin the original). 3. Set the In/Out points of the duplicate to that single frame. 4. Export and then Delete the duplicate.","title":"1. The Challenge: Single Frame Export"},{"location":"insight/adsk/python_utilities/scripts/insight-export_current_frame/#2-key-concepts","text":"","title":"2. Key Concepts"},{"location":"insight/adsk/python_utilities/scripts/insight-export_current_frame/#a-clip-duplication","text":"duplicate_clip = flame.duplicate(clip) Why do this? If you change the In/Out marks on the original clip, the artist will lose their edit! Duplicating creates a \"disposable\" copy that we can change safely.","title":"A. Clip Duplication"},{"location":"insight/adsk/python_utilities/scripts/insight-export_current_frame/#b-mark-manipulation","text":"duplicate_clip.in_mark = clip.current_time.get_value() duplicate_clip.out_mark = clip.current_time.get_value() + 1 This tells the duplicate clip: \"Your start is the current frame, and your end is one frame later.\"","title":"B. Mark Manipulation"},{"location":"insight/adsk/python_utilities/scripts/insight-export_current_frame/#c-the-tryfinally-block","text":"This is a \"Safety Net.\" try: # Do the export... finally: flame.delete(duplicate_clip) The finally part runs no matter what \u2014even if the export crashes. This ensures that Flame's memory doesn't get cluttered with thousands of hidden duplicate clips.","title":"C. The try...finally Block"},{"location":"insight/adsk/python_utilities/scripts/insight-export_current_frame/#3-finding-the-save-location","text":"The script uses a neat trick to find where to save the file. It tries to use the path you currently have open in the MediaHub . This is very intuitive for the user!","title":"3. Finding the Save Location"},{"location":"insight/adsk/python_utilities/scripts/insight-export_current_frame/#4-key-takeaway-for-beginners","text":"Always be Non-Destructive . If your script needs to change a clip's settings just for a moment, consider creating a duplicate, doing the work, and then cleaning up after yourself.","title":"4. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/scripts/insight-export_selection/","text":"Insight: Bulk Export & FFmpeg Integration This document explains the export_selection.py script. This is a \"Power User\" script that handles everything from exporting thumbnails to talking to external software like FFmpeg . Target Audience: Intermediate Python programmers interested in external integrations. 1. What does it do? This script provides several professional export options for your selection: 1. Thumbnail + Movie: Saves a Jpeg of the first frame AND a QuickTime file. 2. Recursive Export: If you select a folder, it digs through and exports everything inside it, keeping your folder structure organized. 3. FFmpeg Export: This is the most advanced part. It bypasses Flame's built-in exporter and uses a third-party tool (FFmpeg) to create movies. 2. Key Concepts: The FFmpeg Bridge How does Flame talk to FFmpeg? It's a three-step dance: Step 1: Named Pipes ( os.mkfifo ) The script creates a \"Pipe\"\u2014a virtual file that exists only in the computer's memory. It uses this to stream audio data from Flame directly into FFmpeg. Step 2: read_frame and read_audio Autodesk provides \"Command Line\" versions of Flame's engine called read_frame and read_audio . The script runs these in the background to pull raw data out of Flame's database. Step 3: Subprocess Piping The script \"pipes\" the video from read_frame into FFmpeg's input. ffmpeg_process = subprocess.Popen(..., stdin=read_frame_process.stdout) This is like connecting a fire hose from one machine (Flame) to another (FFmpeg). 3. Foreground vs. Background Foreground: Your mouse turns into a wait cursor, and you wait for FFmpeg to finish. Background: The script creates a Backburner job. It actually writes a tiny Python script on the fly and tells Backburner to run it on a render node! 4. Why is this useful? Custom Formats: Flame's built-in exporter is great, but FFmpeg can do anything (like making tiny H.264 files for WhatsApp or adding custom text overlays). Efficiency: You can offload heavy transcoding to other computers on your network. 5. Key Takeaway for Beginners Flame is an \"Open\" system. You aren't limited to the buttons inside the software. By using subprocess and external tools, you can bridge Flame to any other software on your computer.","title":"Insight: Bulk Export &amp; FFmpeg Integration"},{"location":"insight/adsk/python_utilities/scripts/insight-export_selection/#insight-bulk-export-ffmpeg-integration","text":"This document explains the export_selection.py script. This is a \"Power User\" script that handles everything from exporting thumbnails to talking to external software like FFmpeg . Target Audience: Intermediate Python programmers interested in external integrations.","title":"Insight: Bulk Export &amp; FFmpeg Integration"},{"location":"insight/adsk/python_utilities/scripts/insight-export_selection/#1-what-does-it-do","text":"This script provides several professional export options for your selection: 1. Thumbnail + Movie: Saves a Jpeg of the first frame AND a QuickTime file. 2. Recursive Export: If you select a folder, it digs through and exports everything inside it, keeping your folder structure organized. 3. FFmpeg Export: This is the most advanced part. It bypasses Flame's built-in exporter and uses a third-party tool (FFmpeg) to create movies.","title":"1. What does it do?"},{"location":"insight/adsk/python_utilities/scripts/insight-export_selection/#2-key-concepts-the-ffmpeg-bridge","text":"How does Flame talk to FFmpeg? It's a three-step dance:","title":"2. Key Concepts: The FFmpeg Bridge"},{"location":"insight/adsk/python_utilities/scripts/insight-export_selection/#step-1-named-pipes-osmkfifo","text":"The script creates a \"Pipe\"\u2014a virtual file that exists only in the computer's memory. It uses this to stream audio data from Flame directly into FFmpeg.","title":"Step 1: Named Pipes (os.mkfifo)"},{"location":"insight/adsk/python_utilities/scripts/insight-export_selection/#step-2-read_frame-and-read_audio","text":"Autodesk provides \"Command Line\" versions of Flame's engine called read_frame and read_audio . The script runs these in the background to pull raw data out of Flame's database.","title":"Step 2: read_frame and read_audio"},{"location":"insight/adsk/python_utilities/scripts/insight-export_selection/#step-3-subprocess-piping","text":"The script \"pipes\" the video from read_frame into FFmpeg's input. ffmpeg_process = subprocess.Popen(..., stdin=read_frame_process.stdout) This is like connecting a fire hose from one machine (Flame) to another (FFmpeg).","title":"Step 3: Subprocess Piping"},{"location":"insight/adsk/python_utilities/scripts/insight-export_selection/#3-foreground-vs-background","text":"Foreground: Your mouse turns into a wait cursor, and you wait for FFmpeg to finish. Background: The script creates a Backburner job. It actually writes a tiny Python script on the fly and tells Backburner to run it on a render node!","title":"3. Foreground vs. Background"},{"location":"insight/adsk/python_utilities/scripts/insight-export_selection/#4-why-is-this-useful","text":"Custom Formats: Flame's built-in exporter is great, but FFmpeg can do anything (like making tiny H.264 files for WhatsApp or adding custom text overlays). Efficiency: You can offload heavy transcoding to other computers on your network.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/scripts/insight-export_selection/#5-key-takeaway-for-beginners","text":"Flame is an \"Open\" system. You aren't limited to the buttons inside the software. By using subprocess and external tools, you can bridge Flame to any other software on your computer.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/scripts/insight-inject_metadata_write_file_exr/","text":"Insight: Injecting Metadata into OpenEXR Files This document explains the inject_metadata_write_file_exr.py script. It shows how to embed important information (like the project name and user) directly into the headers of your rendered files. Target Audience: Novice Python programmers interested in pipeline data and metadata. 1. Why Inject Metadata? When you render a shot as an OpenEXR sequence, the files go onto a server where other artists (like compositors or colorists) pick them up. If they have a problem with a file, they need to know: - Which project did this come from? - Which version of Flame rendered it? - Who was the artist? This script automates that bookkeeping. It \"tags\" every frame with this info invisibly inside the file header. 2. Key Concepts A. The batch_export_begin Hook Unlike the end hook, this one runs before the first frame is written. This is the perfect time to set the \"Rules\" for the render. B. Targeting the \"Write File\" Node The script finds the specific node doing the work: write_file = flame.batch.get_node(info.get(\"nodeName\")) C. Channel-Specific Metadata OpenEXR files can have many channels (Red, Green, Blue, Alpha, Depth). The script iterates through every channel and injects the same metadata into all of them so the info is never lost. write_file.set_metadata_value(channel_name, key, value) 3. What Information is Saved? The script currently saves: - flame/version : The version of Flame used. - flame/project : The name of the project. - flame/workspace : The artist's workspace. - flame/user : The artist's name. 4. Why is this useful? Traceability: You can always find the source of a file, even years later. Automation: Other software (like ShotGrid or Deadline) can read these headers to automatically organize files. Accuracy: It removes the need for artists to manually type notes into the render settings. 5. Key Takeaway for Beginners Metadata is the \"DNA\" of a digital file. By using the set_metadata_value function, you are ensuring that your files carry their history with them wherever they go.","title":"Insight: Injecting Metadata into OpenEXR Files"},{"location":"insight/adsk/python_utilities/scripts/insight-inject_metadata_write_file_exr/#insight-injecting-metadata-into-openexr-files","text":"This document explains the inject_metadata_write_file_exr.py script. It shows how to embed important information (like the project name and user) directly into the headers of your rendered files. Target Audience: Novice Python programmers interested in pipeline data and metadata.","title":"Insight: Injecting Metadata into OpenEXR Files"},{"location":"insight/adsk/python_utilities/scripts/insight-inject_metadata_write_file_exr/#1-why-inject-metadata","text":"When you render a shot as an OpenEXR sequence, the files go onto a server where other artists (like compositors or colorists) pick them up. If they have a problem with a file, they need to know: - Which project did this come from? - Which version of Flame rendered it? - Who was the artist? This script automates that bookkeeping. It \"tags\" every frame with this info invisibly inside the file header.","title":"1. Why Inject Metadata?"},{"location":"insight/adsk/python_utilities/scripts/insight-inject_metadata_write_file_exr/#2-key-concepts","text":"","title":"2. Key Concepts"},{"location":"insight/adsk/python_utilities/scripts/insight-inject_metadata_write_file_exr/#a-the-batch_export_begin-hook","text":"Unlike the end hook, this one runs before the first frame is written. This is the perfect time to set the \"Rules\" for the render.","title":"A. The batch_export_begin Hook"},{"location":"insight/adsk/python_utilities/scripts/insight-inject_metadata_write_file_exr/#b-targeting-the-write-file-node","text":"The script finds the specific node doing the work: write_file = flame.batch.get_node(info.get(\"nodeName\"))","title":"B. Targeting the \"Write File\" Node"},{"location":"insight/adsk/python_utilities/scripts/insight-inject_metadata_write_file_exr/#c-channel-specific-metadata","text":"OpenEXR files can have many channels (Red, Green, Blue, Alpha, Depth). The script iterates through every channel and injects the same metadata into all of them so the info is never lost. write_file.set_metadata_value(channel_name, key, value)","title":"C. Channel-Specific Metadata"},{"location":"insight/adsk/python_utilities/scripts/insight-inject_metadata_write_file_exr/#3-what-information-is-saved","text":"The script currently saves: - flame/version : The version of Flame used. - flame/project : The name of the project. - flame/workspace : The artist's workspace. - flame/user : The artist's name.","title":"3. What Information is Saved?"},{"location":"insight/adsk/python_utilities/scripts/insight-inject_metadata_write_file_exr/#4-why-is-this-useful","text":"Traceability: You can always find the source of a file, even years later. Automation: Other software (like ShotGrid or Deadline) can read these headers to automatically organize files. Accuracy: It removes the need for artists to manually type notes into the render settings.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/scripts/insight-inject_metadata_write_file_exr/#5-key-takeaway-for-beginners","text":"Metadata is the \"DNA\" of a digital file. By using the set_metadata_value function, you are ensuring that your files carry their history with them wherever they go.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/scripts/insight-manage_archived_clips/","text":"Insight: Managing Archived Clips This document explains the managed_archived_clips.py script. It shows how to use Python to quickly see which of your clips have been safely backed up and which ones are still sitting on your local storage. Target Audience: Novice Python programmers interested in data management and visual feedback. 1. The Challenge: What is Archived? When working on a large project, you often archive (back up) clips to a tape or a server. Once they are archived, you might want to: 1. Identify them quickly without looking at a list. 2. Delete them to save local space, but only if you're sure they are safe. 2. Key Concepts: Archive Properties Flame objects have hidden \"Archive\" properties that Python can read: - item.archive_date : Tells you when the clip was successfully backed up. - item.archive_error : Tells you if the backup failed. 3. How the Script Works The script provides two professional tools: A. Visual Audit (Color Coding) It goes through your selection and changes the color of the clips in the Media Panel: - Green: Successfully Archived. - Red: Archive Failed (Error). - Default: Not yet archived. if item.archive_error: item.colour = (1.0, 0.0, 0.0) # Red elif item.archive_date: item.colour = (0.0, 1.0, 0.0) # Green B. Safe Cleanup It removes clips from your project, but it uses a safety check: if item.archive_date and not item.archive_error: flame.delete(item) This ensures you never delete a clip that hasn't been successfully backed up first. 4. Why is this useful? Confidence: You can see at a glance that your work is safe. Organization: It makes it easy to keep your local project \"lean\" by removing old files. Troubleshooting: Red clips immediately show you where a backup failed, so you can fix it. 5. Key Takeaway for Beginners Using item.colour is a great way to give Visual Feedback to the user. Instead of just printing a text list, changing the UI colors makes your script much more intuitive and \"integrated\" into the Flame experience.","title":"Insight: Managing Archived Clips"},{"location":"insight/adsk/python_utilities/scripts/insight-manage_archived_clips/#insight-managing-archived-clips","text":"This document explains the managed_archived_clips.py script. It shows how to use Python to quickly see which of your clips have been safely backed up and which ones are still sitting on your local storage. Target Audience: Novice Python programmers interested in data management and visual feedback.","title":"Insight: Managing Archived Clips"},{"location":"insight/adsk/python_utilities/scripts/insight-manage_archived_clips/#1-the-challenge-what-is-archived","text":"When working on a large project, you often archive (back up) clips to a tape or a server. Once they are archived, you might want to: 1. Identify them quickly without looking at a list. 2. Delete them to save local space, but only if you're sure they are safe.","title":"1. The Challenge: What is Archived?"},{"location":"insight/adsk/python_utilities/scripts/insight-manage_archived_clips/#2-key-concepts-archive-properties","text":"Flame objects have hidden \"Archive\" properties that Python can read: - item.archive_date : Tells you when the clip was successfully backed up. - item.archive_error : Tells you if the backup failed.","title":"2. Key Concepts: Archive Properties"},{"location":"insight/adsk/python_utilities/scripts/insight-manage_archived_clips/#3-how-the-script-works","text":"The script provides two professional tools:","title":"3. How the Script Works"},{"location":"insight/adsk/python_utilities/scripts/insight-manage_archived_clips/#a-visual-audit-color-coding","text":"It goes through your selection and changes the color of the clips in the Media Panel: - Green: Successfully Archived. - Red: Archive Failed (Error). - Default: Not yet archived. if item.archive_error: item.colour = (1.0, 0.0, 0.0) # Red elif item.archive_date: item.colour = (0.0, 1.0, 0.0) # Green","title":"A. Visual Audit (Color Coding)"},{"location":"insight/adsk/python_utilities/scripts/insight-manage_archived_clips/#b-safe-cleanup","text":"It removes clips from your project, but it uses a safety check: if item.archive_date and not item.archive_error: flame.delete(item) This ensures you never delete a clip that hasn't been successfully backed up first.","title":"B. Safe Cleanup"},{"location":"insight/adsk/python_utilities/scripts/insight-manage_archived_clips/#4-why-is-this-useful","text":"Confidence: You can see at a glance that your work is safe. Organization: It makes it easy to keep your local project \"lean\" by removing old files. Troubleshooting: Red clips immediately show you where a backup failed, so you can fix it.","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/scripts/insight-manage_archived_clips/#5-key-takeaway-for-beginners","text":"Using item.colour is a great way to give Visual Feedback to the user. Instead of just printing a text list, changing the UI colors makes your script much more intuitive and \"integrated\" into the Flame experience.","title":"5. Key Takeaway for Beginners"},{"location":"insight/adsk/python_utilities/scripts/insight-path_of_selected_clips/","text":"Insight: Bridging Flame and the OS This document explains the path_of_selected_clips.py script. It shows how to jump from inside Flame's MediaHub directly into your computer's file browser (like Finder or Nautilus). Target Audience: Novice Python programmers interested in Operating System (OS) integration. 1. What is the Goal? Sometimes you see a clip in Flame's MediaHub and you think: \"I need to see this file on my hard drive to rename it or copy it.\" Normally, you'd have to open a new window and manually browse to that folder. This script creates a shortcut. You right-click the clip in Flame, and the folder pops open on your desktop instantly. 2. Key Concepts A. Detecting the OS Computers work differently. A Mac uses open , while Linux usually uses nautilus . The script checks which system you are on using os.uname() . B. flame.execute_command This is a high-performance way for Flame to talk to the rest of the computer. - The \"Old\" way: Using subprocess.call . - The \"Flame\" way: flame.execute_command . This is better because it doesn't slow down Flame's memory while the external window is open. 3. How the Script Works Get the Path: It looks at the selected item and finds its location on the server/hard drive. Handle Files vs Folders: If you clicked a specific file, the script is smart enough to find the \"Parent Folder\" so it can open the right directory. Run the Browser: It builds a command like /usr/bin/open /Volumes/Media/Shots and tells the OS to run it. 4. Why is this useful? Speed: It saves you from the \"Deep Folder Dive\" through your OS. Verification: It's the fastest way to confirm exactly where a file lives on the physical server. Workflow Bridge: It makes it easy to move between Flame and other software (like checking files in a text editor or a specialized player). 5. Key Takeaway for Beginners Your Python scripts can be a \"Bridge\" between different worlds. By using a few simple OS commands, you can make Flame feel like it's deeply connected to the rest of your computer.","title":"Insight: Bridging Flame and the OS"},{"location":"insight/adsk/python_utilities/scripts/insight-path_of_selected_clips/#insight-bridging-flame-and-the-os","text":"This document explains the path_of_selected_clips.py script. It shows how to jump from inside Flame's MediaHub directly into your computer's file browser (like Finder or Nautilus). Target Audience: Novice Python programmers interested in Operating System (OS) integration.","title":"Insight: Bridging Flame and the OS"},{"location":"insight/adsk/python_utilities/scripts/insight-path_of_selected_clips/#1-what-is-the-goal","text":"Sometimes you see a clip in Flame's MediaHub and you think: \"I need to see this file on my hard drive to rename it or copy it.\" Normally, you'd have to open a new window and manually browse to that folder. This script creates a shortcut. You right-click the clip in Flame, and the folder pops open on your desktop instantly.","title":"1. What is the Goal?"},{"location":"insight/adsk/python_utilities/scripts/insight-path_of_selected_clips/#2-key-concepts","text":"","title":"2. Key Concepts"},{"location":"insight/adsk/python_utilities/scripts/insight-path_of_selected_clips/#a-detecting-the-os","text":"Computers work differently. A Mac uses open , while Linux usually uses nautilus . The script checks which system you are on using os.uname() .","title":"A. Detecting the OS"},{"location":"insight/adsk/python_utilities/scripts/insight-path_of_selected_clips/#b-flameexecute_command","text":"This is a high-performance way for Flame to talk to the rest of the computer. - The \"Old\" way: Using subprocess.call . - The \"Flame\" way: flame.execute_command . This is better because it doesn't slow down Flame's memory while the external window is open.","title":"B. flame.execute_command"},{"location":"insight/adsk/python_utilities/scripts/insight-path_of_selected_clips/#3-how-the-script-works","text":"Get the Path: It looks at the selected item and finds its location on the server/hard drive. Handle Files vs Folders: If you clicked a specific file, the script is smart enough to find the \"Parent Folder\" so it can open the right directory. Run the Browser: It builds a command like /usr/bin/open /Volumes/Media/Shots and tells the OS to run it.","title":"3. How the Script Works"},{"location":"insight/adsk/python_utilities/scripts/insight-path_of_selected_clips/#4-why-is-this-useful","text":"Speed: It saves you from the \"Deep Folder Dive\" through your OS. Verification: It's the fastest way to confirm exactly where a file lives on the physical server. Workflow Bridge: It makes it easy to move between Flame and other software (like checking files in a text editor or a specialized player).","title":"4. Why is this useful?"},{"location":"insight/adsk/python_utilities/scripts/insight-path_of_selected_clips/#5-key-takeaway-for-beginners","text":"Your Python scripts can be a \"Bridge\" between different worlds. By using a few simple OS commands, you can make Flame feel like it's deeply connected to the rest of your computer.","title":"5. Key Takeaway for Beginners"},{"location":"insight/inference_builder_api/insight-inference_builder/","text":"Insight: The Inference Builder API (AI Model Packaging) This document explains the Inference Builder , a specialized tool in Autodesk Flame that allows you to bring your own Artificial Intelligence (AI) models into your creative workflow. Target Audience: Novice Python programmers and technical artists interested in Machine Learning (ML). 1. What is the Inference Builder? Autodesk Flame can run custom AI models (like tools that remove backgrounds, upscale low-res video, or clean up digital noise). These models are usually saved in a standard format called ONNX . However, Flame needs a bit more information to use these models correctly\u2014like knowing which socket is \"Video\" and which is \"Alpha.\" The Inference Builder is the tool that packages an AI model into a single, encrypted file called an .inf file (similar to how Matchbox uses .mx files). 2. The Three-Part Package To create a professional AI tool for Flame, you need three files with the same name: 1. MyModel.onnx : The actual \"Brain\" (the trained AI model). 2. MyModel.json : The \"Instruction Manual\" (the sidecar file that explains how to use the brain). 3. MyModel.png : The \"Cover Art\" (a 128x94 thumbnail for the Flame file browser). 3. The \"Instruction Manual\" (JSON File) The .json file is where you do most of your work. It tells Flame how to connect its inputs to the AI model's inputs. Key Settings to Know: ScalingFactor : If your AI model makes a 1080p image into a 4K image, you set this to 2.0 . This tells Flame to prepare a larger canvas for the result. Channels : AI models are very picky. One model might want \"Red, Green, Blue,\" while another wants \"Blue, Green, Red.\" You use the Channels setting (like \"RGB\" or \"BGR\" ) to translate between them. Padding : Some AI models can only work on images that are multiples of 8 or 16 pixels. If you set Padding: 8 , Flame will automatically add invisible pixels to the edges to make the AI happy, then trim them off when it's done. 4. The Workflow Generate: Run the inference_builder -j command to create a \"starting\" JSON file based on your model. Edit: Open the JSON in a text editor and fill in the descriptions and channel types. Test: Load your .onnx and .json files into an Inference Node in Batch. Package: Once it's working perfectly, run inference_builder -p to turn everything into a single, encrypted .inf file. 5. Why is this useful? Custom Tools: You can download open-source AI models from the internet (like those on HuggingFace) and turn them into native Flame tools. IP Protection: Packaging into an .inf file encrypts your model, so you can share your tool with other studios without them seeing your secret AI \"Brain\" code. User Friendly: It turns a complex technical process into a simple \"Node\" that any Flame artist can use without knowing anything about AI. 6. Key Takeaway for Beginners Think of the Inference Builder as a \"Gift Wrapper.\" You take a raw AI model (the gift), write a card explaining how to use it (the JSON), add a nice picture (the thumbnail), and wrap it all into a professional package (the .inf file) that works perfectly inside Flame.","title":"Insight: The Inference Builder API (AI Model Packaging)"},{"location":"insight/inference_builder_api/insight-inference_builder/#insight-the-inference-builder-api-ai-model-packaging","text":"This document explains the Inference Builder , a specialized tool in Autodesk Flame that allows you to bring your own Artificial Intelligence (AI) models into your creative workflow. Target Audience: Novice Python programmers and technical artists interested in Machine Learning (ML).","title":"Insight: The Inference Builder API (AI Model Packaging)"},{"location":"insight/inference_builder_api/insight-inference_builder/#1-what-is-the-inference-builder","text":"Autodesk Flame can run custom AI models (like tools that remove backgrounds, upscale low-res video, or clean up digital noise). These models are usually saved in a standard format called ONNX . However, Flame needs a bit more information to use these models correctly\u2014like knowing which socket is \"Video\" and which is \"Alpha.\" The Inference Builder is the tool that packages an AI model into a single, encrypted file called an .inf file (similar to how Matchbox uses .mx files).","title":"1. What is the Inference Builder?"},{"location":"insight/inference_builder_api/insight-inference_builder/#2-the-three-part-package","text":"To create a professional AI tool for Flame, you need three files with the same name: 1. MyModel.onnx : The actual \"Brain\" (the trained AI model). 2. MyModel.json : The \"Instruction Manual\" (the sidecar file that explains how to use the brain). 3. MyModel.png : The \"Cover Art\" (a 128x94 thumbnail for the Flame file browser).","title":"2. The Three-Part Package"},{"location":"insight/inference_builder_api/insight-inference_builder/#3-the-instruction-manual-json-file","text":"The .json file is where you do most of your work. It tells Flame how to connect its inputs to the AI model's inputs.","title":"3. The \"Instruction Manual\" (JSON File)"},{"location":"insight/inference_builder_api/insight-inference_builder/#key-settings-to-know","text":"ScalingFactor : If your AI model makes a 1080p image into a 4K image, you set this to 2.0 . This tells Flame to prepare a larger canvas for the result. Channels : AI models are very picky. One model might want \"Red, Green, Blue,\" while another wants \"Blue, Green, Red.\" You use the Channels setting (like \"RGB\" or \"BGR\" ) to translate between them. Padding : Some AI models can only work on images that are multiples of 8 or 16 pixels. If you set Padding: 8 , Flame will automatically add invisible pixels to the edges to make the AI happy, then trim them off when it's done.","title":"Key Settings to Know:"},{"location":"insight/inference_builder_api/insight-inference_builder/#4-the-workflow","text":"Generate: Run the inference_builder -j command to create a \"starting\" JSON file based on your model. Edit: Open the JSON in a text editor and fill in the descriptions and channel types. Test: Load your .onnx and .json files into an Inference Node in Batch. Package: Once it's working perfectly, run inference_builder -p to turn everything into a single, encrypted .inf file.","title":"4. The Workflow"},{"location":"insight/inference_builder_api/insight-inference_builder/#5-why-is-this-useful","text":"Custom Tools: You can download open-source AI models from the internet (like those on HuggingFace) and turn them into native Flame tools. IP Protection: Packaging into an .inf file encrypts your model, so you can share your tool with other studios without them seeing your secret AI \"Brain\" code. User Friendly: It turns a complex technical process into a simple \"Node\" that any Flame artist can use without knowing anything about AI.","title":"5. Why is this useful?"},{"location":"insight/inference_builder_api/insight-inference_builder/#6-key-takeaway-for-beginners","text":"Think of the Inference Builder as a \"Gift Wrapper.\" You take a raw AI model (the gift), write a card explaining how to use it (the JSON), add a nice picture (the thumbnail), and wrap it all into a professional package (the .inf file) that works perfectly inside Flame.","title":"6. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_creator/","text":"Insight: The Open Clip Creator This document explains the Open Clip Creator , a tool used to build special XML files that Flame uses to manage complex media. Target Audience: Novice technical artists and pipeline developers. 1. What is an Open Clip? Think of an Open Clip ( .clip file) as a \"Smart Folder.\" Instead of Flame just looking at one movie file, an Open Clip tells Flame: \"This clip actually has 3 different versions (V1, V2, V3), a separate Left/Right eye for 3D, and it's made up of 5,000 individual DPX images stored on a server.\" It \"wraps\" all that complexity into one single file that Flame can load as a regular clip. 2. The Hierarchy (From Small to Large) The Open Clip is built like a pyramid: 1. Span: The lowest level. It's just a path to a piece of media on your hard drive. 2. Feed: A collection of spans that make up one version of a track. 3. Track: All the versions and information about a single channel (like \"Video\" or \"Audio\"). 4. Clip: The top level. It brings all the tracks together into one object. 3. Powerful Features: Patterns The most useful part of Open Clips for programmers is Patterns . Instead of typing every single filename, you can use Tokens like: - {name} : The name of the clip. - {version} : The version number (e.g., v01, v02). - {frame} : The frame number in a sequence. Why? If you drop a new file named Shot01_v02.mov into a folder, an Open Clip using patterns will automatically see it as a new version inside Flame without you doing anything! 4. How to Create Them You have three options: 1. In Flame: Select clips in the MediaHub, right-click, and choose \"Create Open Clip.\" 2. The App: Use the standalone \"Open Clip Creator\" application. 3. Command Line: Use the openclip_creator tool in your terminal to automate the process for thousands of shots at once. 5. Key Takeaway for Beginners Open Clips are the \"Glue\" of a professional pipeline. They allow you to organize messy folders of renders and movie files into neat, versioned clips that Flame understands perfectly. If you find yourself manually importing \"v02\" every time a render finishes, you should probably be using an Open Clip!","title":"Insight: The Open Clip Creator"},{"location":"insight/openclip_api/insight-open_clip_creator/#insight-the-open-clip-creator","text":"This document explains the Open Clip Creator , a tool used to build special XML files that Flame uses to manage complex media. Target Audience: Novice technical artists and pipeline developers.","title":"Insight: The Open Clip Creator"},{"location":"insight/openclip_api/insight-open_clip_creator/#1-what-is-an-open-clip","text":"Think of an Open Clip ( .clip file) as a \"Smart Folder.\" Instead of Flame just looking at one movie file, an Open Clip tells Flame: \"This clip actually has 3 different versions (V1, V2, V3), a separate Left/Right eye for 3D, and it's made up of 5,000 individual DPX images stored on a server.\" It \"wraps\" all that complexity into one single file that Flame can load as a regular clip.","title":"1. What is an Open Clip?"},{"location":"insight/openclip_api/insight-open_clip_creator/#2-the-hierarchy-from-small-to-large","text":"The Open Clip is built like a pyramid: 1. Span: The lowest level. It's just a path to a piece of media on your hard drive. 2. Feed: A collection of spans that make up one version of a track. 3. Track: All the versions and information about a single channel (like \"Video\" or \"Audio\"). 4. Clip: The top level. It brings all the tracks together into one object.","title":"2. The Hierarchy (From Small to Large)"},{"location":"insight/openclip_api/insight-open_clip_creator/#3-powerful-features-patterns","text":"The most useful part of Open Clips for programmers is Patterns . Instead of typing every single filename, you can use Tokens like: - {name} : The name of the clip. - {version} : The version number (e.g., v01, v02). - {frame} : The frame number in a sequence. Why? If you drop a new file named Shot01_v02.mov into a folder, an Open Clip using patterns will automatically see it as a new version inside Flame without you doing anything!","title":"3. Powerful Features: Patterns"},{"location":"insight/openclip_api/insight-open_clip_creator/#4-how-to-create-them","text":"You have three options: 1. In Flame: Select clips in the MediaHub, right-click, and choose \"Create Open Clip.\" 2. The App: Use the standalone \"Open Clip Creator\" application. 3. Command Line: Use the openclip_creator tool in your terminal to automate the process for thousands of shots at once.","title":"4. How to Create Them"},{"location":"insight/openclip_api/insight-open_clip_creator/#5-key-takeaway-for-beginners","text":"Open Clips are the \"Glue\" of a professional pipeline. They allow you to organize messy folders of renders and movie files into neat, versioned clips that Flame understands perfectly. If you find yourself manually importing \"v02\" every time a render finishes, you should probably be using an Open Clip!","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_reference/","text":"Insight: Open Clip XML Reference This document explains the technical structure of an Open Clip XML file. It is the \"Dictionary\" for how Flame reads the instructions inside a .clip file. Target Audience: Novice programmers interested in XML and data structure. 1. What is inside an Open Clip? An Open Clip file is basically an XML list of directions. It tells Flame: - Where the files are (File paths). - When they start and end (Timecodes). - How they are organized (Tracks and Versions). Important Note: An Open Clip is NOT a timeline like an EDL or AAF. It doesn't contain \"edits\" or \"effects.\" It only describes the media itself. 2. Key Components (The XML Tags) When you open a .clip file in a text editor, you will see several standard tags: <clip> : The main container. <tracks> : Groups together all the different channels (Video, Audio). <versions> : Lists the different revisions of the media. <feeds> : The specific media streams for a version. <spans> : The actual links to files on your hard drive. 3. Version History Open Clip has evolved over the years. The most current version is Version 7 . - Newer versions support things like Nested Dictionaries (for complex metadata) and Resolved Color Spaces (so Flame knows exactly what color management to apply). 4. Learning by Example The best way to understand the XML is to look at existing files. Flame installs several examples on your system: /opt/Autodesk/openclip_examples Try opening these in a text editor like VS Code to see how the tags fit together. 5. Key Takeaway for Beginners Think of the Open Clip Reference as the \"Syntax Guide\" for Flame's media language. If you want to write a script that automatically generates these files, you need to follow these rules exactly so Flame can read your instructions correctly.","title":"Insight: Open Clip XML Reference"},{"location":"insight/openclip_api/insight-open_clip_reference/#insight-open-clip-xml-reference","text":"This document explains the technical structure of an Open Clip XML file. It is the \"Dictionary\" for how Flame reads the instructions inside a .clip file. Target Audience: Novice programmers interested in XML and data structure.","title":"Insight: Open Clip XML Reference"},{"location":"insight/openclip_api/insight-open_clip_reference/#1-what-is-inside-an-open-clip","text":"An Open Clip file is basically an XML list of directions. It tells Flame: - Where the files are (File paths). - When they start and end (Timecodes). - How they are organized (Tracks and Versions). Important Note: An Open Clip is NOT a timeline like an EDL or AAF. It doesn't contain \"edits\" or \"effects.\" It only describes the media itself.","title":"1. What is inside an Open Clip?"},{"location":"insight/openclip_api/insight-open_clip_reference/#2-key-components-the-xml-tags","text":"When you open a .clip file in a text editor, you will see several standard tags: <clip> : The main container. <tracks> : Groups together all the different channels (Video, Audio). <versions> : Lists the different revisions of the media. <feeds> : The specific media streams for a version. <spans> : The actual links to files on your hard drive.","title":"2. Key Components (The XML Tags)"},{"location":"insight/openclip_api/insight-open_clip_reference/#3-version-history","text":"Open Clip has evolved over the years. The most current version is Version 7 . - Newer versions support things like Nested Dictionaries (for complex metadata) and Resolved Color Spaces (so Flame knows exactly what color management to apply).","title":"3. Version History"},{"location":"insight/openclip_api/insight-open_clip_reference/#4-learning-by-example","text":"The best way to understand the XML is to look at existing files. Flame installs several examples on your system: /opt/Autodesk/openclip_examples Try opening these in a text editor like VS Code to see how the tags fit together.","title":"4. Learning by Example"},{"location":"insight/openclip_api/insight-open_clip_reference/#5-key-takeaway-for-beginners","text":"Think of the Open Clip Reference as the \"Syntax Guide\" for Flame's media language. If you want to write a script that automatically generates these files, you need to follow these rules exactly so Flame can read your instructions correctly.","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_clip/","text":"Insight: The Root Container ( ) This document explains the <clip> tag, which is the \"Main Envelope\" of an Open Clip XML file. Everything else in the file lives inside this tag. Target Audience: Novice programmers learning XML structure. 1. What is the <clip> tag? The <clip> tag is the Root Element . This means it is the first tag you open and the last tag you close. It defines the basic identity of the clip. <clip type=\"clip\" version=\"7\"> ... everything else ... </clip> 2. Key Information inside <clip> Inside the clip tag, you can define \"Global\" settings that apply to the whole object: <name> : What the clip is called in Flame. <tracks> : The list of all video and audio channels. <versions> : The list of all available versions (V1, V2, etc.). <startTimecode> : Where the clip starts on a clock (e.g., 01:00:00:00). <duration> : How long the clip is. <userData> : A secret compartment where you can store your own custom notes or tracking IDs. 3. Why is it useful? The <clip> tag acts as a \"Summary.\" If you don't define a specific duration or start time, Flame is smart. It looks inside the clip at all the media and infers the information automatically. This means your XML can be very short if you just want to point to one file, or very detailed if you need to override specific settings. 4. Key Takeaway for Beginners Think of the <clip> tag as the \"Header\" of a document. It sets the version of the \"Open Clip Language\" you are using (currently Version 7) and provides the overall context for Flame to understand the media streams hidden inside.","title":"Insight: The Root Container ()"},{"location":"insight/openclip_api/insight-open_clip_xml_clip/#insight-the-root-container","text":"This document explains the <clip> tag, which is the \"Main Envelope\" of an Open Clip XML file. Everything else in the file lives inside this tag. Target Audience: Novice programmers learning XML structure.","title":"Insight: The Root Container ()"},{"location":"insight/openclip_api/insight-open_clip_xml_clip/#1-what-is-the-clip-tag","text":"The <clip> tag is the Root Element . This means it is the first tag you open and the last tag you close. It defines the basic identity of the clip. <clip type=\"clip\" version=\"7\"> ... everything else ... </clip>","title":"1. What is the &lt;clip&gt; tag?"},{"location":"insight/openclip_api/insight-open_clip_xml_clip/#2-key-information-inside-clip","text":"Inside the clip tag, you can define \"Global\" settings that apply to the whole object: <name> : What the clip is called in Flame. <tracks> : The list of all video and audio channels. <versions> : The list of all available versions (V1, V2, etc.). <startTimecode> : Where the clip starts on a clock (e.g., 01:00:00:00). <duration> : How long the clip is. <userData> : A secret compartment where you can store your own custom notes or tracking IDs.","title":"2. Key Information inside &lt;clip&gt;"},{"location":"insight/openclip_api/insight-open_clip_xml_clip/#3-why-is-it-useful","text":"The <clip> tag acts as a \"Summary.\" If you don't define a specific duration or start time, Flame is smart. It looks inside the clip at all the media and infers the information automatically. This means your XML can be very short if you just want to point to one file, or very detailed if you need to override specific settings.","title":"3. Why is it useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_clip/#4-key-takeaway-for-beginners","text":"Think of the <clip> tag as the \"Header\" of a document. It sets the version of the \"Open Clip Language\" you are using (currently Version 7) and provides the overall context for Flame to understand the media streams hidden inside.","title":"4. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_dict/","text":"Insight: Custom Data Containers ( ) This document explains the <dict> tag (short for \"Dictionary\"). It is a flexible container that lets you store almost any kind of custom information inside an Open Clip. Target Audience: Novice programmers learning about \"Key-Value Pairs.\" 1. What is a Dictionary? In programming, a Dictionary is like a real-world dictionary: you have a Key (the word) and a Value (the definition). In an Open Clip, you might want to save info that Flame doesn't have a standard button for\u2014like \"Artist Name,\" \"Lens Info,\" or \"Colorist Notes.\" 2. How it works in XML Inside a <userData> tag, you use a <dict> to list your custom keys: <userData type=\"dict\"> <Artist type=\"string\">John Doe</Artist> <Status type=\"string\">Approved</Status> <RenderTime type=\"int32\">120</RenderTime> </userData> 3. Supported Data Types The <dict> is very versatile. You can tell Flame exactly what kind of data you are storing using the type attribute: - string : Text (names, notes). - int / float : Numbers (versions, frame rates). - bool : Yes/No switches. - time : Timecodes. - dict : You can even put a dictionary inside another dictionary! (This is called \"Nesting\"). 4. Why is this useful? Pipeline Tracking: Your studio's render manager can write a unique ID into the <dict> . Later, Flame can read that ID to find the original 3D project. Automation: You can write a Python script that looks at the userData to decide how to process a clip. Organization: It keeps your custom notes bundled right inside the media file, so they never get lost. 5. Key Takeaway for Beginners The <dict> tag is your \"Miscellaneous\" folder. If Flame doesn't have a specific tag for the data you want to save, just create your own key inside a dictionary. It's the best way to make the Open Clip work for your specific studio needs.","title":"Insight: Custom Data Containers ()"},{"location":"insight/openclip_api/insight-open_clip_xml_dict/#insight-custom-data-containers","text":"This document explains the <dict> tag (short for \"Dictionary\"). It is a flexible container that lets you store almost any kind of custom information inside an Open Clip. Target Audience: Novice programmers learning about \"Key-Value Pairs.\"","title":"Insight: Custom Data Containers ()"},{"location":"insight/openclip_api/insight-open_clip_xml_dict/#1-what-is-a-dictionary","text":"In programming, a Dictionary is like a real-world dictionary: you have a Key (the word) and a Value (the definition). In an Open Clip, you might want to save info that Flame doesn't have a standard button for\u2014like \"Artist Name,\" \"Lens Info,\" or \"Colorist Notes.\"","title":"1. What is a Dictionary?"},{"location":"insight/openclip_api/insight-open_clip_xml_dict/#2-how-it-works-in-xml","text":"Inside a <userData> tag, you use a <dict> to list your custom keys: <userData type=\"dict\"> <Artist type=\"string\">John Doe</Artist> <Status type=\"string\">Approved</Status> <RenderTime type=\"int32\">120</RenderTime> </userData>","title":"2. How it works in XML"},{"location":"insight/openclip_api/insight-open_clip_xml_dict/#3-supported-data-types","text":"The <dict> is very versatile. You can tell Flame exactly what kind of data you are storing using the type attribute: - string : Text (names, notes). - int / float : Numbers (versions, frame rates). - bool : Yes/No switches. - time : Timecodes. - dict : You can even put a dictionary inside another dictionary! (This is called \"Nesting\").","title":"3. Supported Data Types"},{"location":"insight/openclip_api/insight-open_clip_xml_dict/#4-why-is-this-useful","text":"Pipeline Tracking: Your studio's render manager can write a unique ID into the <dict> . Later, Flame can read that ID to find the original 3D project. Automation: You can write a Python script that looks at the userData to decide how to process a clip. Organization: It keeps your custom notes bundled right inside the media file, so they never get lost.","title":"4. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_dict/#5-key-takeaway-for-beginners","text":"The <dict> tag is your \"Miscellaneous\" folder. If Flame doesn't have a specific tag for the data you want to save, just create your own key inside a dictionary. It's the best way to make the Open Clip work for your specific studio needs.","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_feed/","text":"Insight: The Media Stream ( ) This document explains the <feed> tag. It is the part of the Open Clip that points to a specific stream of media for a specific version. Target Audience: Novice programmers interested in versioning and media streams. 1. What is a Feed? If a Track is like a channel on a TV, a Feed is the actual show playing on that channel right now. Specifically, a <feed> represents one version of a track. If you have \"Version 1\" and \"Version 2\" of a shot, each one will have its own <feed> tag inside the track. 2. Connecting Feeds to Versions The most important part of a feed is the vuid (Version Unique ID). - All feeds that belong to \"Version 1\" (across all your video and audio tracks) must share the same vuid (e.g., vuid=\"v1\" ). - This is how Flame knows that when you switch the clip to \"Version 2,\" it should switch the Video Feed AND the Audio Feed at the same time. 3. Key Information inside a Feed uid : A unique name for this specific stream. <spans> : This is where the actual links to the files on your hard drive are stored. <sampleRate> : The frame rate of the media (e.g., 24 or 30). <startOffset> : A way to slide the media forward or backward in time without changing the original file. 4. Why is this useful? Feeds allow you to have Heterogeneous Media . - Version 1 could be a low-res Proxy ( .mov ). - Version 2 could be a high-res master ( .exr ). Because they are in separate <feed> tags, Flame can manage them both inside the same clip perfectly. 5. Key Takeaway for Beginners The <feed> tag is the bridge between the high-level organization (Tracks and Versions) and the low-level files (Spans). It tells Flame: \"For Version X of this track, use these specific files.\"","title":"Insight: The Media Stream ()"},{"location":"insight/openclip_api/insight-open_clip_xml_feed/#insight-the-media-stream","text":"This document explains the <feed> tag. It is the part of the Open Clip that points to a specific stream of media for a specific version. Target Audience: Novice programmers interested in versioning and media streams.","title":"Insight: The Media Stream ()"},{"location":"insight/openclip_api/insight-open_clip_xml_feed/#1-what-is-a-feed","text":"If a Track is like a channel on a TV, a Feed is the actual show playing on that channel right now. Specifically, a <feed> represents one version of a track. If you have \"Version 1\" and \"Version 2\" of a shot, each one will have its own <feed> tag inside the track.","title":"1. What is a Feed?"},{"location":"insight/openclip_api/insight-open_clip_xml_feed/#2-connecting-feeds-to-versions","text":"The most important part of a feed is the vuid (Version Unique ID). - All feeds that belong to \"Version 1\" (across all your video and audio tracks) must share the same vuid (e.g., vuid=\"v1\" ). - This is how Flame knows that when you switch the clip to \"Version 2,\" it should switch the Video Feed AND the Audio Feed at the same time.","title":"2. Connecting Feeds to Versions"},{"location":"insight/openclip_api/insight-open_clip_xml_feed/#3-key-information-inside-a-feed","text":"uid : A unique name for this specific stream. <spans> : This is where the actual links to the files on your hard drive are stored. <sampleRate> : The frame rate of the media (e.g., 24 or 30). <startOffset> : A way to slide the media forward or backward in time without changing the original file.","title":"3. Key Information inside a Feed"},{"location":"insight/openclip_api/insight-open_clip_xml_feed/#4-why-is-this-useful","text":"Feeds allow you to have Heterogeneous Media . - Version 1 could be a low-res Proxy ( .mov ). - Version 2 could be a high-res master ( .exr ). Because they are in separate <feed> tags, Flame can manage them both inside the same clip perfectly.","title":"4. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_feed/#5-key-takeaway-for-beginners","text":"The <feed> tag is the bridge between the high-level organization (Tracks and Versions) and the low-level files (Spans). It tells Flame: \"For Version X of this track, use these specific files.\"","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_feeds/","text":"Insight: Managing Version Lists ( ) This document explains the <feeds> tag (note the 's' at the end!). It is a simple container that holds all the different versions available for a single track. Target Audience: Novice programmers learning about XML lists. 1. What is the <feeds> tag? Think of <feeds> as a Folder . Inside this folder, you put all the individual <feed> tags (the specific versions) for a track. 2. The \"Active\" Version The most important job of the <feeds> tag is to tell Flame which version to show first. It does this using the currentVersion attribute. <feeds currentVersion=\"v2\"> <feed vuid=\"v1\" ... /> <feed vuid=\"v2\" ... /> <!-- This one is active! --> </feeds> If you don't specify a currentVersion , Flame will usually just pick the last one in the list. 3. Why is this useful? It allows for Instant Switching . Because all the versions are listed inside the <feeds> container, an artist in Flame can just click a button to swap between \"v1\" and \"v2\" instantly. The <feeds> tag keeps those options organized and ready to go. 4. Key Takeaway for Beginners The <feeds> tag is the Manager of a track's history. It doesn't hold any media itself; it just keeps a list of every version that has been rendered for that track and marks which one is the \"Current Master.\"","title":"Insight: Managing Version Lists ()"},{"location":"insight/openclip_api/insight-open_clip_xml_feeds/#insight-managing-version-lists","text":"This document explains the <feeds> tag (note the 's' at the end!). It is a simple container that holds all the different versions available for a single track. Target Audience: Novice programmers learning about XML lists.","title":"Insight: Managing Version Lists ()"},{"location":"insight/openclip_api/insight-open_clip_xml_feeds/#1-what-is-the-feeds-tag","text":"Think of <feeds> as a Folder . Inside this folder, you put all the individual <feed> tags (the specific versions) for a track.","title":"1. What is the &lt;feeds&gt; tag?"},{"location":"insight/openclip_api/insight-open_clip_xml_feeds/#2-the-active-version","text":"The most important job of the <feeds> tag is to tell Flame which version to show first. It does this using the currentVersion attribute. <feeds currentVersion=\"v2\"> <feed vuid=\"v1\" ... /> <feed vuid=\"v2\" ... /> <!-- This one is active! --> </feeds> If you don't specify a currentVersion , Flame will usually just pick the last one in the list.","title":"2. The \"Active\" Version"},{"location":"insight/openclip_api/insight-open_clip_xml_feeds/#3-why-is-this-useful","text":"It allows for Instant Switching . Because all the versions are listed inside the <feeds> container, an artist in Flame can just click a button to swap between \"v1\" and \"v2\" instantly. The <feeds> tag keeps those options organized and ready to go.","title":"3. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_feeds/#4-key-takeaway-for-beginners","text":"The <feeds> tag is the Manager of a track's history. It doesn't hold any media itself; it just keeps a list of every version that has been rendered for that track and marks which one is the \"Current Master.\"","title":"4. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_handler/","text":"Insight: The Media Interpreter ( ) This document explains the <handler> tag. It is the part of the Open Clip that acts as a \"Driver\" or \"Interpreter\" for the media files. Target Audience: Novice programmers interested in how software reads files. 1. What is a Handler? When Flame looks at a file (like a DPX sequence), it needs to know how to read the metadata inside it\u2014like the frame rate or the timecode. The <handler> tag tells Flame which \"Logic Engine\" to use. Common handlers include: - MIO Clip : The standard engine for reading modern media files. 2. Dynamic Discovery (ScanPattern) One of the most powerful things a handler can do is Scan . Instead of you listing every single file path in the XML, you can give the handler a \"Search Pattern\" using the <ScanPattern> option. <ScanPattern>Media/Shot_v{version}.{frame}.exr</ScanPattern> How it works: Flame will look at the Media folder. If it finds Shot_v01.001.exr and Shot_v02.001.exr , it will automatically create Version 1 and Version 2 for you. Why use it? It makes your Open Clips \"Self-Updating.\" As soon as a 3D artist renders a new version, Flame sees it instantly. 3. Handler Options Inside the handler, you can also set \"Rules\" for how to interpret the media: - RateMode : Should Flame trust the \"Header\" of the file for the frame rate, or should you force a specific number? - AlignToZero : Should the first frame of the file always be treated as \"Frame 0\"? 4. Why is this useful? The handler removes the manual labor of building complex clips. By setting up a good Scan Pattern, you can create a single .clip file that acts as a window into a messy folder of renders, organizing them into a neat, versioned interface for the artist. 5. Key Takeaway for Beginners Think of the <handler> as the \"Smart Assistant.\" You give it a general rule (the Scan Pattern), and it does the tedious work of finding files and identifying versions so you don't have to write thousands of lines of XML.","title":"Insight: The Media Interpreter ()"},{"location":"insight/openclip_api/insight-open_clip_xml_handler/#insight-the-media-interpreter","text":"This document explains the <handler> tag. It is the part of the Open Clip that acts as a \"Driver\" or \"Interpreter\" for the media files. Target Audience: Novice programmers interested in how software reads files.","title":"Insight: The Media Interpreter ()"},{"location":"insight/openclip_api/insight-open_clip_xml_handler/#1-what-is-a-handler","text":"When Flame looks at a file (like a DPX sequence), it needs to know how to read the metadata inside it\u2014like the frame rate or the timecode. The <handler> tag tells Flame which \"Logic Engine\" to use. Common handlers include: - MIO Clip : The standard engine for reading modern media files.","title":"1. What is a Handler?"},{"location":"insight/openclip_api/insight-open_clip_xml_handler/#2-dynamic-discovery-scanpattern","text":"One of the most powerful things a handler can do is Scan . Instead of you listing every single file path in the XML, you can give the handler a \"Search Pattern\" using the <ScanPattern> option. <ScanPattern>Media/Shot_v{version}.{frame}.exr</ScanPattern> How it works: Flame will look at the Media folder. If it finds Shot_v01.001.exr and Shot_v02.001.exr , it will automatically create Version 1 and Version 2 for you. Why use it? It makes your Open Clips \"Self-Updating.\" As soon as a 3D artist renders a new version, Flame sees it instantly.","title":"2. Dynamic Discovery (ScanPattern)"},{"location":"insight/openclip_api/insight-open_clip_xml_handler/#3-handler-options","text":"Inside the handler, you can also set \"Rules\" for how to interpret the media: - RateMode : Should Flame trust the \"Header\" of the file for the frame rate, or should you force a specific number? - AlignToZero : Should the first frame of the file always be treated as \"Frame 0\"?","title":"3. Handler Options"},{"location":"insight/openclip_api/insight-open_clip_xml_handler/#4-why-is-this-useful","text":"The handler removes the manual labor of building complex clips. By setting up a good Scan Pattern, you can create a single .clip file that acts as a window into a messy folder of renders, organizing them into a neat, versioned interface for the artist.","title":"4. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_handler/#5-key-takeaway-for-beginners","text":"Think of the <handler> as the \"Smart Assistant.\" You give it a general rule (the Scan Pattern), and it does the tedious work of finding files and identifying versions so you don't have to write thousands of lines of XML.","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_path/","text":"Insight: Linking to Files ( ) This document explains the <path> tag. It is the lowest level of an Open Clip and tells Flame exactly where to find the physical media on your computer or server. Target Audience: Novice programmers interested in file systems and patterns. 1. What is a Path? A path is just an address. In an Open Clip, it can be two things: 1. A Single File: Like a QuickTime movie ( video.mov ). 2. A Pattern: Like a sequence of images ( shot_[001-100].dpx ). 2. Encoding Types The encoding attribute tells Flame how to read the text inside the tag: - encoding=\"file\" : Take the text literally. Don't look for brackets or numbers. - encoding=\"pattern\" : Look for special characters like [] or {frame} to find a range of files. 3. Absolute vs. Relative Paths Absolute: The full address from the root of the computer (e.g., /Volumes/Media/Shot01.mov ). Relative: The address starting from where the .clip file is saved (e.g., Media/Shot01.mov ). Tip: Relative paths are better because you can move the entire project folder to a new drive without breaking the links! 4. Range Patterns Open Clip supports a shorthand for image sequences: - shot_[0001-0010].exr will automatically find frames 1 through 10. - shot_{frame}.exr will find every frame in that folder that matches the name, no matter what the numbers are. 5. Key Takeaway for Beginners The <path> tag is the \"Street Address\" for your media. Whether you are pointing to one big movie file or 10,000 individual images, the <path> tag is where you give Flame the specific coordinates to find those bits and bytes.","title":"Insight: Linking to Files ()"},{"location":"insight/openclip_api/insight-open_clip_xml_path/#insight-linking-to-files","text":"This document explains the <path> tag. It is the lowest level of an Open Clip and tells Flame exactly where to find the physical media on your computer or server. Target Audience: Novice programmers interested in file systems and patterns.","title":"Insight: Linking to Files ()"},{"location":"insight/openclip_api/insight-open_clip_xml_path/#1-what-is-a-path","text":"A path is just an address. In an Open Clip, it can be two things: 1. A Single File: Like a QuickTime movie ( video.mov ). 2. A Pattern: Like a sequence of images ( shot_[001-100].dpx ).","title":"1. What is a Path?"},{"location":"insight/openclip_api/insight-open_clip_xml_path/#2-encoding-types","text":"The encoding attribute tells Flame how to read the text inside the tag: - encoding=\"file\" : Take the text literally. Don't look for brackets or numbers. - encoding=\"pattern\" : Look for special characters like [] or {frame} to find a range of files.","title":"2. Encoding Types"},{"location":"insight/openclip_api/insight-open_clip_xml_path/#3-absolute-vs-relative-paths","text":"Absolute: The full address from the root of the computer (e.g., /Volumes/Media/Shot01.mov ). Relative: The address starting from where the .clip file is saved (e.g., Media/Shot01.mov ). Tip: Relative paths are better because you can move the entire project folder to a new drive without breaking the links!","title":"3. Absolute vs. Relative Paths"},{"location":"insight/openclip_api/insight-open_clip_xml_path/#4-range-patterns","text":"Open Clip supports a shorthand for image sequences: - shot_[0001-0010].exr will automatically find frames 1 through 10. - shot_{frame}.exr will find every frame in that folder that matches the name, no matter what the numbers are.","title":"4. Range Patterns"},{"location":"insight/openclip_api/insight-open_clip_xml_path/#5-key-takeaway-for-beginners","text":"The <path> tag is the \"Street Address\" for your media. Whether you are pointing to one big movie file or 10,000 individual images, the <path> tag is where you give Flame the specific coordinates to find those bits and bytes.","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_paths/","text":"Insight: Multiple Views ( ) This document explains the <paths> tag (with an 's'). It is a special container used when you have multiple \"Views\" of the exact same moment in time\u2014the most common example being Stereo 3D . Target Audience: Novice programmers interested in 3D and stereoscopic media. 1. What is the <paths> tag? Sometimes, one path isn't enough to describe a single moment of video. In a 3D movie, you need a path for the Left Eye and a different path for the Right Eye . The <paths> tag groups these two links together so Flame knows they are two halves of the same stereoscopic image. 2. Using subFeedId Inside the <paths> tag, you list multiple <path> tags. You use the subFeedId attribute to label them: <paths> <path subFeedId=\"Left\" encoding=\"file\">Media/shot_L.mov</path> <path subFeedId=\"Right\" encoding=\"file\">Media/shot_R.mov</path> </paths> 3. Why is this different from Tracks? Tracks are for different things (like Video vs. Audio). They can have different lengths and frame rates. Paths (inside a Feed) are for different views of the same thing . The Left and Right eyes must have the exact same duration and frame rate to work together. 4. Why is this useful? It simplifies the artist's life. Instead of having two separate clips (one for each eye), the artist just sees one \"Stereo Clip.\" Flame handles the complexity of reading both files in the background and keeping them perfectly in sync. 5. Key Takeaway for Beginners The <paths> tag is the \"Stereo Pair\" container. Use it whenever you have media that needs to be \"Joined at the Hip\"\u2014different files that represent different angles or views of the exact same sequence of frames.","title":"Insight: Multiple Views ()"},{"location":"insight/openclip_api/insight-open_clip_xml_paths/#insight-multiple-views","text":"This document explains the <paths> tag (with an 's'). It is a special container used when you have multiple \"Views\" of the exact same moment in time\u2014the most common example being Stereo 3D . Target Audience: Novice programmers interested in 3D and stereoscopic media.","title":"Insight: Multiple Views ()"},{"location":"insight/openclip_api/insight-open_clip_xml_paths/#1-what-is-the-paths-tag","text":"Sometimes, one path isn't enough to describe a single moment of video. In a 3D movie, you need a path for the Left Eye and a different path for the Right Eye . The <paths> tag groups these two links together so Flame knows they are two halves of the same stereoscopic image.","title":"1. What is the &lt;paths&gt; tag?"},{"location":"insight/openclip_api/insight-open_clip_xml_paths/#2-using-subfeedid","text":"Inside the <paths> tag, you list multiple <path> tags. You use the subFeedId attribute to label them: <paths> <path subFeedId=\"Left\" encoding=\"file\">Media/shot_L.mov</path> <path subFeedId=\"Right\" encoding=\"file\">Media/shot_R.mov</path> </paths>","title":"2. Using subFeedId"},{"location":"insight/openclip_api/insight-open_clip_xml_paths/#3-why-is-this-different-from-tracks","text":"Tracks are for different things (like Video vs. Audio). They can have different lengths and frame rates. Paths (inside a Feed) are for different views of the same thing . The Left and Right eyes must have the exact same duration and frame rate to work together.","title":"3. Why is this different from Tracks?"},{"location":"insight/openclip_api/insight-open_clip_xml_paths/#4-why-is-this-useful","text":"It simplifies the artist's life. Instead of having two separate clips (one for each eye), the artist just sees one \"Stereo Clip.\" Flame handles the complexity of reading both files in the background and keeping them perfectly in sync.","title":"4. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_paths/#5-key-takeaway-for-beginners","text":"The <paths> tag is the \"Stereo Pair\" container. Use it whenever you have media that needs to be \"Joined at the Hip\"\u2014different files that represent different angles or views of the exact same sequence of frames.","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_rate/","text":"Insight: Precision Frame Rates ( ) This document explains the <rate> tag. It is used to tell Flame exactly how many frames (images) should play every second. Target Audience: Novice programmers interested in video timing and math. 1. Why Not Just Use Decimals? In the movie world, frame rates are often messy. For example, \"23.98 fps\" is actually 23.976023976... infinitely. If a computer uses a simple decimal, it will eventually lose sync over a long movie. 2. The Rational Solution (Numerator & Denominator) To keep things 100% precise, Open Clip uses Fractions . <rate type=\"rate\"> <numerator>24000</numerator> <denominator>1001</denominator> </rate> Numerator: The top number. Denominator: The bottom number. Result: 24000 / 1001 equals exactly 23.976... without any rounding errors. 3. Simplified Decimal Format If you aren't worried about extreme precision (like for a short 5-second clip), you can still use a simple number: <rate type=\"rate\">24</rate> <!-- Exactly 24 frames per second --> 4. Why is this useful? Precision frame rates ensure that your audio and video stay perfectly in sync, even if the movie is 3 hours long. By using the <numerator> and <denominator> , you are giving Flame the most accurate \"Clock\" possible. 5. Key Takeaway for Beginners The <rate> tag is the \"Metronome\" of your clip. Using the fraction format ( 24000/1001 ) is the professional way to handle frame rates, ensuring that every single frame plays at exactly the right micro-second.","title":"Insight: Precision Frame Rates ()"},{"location":"insight/openclip_api/insight-open_clip_xml_rate/#insight-precision-frame-rates","text":"This document explains the <rate> tag. It is used to tell Flame exactly how many frames (images) should play every second. Target Audience: Novice programmers interested in video timing and math.","title":"Insight: Precision Frame Rates ()"},{"location":"insight/openclip_api/insight-open_clip_xml_rate/#1-why-not-just-use-decimals","text":"In the movie world, frame rates are often messy. For example, \"23.98 fps\" is actually 23.976023976... infinitely. If a computer uses a simple decimal, it will eventually lose sync over a long movie.","title":"1. Why Not Just Use Decimals?"},{"location":"insight/openclip_api/insight-open_clip_xml_rate/#2-the-rational-solution-numerator-denominator","text":"To keep things 100% precise, Open Clip uses Fractions . <rate type=\"rate\"> <numerator>24000</numerator> <denominator>1001</denominator> </rate> Numerator: The top number. Denominator: The bottom number. Result: 24000 / 1001 equals exactly 23.976... without any rounding errors.","title":"2. The Rational Solution (Numerator &amp; Denominator)"},{"location":"insight/openclip_api/insight-open_clip_xml_rate/#3-simplified-decimal-format","text":"If you aren't worried about extreme precision (like for a short 5-second clip), you can still use a simple number: <rate type=\"rate\">24</rate> <!-- Exactly 24 frames per second -->","title":"3. Simplified Decimal Format"},{"location":"insight/openclip_api/insight-open_clip_xml_rate/#4-why-is-this-useful","text":"Precision frame rates ensure that your audio and video stay perfectly in sync, even if the movie is 3 hours long. By using the <numerator> and <denominator> , you are giving Flame the most accurate \"Clock\" possible.","title":"4. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_rate/#5-key-takeaway-for-beginners","text":"The <rate> tag is the \"Metronome\" of your clip. Using the fraction format ( 24000/1001 ) is the professional way to handle frame rates, ensuring that every single frame plays at exactly the right micro-second.","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_rational/","text":"Insight: Precise Fractions ( ) This document explains the <rational> tag. It is very similar to the <rate> tag, but it's used for general math instead of just frame rates. Target Audience: Novice programmers learning about data precision. 1. What is a Rational number? In mathematics, a Rational number is any number that can be written as a fraction (one number divided by another). In an Open Clip, we use this for things like Aspect Ratio (the shape of the screen). 2. Using the Fraction Format Instead of saying \"The screen is 1.777 wide,\" we use the exact fraction for 16:9: <rational type=\"rational\"> <numerator>16</numerator> <denominator>9</denominator> </rational> 3. Why is this useful? Just like frame rates, using fractions prevents \"Rounding Errors.\" If a computer rounds 1.777777 to 1.78 , your image might look slightly stretched or squashed. By giving Flame the exact numbers ( 16 and 9 ), the math stays perfect. 4. Key Takeaway for Beginners The <rational> tag is used whenever you need to be 100% accurate about a ratio or fraction. Use it for aspect ratios or any other setting where a simple decimal isn't precise enough for professional filmmaking.","title":"Insight: Precise Fractions ()"},{"location":"insight/openclip_api/insight-open_clip_xml_rational/#insight-precise-fractions","text":"This document explains the <rational> tag. It is very similar to the <rate> tag, but it's used for general math instead of just frame rates. Target Audience: Novice programmers learning about data precision.","title":"Insight: Precise Fractions ()"},{"location":"insight/openclip_api/insight-open_clip_xml_rational/#1-what-is-a-rational-number","text":"In mathematics, a Rational number is any number that can be written as a fraction (one number divided by another). In an Open Clip, we use this for things like Aspect Ratio (the shape of the screen).","title":"1. What is a Rational number?"},{"location":"insight/openclip_api/insight-open_clip_xml_rational/#2-using-the-fraction-format","text":"Instead of saying \"The screen is 1.777 wide,\" we use the exact fraction for 16:9: <rational type=\"rational\"> <numerator>16</numerator> <denominator>9</denominator> </rational>","title":"2. Using the Fraction Format"},{"location":"insight/openclip_api/insight-open_clip_xml_rational/#3-why-is-this-useful","text":"Just like frame rates, using fractions prevents \"Rounding Errors.\" If a computer rounds 1.777777 to 1.78 , your image might look slightly stretched or squashed. By giving Flame the exact numbers ( 16 and 9 ), the math stays perfect.","title":"3. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_rational/#4-key-takeaway-for-beginners","text":"The <rational> tag is used whenever you need to be 100% accurate about a ratio or fraction. Use it for aspect ratios or any other setting where a simple decimal isn't precise enough for professional filmmaking.","title":"4. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_span/","text":"Insight: The File Link ( ) This document explains the <span> tag. It is the part of the Open Clip that describes a single continuous piece of media. Target Audience: Novice programmers interested in how software links to files. 1. What is a Span? In the real world, a \"Span\" is a distance between two points. In an Open Clip, a <span> is a continuous segment of time that points to a specific physical location on your hard drive. A <feed> is made up of one or more spans. 2. Key Information inside a Span <path> : The address of the file (e.g., Media/video.mov ). <duration> : How many frames this specific file lasts. <trackIndex> : If you are pointing to a file with many tracks (like a multi-channel OpenEXR), this tells Flame which specific channel to look at (e.g., Index 0 for Red, Index 1 for Green). 3. Why use multiple spans? Imagine you have a long movie that was recorded by a camera that split the file into 4GB chunks ( part1.mov , video2.mov , final.mov ). Instead of joining them in an editing program, you can just list three <span> tags inside your Open Clip. Flame will play them back-to-back as if they were one single, perfect file! 4. Creating Gaps If you have a <span> with a duration but no path , Flame treats it as a Gap . It will just show black for that amount of time. This is a great way to \"Pad\" a clip if you know more media is coming later. 5. Key Takeaway for Beginners The <span> tag is the \"Building Block\" of your media stream. By stacking multiple spans together, you can bridge multiple files into one continuous clip without ever needing to render a new file.","title":"Insight: The File Link ()"},{"location":"insight/openclip_api/insight-open_clip_xml_span/#insight-the-file-link","text":"This document explains the <span> tag. It is the part of the Open Clip that describes a single continuous piece of media. Target Audience: Novice programmers interested in how software links to files.","title":"Insight: The File Link ()"},{"location":"insight/openclip_api/insight-open_clip_xml_span/#1-what-is-a-span","text":"In the real world, a \"Span\" is a distance between two points. In an Open Clip, a <span> is a continuous segment of time that points to a specific physical location on your hard drive. A <feed> is made up of one or more spans.","title":"1. What is a Span?"},{"location":"insight/openclip_api/insight-open_clip_xml_span/#2-key-information-inside-a-span","text":"<path> : The address of the file (e.g., Media/video.mov ). <duration> : How many frames this specific file lasts. <trackIndex> : If you are pointing to a file with many tracks (like a multi-channel OpenEXR), this tells Flame which specific channel to look at (e.g., Index 0 for Red, Index 1 for Green).","title":"2. Key Information inside a Span"},{"location":"insight/openclip_api/insight-open_clip_xml_span/#3-why-use-multiple-spans","text":"Imagine you have a long movie that was recorded by a camera that split the file into 4GB chunks ( part1.mov , video2.mov , final.mov ). Instead of joining them in an editing program, you can just list three <span> tags inside your Open Clip. Flame will play them back-to-back as if they were one single, perfect file!","title":"3. Why use multiple spans?"},{"location":"insight/openclip_api/insight-open_clip_xml_span/#4-creating-gaps","text":"If you have a <span> with a duration but no path , Flame treats it as a Gap . It will just show black for that amount of time. This is a great way to \"Pad\" a clip if you know more media is coming later.","title":"4. Creating Gaps"},{"location":"insight/openclip_api/insight-open_clip_xml_span/#5-key-takeaway-for-beginners","text":"The <span> tag is the \"Building Block\" of your media stream. By stacking multiple spans together, you can bridge multiple files into one continuous clip without ever needing to render a new file.","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_spans/","text":"Insight: Joining Segments ( ) This document explains the <spans> tag (with an 's'). It is a simple list that holds all the individual links (spans) for a media stream. Target Audience: Novice programmers learning about sequential data. 1. What is the <spans> tag? Think of <spans> as a Playlist . It defines the order in which individual files should be played to make up one version of a track. 2. Order Matters The order in which you list the <span> tags inside the <spans> container is exactly how Flame will play them. 1. First <span> = The beginning of the clip. 2. Second <span> = Joined immediately after the first. 3. ...and so on. 3. Why is this useful? It allows for \"Virtual Assembly.\" You can join dozens of files together without moving them or renaming them. As long as they are listed in the <spans> tag, Flame handles the transition between the files invisibly in the background. This is common for \"Spanned\" camera recordings where one long take is saved as multiple smaller files. 4. Key Takeaway for Beginners The <spans> tag is the \"Sequential List\" of your media. It takes individual building blocks (spans) and glues them together into a single, seamless stream of frames for Flame to play.","title":"Insight: Joining Segments ()"},{"location":"insight/openclip_api/insight-open_clip_xml_spans/#insight-joining-segments","text":"This document explains the <spans> tag (with an 's'). It is a simple list that holds all the individual links (spans) for a media stream. Target Audience: Novice programmers learning about sequential data.","title":"Insight: Joining Segments ()"},{"location":"insight/openclip_api/insight-open_clip_xml_spans/#1-what-is-the-spans-tag","text":"Think of <spans> as a Playlist . It defines the order in which individual files should be played to make up one version of a track.","title":"1. What is the &lt;spans&gt; tag?"},{"location":"insight/openclip_api/insight-open_clip_xml_spans/#2-order-matters","text":"The order in which you list the <span> tags inside the <spans> container is exactly how Flame will play them. 1. First <span> = The beginning of the clip. 2. Second <span> = Joined immediately after the first. 3. ...and so on.","title":"2. Order Matters"},{"location":"insight/openclip_api/insight-open_clip_xml_spans/#3-why-is-this-useful","text":"It allows for \"Virtual Assembly.\" You can join dozens of files together without moving them or renaming them. As long as they are listed in the <spans> tag, Flame handles the transition between the files invisibly in the background. This is common for \"Spanned\" camera recordings where one long take is saved as multiple smaller files.","title":"3. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_spans/#4-key-takeaway-for-beginners","text":"The <spans> tag is the \"Sequential List\" of your media. It takes individual building blocks (spans) and glues them together into a single, seamless stream of frames for Flame to play.","title":"4. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_time/","text":"Insight: Measuring Time ( ) This document explains the <time> tag. It is how Flame calculates where a clip sits on a timeline and how long it lasts. Target Audience: Novice programmers interested in timecodes and duration. 1. How is Time measured in Flame? In digital video, time isn't just \"minutes and seconds.\" It's a combination of two things: 1. A Count: How many frames (samples) are there? 2. A Speed: How fast do those frames play? 2. The Anatomy of the <time> tag The <time> tag combines these two parts: <nbTicks> : The number of \"Ticks\" or Frames. (e.g., 240 frames). <rate> : The speed (e.g., 24 frames per second). <dropMode> : For certain broadcast standards (like NTSC), you might need \"Drop Frame\" ( DF ) or \"Non-Drop Frame\" ( NDF ) mode to keep the clock accurate. 3. Calculating Seconds To find out how many seconds a clip is, Flame does a simple math problem: nbTicks divided by rate = seconds Example: 48 frames / 24 fps = 2 seconds . 4. Why is this useful? Flexibility: You can define time in frames, or you can get extremely precise using fractional rates (like 24000/1001 ). Communication: It allows the Open Clip to speak the \"Language of Timecode,\" which is essential for editors who need to know exactly which hour, minute, and second a shot belongs to. 5. Key Takeaway for Beginners Time in an Open Clip is a Calculation . The <time> tag gives Flame the two ingredients it needs (Count and Speed) to correctly place your media on the timeline.","title":"Insight: Measuring Time ()"},{"location":"insight/openclip_api/insight-open_clip_xml_time/#insight-measuring-time","text":"This document explains the <time> tag. It is how Flame calculates where a clip sits on a timeline and how long it lasts. Target Audience: Novice programmers interested in timecodes and duration.","title":"Insight: Measuring Time ()"},{"location":"insight/openclip_api/insight-open_clip_xml_time/#1-how-is-time-measured-in-flame","text":"In digital video, time isn't just \"minutes and seconds.\" It's a combination of two things: 1. A Count: How many frames (samples) are there? 2. A Speed: How fast do those frames play?","title":"1. How is Time measured in Flame?"},{"location":"insight/openclip_api/insight-open_clip_xml_time/#2-the-anatomy-of-the-time-tag","text":"The <time> tag combines these two parts: <nbTicks> : The number of \"Ticks\" or Frames. (e.g., 240 frames). <rate> : The speed (e.g., 24 frames per second). <dropMode> : For certain broadcast standards (like NTSC), you might need \"Drop Frame\" ( DF ) or \"Non-Drop Frame\" ( NDF ) mode to keep the clock accurate.","title":"2. The Anatomy of the &lt;time&gt; tag"},{"location":"insight/openclip_api/insight-open_clip_xml_time/#3-calculating-seconds","text":"To find out how many seconds a clip is, Flame does a simple math problem: nbTicks divided by rate = seconds Example: 48 frames / 24 fps = 2 seconds .","title":"3. Calculating Seconds"},{"location":"insight/openclip_api/insight-open_clip_xml_time/#4-why-is-this-useful","text":"Flexibility: You can define time in frames, or you can get extremely precise using fractional rates (like 24000/1001 ). Communication: It allows the Open Clip to speak the \"Language of Timecode,\" which is essential for editors who need to know exactly which hour, minute, and second a shot belongs to.","title":"4. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_time/#5-key-takeaway-for-beginners","text":"Time in an Open Clip is a Calculation . The <time> tag gives Flame the two ingredients it needs (Count and Speed) to correctly place your media on the timeline.","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_track/","text":"Insight: Organizing Channels ( ) This document explains the <track> tag. It is used to separate different streams of data\u2014like Video and Audio\u2014inside a single Open Clip. Target Audience: Novice programmers interested in multi-channel media. 1. What is a Track? In Flame, a clip isn't just a movie; it's a collection of channels. The <track> tag allows you to define these channels individually. Common examples include: - A Video track. - An Audio track (you can have many of these). - A Matte (Alpha) track. - A Layer from a Photoshop or OpenEXR file. 2. Key Attributes of a Track uid (Unique ID) : Every track must have a name that makes it unique (e.g., \"t0\", \"audio_left\", \"Beauty_Pass\"). <trackType> : Usually video or audio . <feeds> : This is where the actual media links live for this specific track. 3. Advanced Overrides Normally, a track is as long as the movie file it points to. But you can use the <track> tag to force a specific timing: <startTimecode> : You can tell Track 1 to start at 01:00:00:00 even if the file itself starts at zero. <duration> : You can make a track appear longer or shorter than the physical media. If you make it longer, Flame will automatically show a \"No Media\" slate for the extra time. 4. Why use multiple tracks? Imagine a 3D artist renders a scene. They give you one OpenEXR file that contains the \"Beauty\" pass, a \"Shadow\" pass, and a \"Reflection\" pass. By using three <track> tags in your Open Clip, Flame will see these as three separate, perfectly synced layers that you can edit independently! 5. Key Takeaway for Beginners The <track> tag is like a \"Channel Strip\" on a mixer. It doesn't hold the media itself (that's the job of the feed ), but it organizes the media into a logical stream that Flame can play back and edit.","title":"Insight: Organizing Channels ()"},{"location":"insight/openclip_api/insight-open_clip_xml_track/#insight-organizing-channels","text":"This document explains the <track> tag. It is used to separate different streams of data\u2014like Video and Audio\u2014inside a single Open Clip. Target Audience: Novice programmers interested in multi-channel media.","title":"Insight: Organizing Channels ()"},{"location":"insight/openclip_api/insight-open_clip_xml_track/#1-what-is-a-track","text":"In Flame, a clip isn't just a movie; it's a collection of channels. The <track> tag allows you to define these channels individually. Common examples include: - A Video track. - An Audio track (you can have many of these). - A Matte (Alpha) track. - A Layer from a Photoshop or OpenEXR file.","title":"1. What is a Track?"},{"location":"insight/openclip_api/insight-open_clip_xml_track/#2-key-attributes-of-a-track","text":"uid (Unique ID) : Every track must have a name that makes it unique (e.g., \"t0\", \"audio_left\", \"Beauty_Pass\"). <trackType> : Usually video or audio . <feeds> : This is where the actual media links live for this specific track.","title":"2. Key Attributes of a Track"},{"location":"insight/openclip_api/insight-open_clip_xml_track/#3-advanced-overrides","text":"Normally, a track is as long as the movie file it points to. But you can use the <track> tag to force a specific timing: <startTimecode> : You can tell Track 1 to start at 01:00:00:00 even if the file itself starts at zero. <duration> : You can make a track appear longer or shorter than the physical media. If you make it longer, Flame will automatically show a \"No Media\" slate for the extra time.","title":"3. Advanced Overrides"},{"location":"insight/openclip_api/insight-open_clip_xml_track/#4-why-use-multiple-tracks","text":"Imagine a 3D artist renders a scene. They give you one OpenEXR file that contains the \"Beauty\" pass, a \"Shadow\" pass, and a \"Reflection\" pass. By using three <track> tags in your Open Clip, Flame will see these as three separate, perfectly synced layers that you can edit independently!","title":"4. Why use multiple tracks?"},{"location":"insight/openclip_api/insight-open_clip_xml_track/#5-key-takeaway-for-beginners","text":"The <track> tag is like a \"Channel Strip\" on a mixer. It doesn't hold the media itself (that's the job of the feed ), but it organizes the media into a logical stream that Flame can play back and edit.","title":"5. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_tracks/","text":"Insight: The Channel Manager ( ) This document explains the <tracks> tag (with an 's'). It is the part of the Open Clip that organizes all the different \"Layers\" or \"Channels\" of your media. Target Audience: Novice programmers interested in multi-layer media organization. 1. What is the <tracks> tag? Think of <tracks> as the Backbone of the clip. It is a container that holds all the individual <track> tags (the specific video, audio, or metadata channels). 2. Global Track Management While each individual track has its own settings, the <tracks> tag allows you to see the \"Big Picture\" of what the clip is made of. - Does it have 1 video and 2 audio channels? - Does it have 50 layers from a complex 3D render? All of those will be listed neatly inside this one tag. 3. Why is this useful? It allows for Multi-Channel Workflows . By grouping everything inside <tracks> , you ensure that Flame sees all the components of a shot together. For example, if you have a \"Beauty\" layer, a \"Depth\" layer, and an \"Ambient Occlusion\" layer, they all live inside the <tracks> container, perfectly synced and ready for compositing. 4. Key Takeaway for Beginners The <tracks> tag is the \"Master List\" of every channel in your clip. It provides the high-level structure that allows Flame to understand that several different media streams are actually parts of the same single object.","title":"Insight: The Channel Manager ()"},{"location":"insight/openclip_api/insight-open_clip_xml_tracks/#insight-the-channel-manager","text":"This document explains the <tracks> tag (with an 's'). It is the part of the Open Clip that organizes all the different \"Layers\" or \"Channels\" of your media. Target Audience: Novice programmers interested in multi-layer media organization.","title":"Insight: The Channel Manager ()"},{"location":"insight/openclip_api/insight-open_clip_xml_tracks/#1-what-is-the-tracks-tag","text":"Think of <tracks> as the Backbone of the clip. It is a container that holds all the individual <track> tags (the specific video, audio, or metadata channels).","title":"1. What is the &lt;tracks&gt; tag?"},{"location":"insight/openclip_api/insight-open_clip_xml_tracks/#2-global-track-management","text":"While each individual track has its own settings, the <tracks> tag allows you to see the \"Big Picture\" of what the clip is made of. - Does it have 1 video and 2 audio channels? - Does it have 50 layers from a complex 3D render? All of those will be listed neatly inside this one tag.","title":"2. Global Track Management"},{"location":"insight/openclip_api/insight-open_clip_xml_tracks/#3-why-is-this-useful","text":"It allows for Multi-Channel Workflows . By grouping everything inside <tracks> , you ensure that Flame sees all the components of a shot together. For example, if you have a \"Beauty\" layer, a \"Depth\" layer, and an \"Ambient Occlusion\" layer, they all live inside the <tracks> container, perfectly synced and ready for compositing.","title":"3. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_tracks/#4-key-takeaway-for-beginners","text":"The <tracks> tag is the \"Master List\" of every channel in your clip. It provides the high-level structure that allows Flame to understand that several different media streams are actually parts of the same single object.","title":"4. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_version/","text":"Insight: Version Metadata ( ) This document explains the <version> tag. It is used to store information about a specific iteration of your work\u2014like \"V1\" or \"Final_Master.\" Target Audience: Novice programmers interested in creative workflow metadata. 1. What is a Version? In filmmaking, we never get it right the first time. We render \"Version 1\", then \"Version 2,\" and so on. The <version> tag allows you to add specific Notes to those iterations. 2. Key Information inside a Version uid : The unique link (like \"v1\") that connects this metadata to the actual media in the tracks. <name> : A friendly name for the version (e.g., \"Roto Version\"). <comment> : A place for instructions (e.g., \"Added more blur to the edges\"). <creationDate> : When this version was rendered. 3. Why is this useful? Communication: An artist can see exactly why a new version was created by looking at the comments inside the Open Clip. Audit Trail: You can keep track of who worked on a shot and when it was finished. Pipeline Logic: You can use the creationDate to automatically show the most recent render to the artist. 4. Key Takeaway for Beginners The <version> tag is the \"Artist's Notebook\" for a clip. While other tags focus on technical things like file paths and frame rates, the <version> tag is where you store the human history of the shot.","title":"Insight: Version Metadata ()"},{"location":"insight/openclip_api/insight-open_clip_xml_version/#insight-version-metadata","text":"This document explains the <version> tag. It is used to store information about a specific iteration of your work\u2014like \"V1\" or \"Final_Master.\" Target Audience: Novice programmers interested in creative workflow metadata.","title":"Insight: Version Metadata ()"},{"location":"insight/openclip_api/insight-open_clip_xml_version/#1-what-is-a-version","text":"In filmmaking, we never get it right the first time. We render \"Version 1\", then \"Version 2,\" and so on. The <version> tag allows you to add specific Notes to those iterations.","title":"1. What is a Version?"},{"location":"insight/openclip_api/insight-open_clip_xml_version/#2-key-information-inside-a-version","text":"uid : The unique link (like \"v1\") that connects this metadata to the actual media in the tracks. <name> : A friendly name for the version (e.g., \"Roto Version\"). <comment> : A place for instructions (e.g., \"Added more blur to the edges\"). <creationDate> : When this version was rendered.","title":"2. Key Information inside a Version"},{"location":"insight/openclip_api/insight-open_clip_xml_version/#3-why-is-this-useful","text":"Communication: An artist can see exactly why a new version was created by looking at the comments inside the Open Clip. Audit Trail: You can keep track of who worked on a shot and when it was finished. Pipeline Logic: You can use the creationDate to automatically show the most recent render to the artist.","title":"3. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_version/#4-key-takeaway-for-beginners","text":"The <version> tag is the \"Artist's Notebook\" for a clip. While other tags focus on technical things like file paths and frame rates, the <version> tag is where you store the human history of the shot.","title":"4. Key Takeaway for Beginners"},{"location":"insight/openclip_api/insight-open_clip_xml_versions/","text":"Insight: The Master Version List ( ) This document explains the <versions> tag. It is the \"Master Registry\" that tells Flame exactly which versions exist for the entire clip. Target Audience: Novice programmers interested in high-level media organization. 1. The Global List While each Track has a list of feeds, the Clip needs one central list that summarizes every version available across the whole project. That is the <versions> tag. It usually looks like this: <versions currentVersion=\"v2\"> <version uid=\"v1\"/> <version uid=\"v2\"/> <version uid=\"v3\"/> </versions> 2. How it Connects Everything The uid inside a <version> tag acts as a Link . When you switch the clip to \"v2\" in Flame, the software looks at this list and then goes to every track and says: \"Find me the feed that also has the ID 'v2'.\" 3. Why is this useful? Consistency: It ensures that \"Version 2\" means the same thing for the Video track as it does for the Audio track. Easy UI: Flame uses this list to build the dropdown menu that the artist uses to pick a version. Safety: It prevents Flame from trying to load a version that doesn't actually exist. 4. Key Takeaway for Beginners The <versions> tag is the \"Global Table of Contents\" for your clip. It doesn't contain links to files; it just defines the \"Names\" of the versions so that the Tracks can stay in sync when an artist switches between them.","title":"Insight: The Master Version List ()"},{"location":"insight/openclip_api/insight-open_clip_xml_versions/#insight-the-master-version-list","text":"This document explains the <versions> tag. It is the \"Master Registry\" that tells Flame exactly which versions exist for the entire clip. Target Audience: Novice programmers interested in high-level media organization.","title":"Insight: The Master Version List ()"},{"location":"insight/openclip_api/insight-open_clip_xml_versions/#1-the-global-list","text":"While each Track has a list of feeds, the Clip needs one central list that summarizes every version available across the whole project. That is the <versions> tag. It usually looks like this: <versions currentVersion=\"v2\"> <version uid=\"v1\"/> <version uid=\"v2\"/> <version uid=\"v3\"/> </versions>","title":"1. The Global List"},{"location":"insight/openclip_api/insight-open_clip_xml_versions/#2-how-it-connects-everything","text":"The uid inside a <version> tag acts as a Link . When you switch the clip to \"v2\" in Flame, the software looks at this list and then goes to every track and says: \"Find me the feed that also has the ID 'v2'.\"","title":"2. How it Connects Everything"},{"location":"insight/openclip_api/insight-open_clip_xml_versions/#3-why-is-this-useful","text":"Consistency: It ensures that \"Version 2\" means the same thing for the Video track as it does for the Audio track. Easy UI: Flame uses this list to build the dropdown menu that the artist uses to pick a version. Safety: It prevents Flame from trying to load a version that doesn't actually exist.","title":"3. Why is this useful?"},{"location":"insight/openclip_api/insight-open_clip_xml_versions/#4-key-takeaway-for-beginners","text":"The <versions> tag is the \"Global Table of Contents\" for your clip. It doesn't contain links to files; it just defines the \"Names\" of the versions so that the Tracks can stay in sync when an artist switches between them.","title":"4. Key Takeaway for Beginners"},{"location":"insight/shader_builder_api/insight-lightbox_examples/","text":"Insight: Lightbox Shader Examples This document provides a summary of the official Lightbox examples provided by Autodesk. These are the best place to start if you want to learn by \"deconstructing\" existing code. Location in Flame: /opt/Autodesk/presets/<version>/action/lightbox/EXAMPLES 1. The Learning Path Level 1: The Basics LightboxBasics.glsl : The simplest possible Lightbox. It just multiplies the color by a \"Gain\" value. Use this to see the minimum code required to make a Lightbox work. Level 2: Replicating Flame SimpleLight.glsl : Shows you how to manually recreate the math of a standard \"Point Light.\" It's a great lesson in 3D math and how Flame calculates brightness based on distance. Level 3: Interaction with 3D Space LightboxAPISimple.glsl : Shows how to ask Flame for information about the 3D scene, like the position of the light and the position of the pixels (vertices). This allows for \"Decay\" effects where the light gets weaker as it gets further away. Level 4: Advanced Material Science PhysicallyBasedIBL and GGXMaterial : These are complex shaders. They use \"Physically Based Rendering\" (PBR) to make surfaces look like real metal, plastic, or glass. They show how a Lightbox can completely change the \"look\" of an object's material. 2. Key Code Snippets to Look For When you open these files, look for these specific API calls: adsk_getLightPosition() : Where is the light? adsk_getVertexPosition() : Where is the object? adsk_rgb2yuv() : A built-in helper to change color spaces quickly. 3. How to use these Examples Don't try to write a complex shader from scratch. 1. Copy an example that is close to what you want. 2. Modify one or two lines of code. 3. Run shader_builder to see if it still works. 4. Load it into Action to see the result. 4. Key Takeaway for Beginners The EXAMPLES folder is your \"Cheat Sheet.\" Most professional shaders are just variations of these basic patterns. If you want to build a tool that relights a scene, start with SimpleLight and build from there!","title":"Insight: Lightbox Shader Examples"},{"location":"insight/shader_builder_api/insight-lightbox_examples/#insight-lightbox-shader-examples","text":"This document provides a summary of the official Lightbox examples provided by Autodesk. These are the best place to start if you want to learn by \"deconstructing\" existing code. Location in Flame: /opt/Autodesk/presets/<version>/action/lightbox/EXAMPLES","title":"Insight: Lightbox Shader Examples"},{"location":"insight/shader_builder_api/insight-lightbox_examples/#1-the-learning-path","text":"","title":"1. The Learning Path"},{"location":"insight/shader_builder_api/insight-lightbox_examples/#level-1-the-basics","text":"LightboxBasics.glsl : The simplest possible Lightbox. It just multiplies the color by a \"Gain\" value. Use this to see the minimum code required to make a Lightbox work.","title":"Level 1: The Basics"},{"location":"insight/shader_builder_api/insight-lightbox_examples/#level-2-replicating-flame","text":"SimpleLight.glsl : Shows you how to manually recreate the math of a standard \"Point Light.\" It's a great lesson in 3D math and how Flame calculates brightness based on distance.","title":"Level 2: Replicating Flame"},{"location":"insight/shader_builder_api/insight-lightbox_examples/#level-3-interaction-with-3d-space","text":"LightboxAPISimple.glsl : Shows how to ask Flame for information about the 3D scene, like the position of the light and the position of the pixels (vertices). This allows for \"Decay\" effects where the light gets weaker as it gets further away.","title":"Level 3: Interaction with 3D Space"},{"location":"insight/shader_builder_api/insight-lightbox_examples/#level-4-advanced-material-science","text":"PhysicallyBasedIBL and GGXMaterial : These are complex shaders. They use \"Physically Based Rendering\" (PBR) to make surfaces look like real metal, plastic, or glass. They show how a Lightbox can completely change the \"look\" of an object's material.","title":"Level 4: Advanced Material Science"},{"location":"insight/shader_builder_api/insight-lightbox_examples/#2-key-code-snippets-to-look-for","text":"When you open these files, look for these specific API calls: adsk_getLightPosition() : Where is the light? adsk_getVertexPosition() : Where is the object? adsk_rgb2yuv() : A built-in helper to change color spaces quickly.","title":"2. Key Code Snippets to Look For"},{"location":"insight/shader_builder_api/insight-lightbox_examples/#3-how-to-use-these-examples","text":"Don't try to write a complex shader from scratch. 1. Copy an example that is close to what you want. 2. Modify one or two lines of code. 3. Run shader_builder to see if it still works. 4. Load it into Action to see the result.","title":"3. How to use these Examples"},{"location":"insight/shader_builder_api/insight-lightbox_examples/#4-key-takeaway-for-beginners","text":"The EXAMPLES folder is your \"Cheat Sheet.\" Most professional shaders are just variations of these basic patterns. If you want to build a tool that relights a scene, start with SimpleLight and build from there!","title":"4. Key Takeaway for Beginners"},{"location":"insight/shader_builder_api/insight-lightbox_shader_builder/","text":"Insight: Creating Lightbox Shaders This document explains the Lightbox framework in Autodesk Flame. It shows how you can write your own 3D lighting effects using GLSL (OpenGL Shading Language). Target Audience: Novice programmers and technical artists interested in 3D compositing and GLSL. 1. What is a Lightbox? A Lightbox is a custom shader that lives inside Action (Flame's 3D engine). Think of it as a \"Smart Filter\" for a light. Usually, a light just makes things brighter. A Lightbox can make a light do anything \u2014like inverting colors, adding texture, or changing the way a surface reacts to distance. 2. The Basic Structure A Lightbox shader is a small piece of code written in GLSL. It always has a specific function: vec4 adskUID_lightbox(vec4 source) { // 'source' is the pixel color before this light hits it. // Your code goes here... return source; } adskUID_ : This prefix is mandatory. It stands for \"Unique ID\" and prevents your shader from clashing with others when multiple Lightboxes are loaded. source : This represents the color and transparency (RGBA) of the object being lit. 3. Writing and Testing Code: Write your shader in a text editor and save it as .glsl . Validate: Use the shader_builder utility in your terminal: shader_builder -l -x my_shader.glsl -l tells it this is a Lightbox . -x tells it to generate an XML file (this creates the buttons and sliders in Flame). Fix: If there are errors (like a missing ; ), shader_builder will tell you exactly which line is broken. 4. Key Concepts to Remember Pre vs. Post: In Flame, a Lightbox can run before the light hits the object (to modify the surface) or after the light (to modify the final lit result). The Alpha Rule: Always return a valid Alpha ( source.a ). If you set Alpha to 0, the object will disappear! Namespacing: You must use the adskUID_ prefix for every variable you create (like adskUID_gain ). If you don't, you can only load one copy of your shader at a time. 5. Why use Lightbox instead of Matchbox? Matchbox is for 2D image processing (like blurs or color corrections). Lightbox is for 3D interactions. It has access to things like the position of the light, the direction of the surface (normals), and the 3D depth of the scene. 6. Key Takeaway for Beginners Lightbox allows you to \"hijack\" Flame's 3D lighting pipeline. Whether you want to make a light that only affects blue objects or a light that adds a custom glow pattern, the adskUID_lightbox function is where you build that logic.","title":"Insight: Creating Lightbox Shaders"},{"location":"insight/shader_builder_api/insight-lightbox_shader_builder/#insight-creating-lightbox-shaders","text":"This document explains the Lightbox framework in Autodesk Flame. It shows how you can write your own 3D lighting effects using GLSL (OpenGL Shading Language). Target Audience: Novice programmers and technical artists interested in 3D compositing and GLSL.","title":"Insight: Creating Lightbox Shaders"},{"location":"insight/shader_builder_api/insight-lightbox_shader_builder/#1-what-is-a-lightbox","text":"A Lightbox is a custom shader that lives inside Action (Flame's 3D engine). Think of it as a \"Smart Filter\" for a light. Usually, a light just makes things brighter. A Lightbox can make a light do anything \u2014like inverting colors, adding texture, or changing the way a surface reacts to distance.","title":"1. What is a Lightbox?"},{"location":"insight/shader_builder_api/insight-lightbox_shader_builder/#2-the-basic-structure","text":"A Lightbox shader is a small piece of code written in GLSL. It always has a specific function: vec4 adskUID_lightbox(vec4 source) { // 'source' is the pixel color before this light hits it. // Your code goes here... return source; } adskUID_ : This prefix is mandatory. It stands for \"Unique ID\" and prevents your shader from clashing with others when multiple Lightboxes are loaded. source : This represents the color and transparency (RGBA) of the object being lit.","title":"2. The Basic Structure"},{"location":"insight/shader_builder_api/insight-lightbox_shader_builder/#3-writing-and-testing","text":"Code: Write your shader in a text editor and save it as .glsl . Validate: Use the shader_builder utility in your terminal: shader_builder -l -x my_shader.glsl -l tells it this is a Lightbox . -x tells it to generate an XML file (this creates the buttons and sliders in Flame). Fix: If there are errors (like a missing ; ), shader_builder will tell you exactly which line is broken.","title":"3. Writing and Testing"},{"location":"insight/shader_builder_api/insight-lightbox_shader_builder/#4-key-concepts-to-remember","text":"Pre vs. Post: In Flame, a Lightbox can run before the light hits the object (to modify the surface) or after the light (to modify the final lit result). The Alpha Rule: Always return a valid Alpha ( source.a ). If you set Alpha to 0, the object will disappear! Namespacing: You must use the adskUID_ prefix for every variable you create (like adskUID_gain ). If you don't, you can only load one copy of your shader at a time.","title":"4. Key Concepts to Remember"},{"location":"insight/shader_builder_api/insight-lightbox_shader_builder/#5-why-use-lightbox-instead-of-matchbox","text":"Matchbox is for 2D image processing (like blurs or color corrections). Lightbox is for 3D interactions. It has access to things like the position of the light, the direction of the surface (normals), and the 3D depth of the scene.","title":"5. Why use Lightbox instead of Matchbox?"},{"location":"insight/shader_builder_api/insight-lightbox_shader_builder/#6-key-takeaway-for-beginners","text":"Lightbox allows you to \"hijack\" Flame's 3D lighting pipeline. Whether you want to make a light that only affects blue objects or a light that adds a custom glow pattern, the adskUID_lightbox function is where you build that logic.","title":"6. Key Takeaway for Beginners"},{"location":"insight/shader_builder_api/insight-matchbox_examples/","text":"Insight: Matchbox Shader Examples This document provides a summary of the official Matchbox examples provided by Autodesk. These files demonstrate the wide variety of technical tricks you can use in your own shaders. Location in Flame: /opt/Autodesk/presets/<version>/matchbox/shaders/EXAMPLES/ 1. UI and Interaction Examples Curves.glsl : Shows how to add a graph editor to your node. This is perfect for custom color grading or complex easing. ColourWheel.glsl : Shows how to use the standard \"Lift/Gamma/Gain\" style wheels in your UI. ConditionalUI.glsl : Shows how to make a button appear or disappear based on another setting (e.g., hiding a \"Size\" slider when \"Auto-Scale\" is checked). 2. Technical Feature Examples Accumulate.glsl : Shows how to \"remember\" the previous frame. This is essential for trails, echoes, or temporal noise reduction. TemporalSampling.glsl : Shows how to look at the frames immediately before and after the current one. Mipmaps.glsl : Shows how to use Flame's built-in \"low-res\" versions of an image to create very fast, high-quality blurs. 3. Real-World Tool Examples TransitionShader.glsl : A template for building your own timeline transitions (like wipes, dissolves, or glitched cuts). DecodeZDepthHQ.glsl : An advanced example that shows how to take technical data from Action (depth information) and use it to build a 3D-aware 2D effect (like Depth of Field). ImagePosition/Rotation/Scaling : These show the core math for basic image transforms. If you've ever wondered how a computer \"moves\" an image, look at these files. 4. How to use these Examples The EXAMPLES folder is a \"Library of Parts.\" - Need a blur? Check PyramidBlur . - Need a dropdown list? Check BuildList . - Need to blend two images? Check Blending . Pro Tip: Don't try to memorize the code. Just remember that these examples exist, and copy-paste the sections you need into your own project! 5. Key Takeaway for Beginners The strength of Matchbox is its versatility . These examples prove that you can build everything from a simple color filter to a complex 3D-aware compositing tool. If you can't figure out how to do something in GLSL, there is probably an example in this folder that shows you the way.","title":"Insight: Matchbox Shader Examples"},{"location":"insight/shader_builder_api/insight-matchbox_examples/#insight-matchbox-shader-examples","text":"This document provides a summary of the official Matchbox examples provided by Autodesk. These files demonstrate the wide variety of technical tricks you can use in your own shaders. Location in Flame: /opt/Autodesk/presets/<version>/matchbox/shaders/EXAMPLES/","title":"Insight: Matchbox Shader Examples"},{"location":"insight/shader_builder_api/insight-matchbox_examples/#1-ui-and-interaction-examples","text":"Curves.glsl : Shows how to add a graph editor to your node. This is perfect for custom color grading or complex easing. ColourWheel.glsl : Shows how to use the standard \"Lift/Gamma/Gain\" style wheels in your UI. ConditionalUI.glsl : Shows how to make a button appear or disappear based on another setting (e.g., hiding a \"Size\" slider when \"Auto-Scale\" is checked).","title":"1. UI and Interaction Examples"},{"location":"insight/shader_builder_api/insight-matchbox_examples/#2-technical-feature-examples","text":"Accumulate.glsl : Shows how to \"remember\" the previous frame. This is essential for trails, echoes, or temporal noise reduction. TemporalSampling.glsl : Shows how to look at the frames immediately before and after the current one. Mipmaps.glsl : Shows how to use Flame's built-in \"low-res\" versions of an image to create very fast, high-quality blurs.","title":"2. Technical Feature Examples"},{"location":"insight/shader_builder_api/insight-matchbox_examples/#3-real-world-tool-examples","text":"TransitionShader.glsl : A template for building your own timeline transitions (like wipes, dissolves, or glitched cuts). DecodeZDepthHQ.glsl : An advanced example that shows how to take technical data from Action (depth information) and use it to build a 3D-aware 2D effect (like Depth of Field). ImagePosition/Rotation/Scaling : These show the core math for basic image transforms. If you've ever wondered how a computer \"moves\" an image, look at these files.","title":"3. Real-World Tool Examples"},{"location":"insight/shader_builder_api/insight-matchbox_examples/#4-how-to-use-these-examples","text":"The EXAMPLES folder is a \"Library of Parts.\" - Need a blur? Check PyramidBlur . - Need a dropdown list? Check BuildList . - Need to blend two images? Check Blending . Pro Tip: Don't try to memorize the code. Just remember that these examples exist, and copy-paste the sections you need into your own project!","title":"4. How to use these Examples"},{"location":"insight/shader_builder_api/insight-matchbox_examples/#5-key-takeaway-for-beginners","text":"The strength of Matchbox is its versatility . These examples prove that you can build everything from a simple color filter to a complex 3D-aware compositing tool. If you can't figure out how to do something in GLSL, there is probably an example in this folder that shows you the way.","title":"5. Key Takeaway for Beginners"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/","text":"Insight: Creating Matchbox Shaders This document explains the Matchbox framework in Autodesk Flame. It is the most common way to build custom 2D image effects (like blurs, color corrections, or distortions) using GLSL. Target Audience: Novice programmers and technical artists interested in image processing and 2D compositing. 1. What is a Matchbox? A Matchbox is a standalone image processor. Unlike a Lightbox (which lives inside 3D space), a Matchbox takes an input image, does some math to every pixel, and spits out a new result. You can use Matchboxes in: - Batch : As a node in your compositing tree. - Timeline : As a transition between two clips. - Action : As a post-processing filter. 2. The Basic Structure A Matchbox shader is a GLSL file. Unlike Lightbox, it uses the standard main() function: uniform float adsk_result_w, adsk_result_h; uniform sampler2D input1; void main() { // 1. Get the current pixel's coordinate vec2 coords = gl_FragCoord.xy / vec2(adsk_result_w, adsk_result_h); // 2. Read the color from the input vec4 color = texture2D(input1, coords); // 3. Output the final color gl_FragColor = color; } adsk_result_w/h : These are built-in variables that Flame fills with the width and height of your output. input1 : This represents the first image socket on the node. 3. Key Features A. Multiple Inputs A Matchbox can have up to 6 input sockets. You can define what these sockets are for (Front, Back, Matte) in your XML file so they are color-coded correctly in Batch. B. Multi-pass Rendering If your effect is complex (like a heavy blur), you can split it into multiple \"Passes.\" You write several GLSL files (e.g., Blur.1.glsl , Blur.2.glsl ), and Flame runs them in sequence. C. Selective FX This is a specialized Matchbox that can interact with Flame's \"Selective\" node. It allows you to isolate a specific area (like a person's face) and apply the effect only there, with a perfect soft edge. 4. Writing and Testing Code: Write your GLSL and save it. Validate: Run shader_builder -m -x my_shader.glsl . -m tells it this is a Matchbox . Package: Use shader_builder -m -p my_shader.glsl to create an encrypted .mx file for sharing. 5. Why use Matchbox? Custom Filters: Build a specific look that doesn't exist in Flame's standard library. Performance: GLSL runs on the GPU, making it extremely fast for complex math. Universal: Once you build a Matchbox, you can use it anywhere in the Flame family (Flame, Flare, Flame Assist). 6. Key Takeaway for Beginners Matchbox is your \"Custom Node Factory.\" If you can imagine a mathematical formula for how a pixel should change based on its color or position, you can turn that into a Matchbox tool.","title":"Insight: Creating Matchbox Shaders"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/#insight-creating-matchbox-shaders","text":"This document explains the Matchbox framework in Autodesk Flame. It is the most common way to build custom 2D image effects (like blurs, color corrections, or distortions) using GLSL. Target Audience: Novice programmers and technical artists interested in image processing and 2D compositing.","title":"Insight: Creating Matchbox Shaders"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/#1-what-is-a-matchbox","text":"A Matchbox is a standalone image processor. Unlike a Lightbox (which lives inside 3D space), a Matchbox takes an input image, does some math to every pixel, and spits out a new result. You can use Matchboxes in: - Batch : As a node in your compositing tree. - Timeline : As a transition between two clips. - Action : As a post-processing filter.","title":"1. What is a Matchbox?"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/#2-the-basic-structure","text":"A Matchbox shader is a GLSL file. Unlike Lightbox, it uses the standard main() function: uniform float adsk_result_w, adsk_result_h; uniform sampler2D input1; void main() { // 1. Get the current pixel's coordinate vec2 coords = gl_FragCoord.xy / vec2(adsk_result_w, adsk_result_h); // 2. Read the color from the input vec4 color = texture2D(input1, coords); // 3. Output the final color gl_FragColor = color; } adsk_result_w/h : These are built-in variables that Flame fills with the width and height of your output. input1 : This represents the first image socket on the node.","title":"2. The Basic Structure"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/#3-key-features","text":"","title":"3. Key Features"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/#a-multiple-inputs","text":"A Matchbox can have up to 6 input sockets. You can define what these sockets are for (Front, Back, Matte) in your XML file so they are color-coded correctly in Batch.","title":"A. Multiple Inputs"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/#b-multi-pass-rendering","text":"If your effect is complex (like a heavy blur), you can split it into multiple \"Passes.\" You write several GLSL files (e.g., Blur.1.glsl , Blur.2.glsl ), and Flame runs them in sequence.","title":"B. Multi-pass Rendering"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/#c-selective-fx","text":"This is a specialized Matchbox that can interact with Flame's \"Selective\" node. It allows you to isolate a specific area (like a person's face) and apply the effect only there, with a perfect soft edge.","title":"C. Selective FX"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/#4-writing-and-testing","text":"Code: Write your GLSL and save it. Validate: Run shader_builder -m -x my_shader.glsl . -m tells it this is a Matchbox . Package: Use shader_builder -m -p my_shader.glsl to create an encrypted .mx file for sharing.","title":"4. Writing and Testing"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/#5-why-use-matchbox","text":"Custom Filters: Build a specific look that doesn't exist in Flame's standard library. Performance: GLSL runs on the GPU, making it extremely fast for complex math. Universal: Once you build a Matchbox, you can use it anywhere in the Flame family (Flame, Flare, Flame Assist).","title":"5. Why use Matchbox?"},{"location":"insight/shader_builder_api/insight-matchbox_shader_builder/#6-key-takeaway-for-beginners","text":"Matchbox is your \"Custom Node Factory.\" If you can imagine a mathematical formula for how a pixel should change based on its color or position, you can turn that into a Matchbox tool.","title":"6. Key Takeaway for Beginners"},{"location":"insight/shader_builder_api/insight-shader_api/","text":"Insight: The Shader API (Helper Functions) This document explains the built-in Shader API . These are special \"shortcuts\" (functions) that Autodesk provides to help you write complex shaders without doing all the hard math yourself. Target Audience: Novice programmers learning GLSL syntax. 1. What is the Shader API? When you write a shader for Flame, you don't have to calculate things like \"How bright is this light?\" or \"Convert this color to Grayscale\" from scratch. Flame has a library of pre-written functions you can \"call\" in your code. 2. Lighting & 3D Helpers (Lightbox) These are for interacting with the 3D scene in Action: - adsk_getLightPosition() : Tells you exactly where the light is in 3D space. - adsk_getNormal() : Tells you which way the surface of an object is facing. - adsk_getLightColour() : Tells you the color and brightness of the light. - adsk_getVertexPosition() : Tells you the 3D coordinate of the pixel you are currently coloring. 3. Color Space Helpers (Matchbox & Lightbox) Moving between different color \"languages\" is easy with these functions: - adsk_rgb2hsv() : Converts standard Red/Green/Blue into Hue/Saturation/Value (great for making \"Hue Shift\" tools). - adsk_scene2log() : Converts linear light into \"Log\" (Cineon) space. - adsk_getLuminance() : Quickly turns a color image into a perfect black-and-white (grayscale) image. 4. Blending Helpers Instead of writing complex math for \"Overlay\" or \"Screen\" modes, you can just use: - adsk_getBlendedValue(blendType, foreground, background) By changing the blendType number (e.g., 0 for Add, 2 for Multiply), you can replicate any Photoshop-style blending mode. 5. Built-in Variables (Uniforms) Flame also automatically gives you these \"Magic Variables\": - adsk_time : The current frame number (useful for making things animate or flicker). - adsk_result_w / h : The width and height of your image. 6. Key Takeaway for Beginners The Shader API is like a \"Toolbox.\" Before you try to write a complex mathematical formula, check the API documentation first. There is a high chance that Autodesk has already written a one-line function that does exactly what you need!","title":"Insight: The Shader API (Helper Functions)"},{"location":"insight/shader_builder_api/insight-shader_api/#insight-the-shader-api-helper-functions","text":"This document explains the built-in Shader API . These are special \"shortcuts\" (functions) that Autodesk provides to help you write complex shaders without doing all the hard math yourself. Target Audience: Novice programmers learning GLSL syntax.","title":"Insight: The Shader API (Helper Functions)"},{"location":"insight/shader_builder_api/insight-shader_api/#1-what-is-the-shader-api","text":"When you write a shader for Flame, you don't have to calculate things like \"How bright is this light?\" or \"Convert this color to Grayscale\" from scratch. Flame has a library of pre-written functions you can \"call\" in your code.","title":"1. What is the Shader API?"},{"location":"insight/shader_builder_api/insight-shader_api/#2-lighting-3d-helpers-lightbox","text":"These are for interacting with the 3D scene in Action: - adsk_getLightPosition() : Tells you exactly where the light is in 3D space. - adsk_getNormal() : Tells you which way the surface of an object is facing. - adsk_getLightColour() : Tells you the color and brightness of the light. - adsk_getVertexPosition() : Tells you the 3D coordinate of the pixel you are currently coloring.","title":"2. Lighting &amp; 3D Helpers (Lightbox)"},{"location":"insight/shader_builder_api/insight-shader_api/#3-color-space-helpers-matchbox-lightbox","text":"Moving between different color \"languages\" is easy with these functions: - adsk_rgb2hsv() : Converts standard Red/Green/Blue into Hue/Saturation/Value (great for making \"Hue Shift\" tools). - adsk_scene2log() : Converts linear light into \"Log\" (Cineon) space. - adsk_getLuminance() : Quickly turns a color image into a perfect black-and-white (grayscale) image.","title":"3. Color Space Helpers (Matchbox &amp; Lightbox)"},{"location":"insight/shader_builder_api/insight-shader_api/#4-blending-helpers","text":"Instead of writing complex math for \"Overlay\" or \"Screen\" modes, you can just use: - adsk_getBlendedValue(blendType, foreground, background) By changing the blendType number (e.g., 0 for Add, 2 for Multiply), you can replicate any Photoshop-style blending mode.","title":"4. Blending Helpers"},{"location":"insight/shader_builder_api/insight-shader_api/#5-built-in-variables-uniforms","text":"Flame also automatically gives you these \"Magic Variables\": - adsk_time : The current frame number (useful for making things animate or flicker). - adsk_result_w / h : The width and height of your image.","title":"5. Built-in Variables (Uniforms)"},{"location":"insight/shader_builder_api/insight-shader_api/#6-key-takeaway-for-beginners","text":"The Shader API is like a \"Toolbox.\" Before you try to write a complex mathematical formula, check the API documentation first. There is a high chance that Autodesk has already written a one-line function that does exactly what you need!","title":"6. Key Takeaway for Beginners"},{"location":"insight/shader_builder_api/insight-shader_builder_overview/","text":"Insight: Shader Builder Overview (High-Level) This document provides a birds-eye view of the Shader Builder workflow. It is the master process for turning raw code into a professional tool for Autodesk Flame. Target Audience: Novice programmers and technical artists. 1. The Workflow in 5 Steps Creating a custom tool follows a specific sequence: Write: Create your graphics code in GLSL (The math of the effect). Generate: Use the shader_builder tool to create an XML file (The design of the buttons). Refine: Edit the XML to add better names, tooltips, and organized pages for your sliders. Preset: Open your shader in Flame, make a \"Cool Look,\" and save it as a Preset . Package: Use shader_builder again to encrypt your code into a single .mx (Matchbox) or .lx (Lightbox) file. 2. Matchbox vs. Lightbox Feature Matchbox Lightbox Dimension 2D (Flat Images) 3D (Inside Action) Main Function main() adskUID_lightbox() Location Batch, Timeline, Action Attached to a Light in Action Best For Blurs, CC, Distortions Relighting, Materials, 3D Glows 3. The Power of shader_builder shader_builder is a command-line utility. You use it in your terminal to: - Check for Errors: It tries to \"compile\" your code. If you forgot a semicolon, it will tell you exactly where. - Auto-UI: It looks at your variables and automatically builds a \"Best Guess\" user interface. - IP Protection: It encrypts your code so other people can use your tool without seeing your secret formulas. 4. Why build your own shaders? Unique Identity: Make your studio's work stand out with looks that no one else has. Speed: Custom nodes can combine 10 standard nodes into one single, fast button. Community: You can join sites like Logik Matchbook to download shaders from other professional artists around the world. 5. Key Takeaway for Beginners The Shader Builder API is the \"Secret Sauce\" of Autodesk Flame. It allows you to transform the software from a standard editing tool into a specialized, high-performance visual effects engine tailored exactly to your needs.","title":"Insight: Shader Builder Overview (High-Level)"},{"location":"insight/shader_builder_api/insight-shader_builder_overview/#insight-shader-builder-overview-high-level","text":"This document provides a birds-eye view of the Shader Builder workflow. It is the master process for turning raw code into a professional tool for Autodesk Flame. Target Audience: Novice programmers and technical artists.","title":"Insight: Shader Builder Overview (High-Level)"},{"location":"insight/shader_builder_api/insight-shader_builder_overview/#1-the-workflow-in-5-steps","text":"Creating a custom tool follows a specific sequence: Write: Create your graphics code in GLSL (The math of the effect). Generate: Use the shader_builder tool to create an XML file (The design of the buttons). Refine: Edit the XML to add better names, tooltips, and organized pages for your sliders. Preset: Open your shader in Flame, make a \"Cool Look,\" and save it as a Preset . Package: Use shader_builder again to encrypt your code into a single .mx (Matchbox) or .lx (Lightbox) file.","title":"1. The Workflow in 5 Steps"},{"location":"insight/shader_builder_api/insight-shader_builder_overview/#2-matchbox-vs-lightbox","text":"Feature Matchbox Lightbox Dimension 2D (Flat Images) 3D (Inside Action) Main Function main() adskUID_lightbox() Location Batch, Timeline, Action Attached to a Light in Action Best For Blurs, CC, Distortions Relighting, Materials, 3D Glows","title":"2. Matchbox vs. Lightbox"},{"location":"insight/shader_builder_api/insight-shader_builder_overview/#3-the-power-of-shader_builder","text":"shader_builder is a command-line utility. You use it in your terminal to: - Check for Errors: It tries to \"compile\" your code. If you forgot a semicolon, it will tell you exactly where. - Auto-UI: It looks at your variables and automatically builds a \"Best Guess\" user interface. - IP Protection: It encrypts your code so other people can use your tool without seeing your secret formulas.","title":"3. The Power of shader_builder"},{"location":"insight/shader_builder_api/insight-shader_builder_overview/#4-why-build-your-own-shaders","text":"Unique Identity: Make your studio's work stand out with looks that no one else has. Speed: Custom nodes can combine 10 standard nodes into one single, fast button. Community: You can join sites like Logik Matchbook to download shaders from other professional artists around the world.","title":"4. Why build your own shaders?"},{"location":"insight/shader_builder_api/insight-shader_builder_overview/#5-key-takeaway-for-beginners","text":"The Shader Builder API is the \"Secret Sauce\" of Autodesk Flame. It allows you to transform the software from a standard editing tool into a specialized, high-performance visual effects engine tailored exactly to your needs.","title":"5. Key Takeaway for Beginners"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/","text":"Insight: Designing Shader Interfaces (XML) This document explains the sidecar XML file that accompanies Matchbox and Lightbox shaders. It is the \"Blueprint\" for the user interface (UI) you see inside Flame. Target Audience: Novice programmers who want to make their shaders easy for others to use. 1. Why do I need an XML file? When you write a shader ( .glsl ), Flame can guess some simple buttons for you. But if you want a professional UI with organized pages, custom names, dropdown menus, or color wheels, you need an XML sidecar file . You generate this file by running: shader_builder -x my_shader.glsl 2. Anatomy of the UI The XML file is broken down into a hierarchy: A. <ShaderNodePreset> (The Root) This is the main container. It holds the name of your effect and settings like whether it supports 3D or if it provides a Matte. B. <Uniform> (The Controls) Every slider, checkbox, or color pot in Flame is a Uniform . - DisplayName : What the user sees (e.g., \"Glow Strength\" instead of adskUID_strength ). - Min / Max / Default : Sets the safe range for the slider. - Tooltip : The helpful text that appears when a user hovers over the control. C. <Page> and <Col> (The Layout) These organize your controls so the UI isn't just one long list. - Pages : Tabs at the bottom of the node. - Columns : Vertical groups within a page. 3. Special Control Types The XML allows you to change how a value is presented: - PopUp : Turns a number into a dropdown list (e.g., 0 = \"Linear\", 1 = \"Log\"). - Colour : Adds a color picker instead of three separate R, G, B sliders. - Curve : Provides a graph editor for complex changes over time. 4. Smart UI (Conditional logic) You can make your UI \"smart\" using UIConditions . For example, you can hide the \"Blur Amount\" slider unless the \"Enable Blur\" checkbox is checked. This keeps the interface clean and prevents users from changing settings that don't do anything. 5. Key Tip: The adsk_ Prefix If you name a variable in your GLSL starting with adsk_ (like adsk_time ), Flame will hide it from the UI. This is useful for internal math that the user shouldn't touch. 6. Key Takeaway for Beginners The XML file is your way of communicating with the artist. A well-organized XML makes a complex shader feel like a simple, built-in tool. If you can't find a setting, look for the shader_builder -x command\u2014it's the best way to start building your custom interface.","title":"Insight: Designing Shader Interfaces (XML)"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/#insight-designing-shader-interfaces-xml","text":"This document explains the sidecar XML file that accompanies Matchbox and Lightbox shaders. It is the \"Blueprint\" for the user interface (UI) you see inside Flame. Target Audience: Novice programmers who want to make their shaders easy for others to use.","title":"Insight: Designing Shader Interfaces (XML)"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/#1-why-do-i-need-an-xml-file","text":"When you write a shader ( .glsl ), Flame can guess some simple buttons for you. But if you want a professional UI with organized pages, custom names, dropdown menus, or color wheels, you need an XML sidecar file . You generate this file by running: shader_builder -x my_shader.glsl","title":"1. Why do I need an XML file?"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/#2-anatomy-of-the-ui","text":"The XML file is broken down into a hierarchy:","title":"2. Anatomy of the UI"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/#a-shadernodepreset-the-root","text":"This is the main container. It holds the name of your effect and settings like whether it supports 3D or if it provides a Matte.","title":"A. &lt;ShaderNodePreset&gt; (The Root)"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/#b-uniform-the-controls","text":"Every slider, checkbox, or color pot in Flame is a Uniform . - DisplayName : What the user sees (e.g., \"Glow Strength\" instead of adskUID_strength ). - Min / Max / Default : Sets the safe range for the slider. - Tooltip : The helpful text that appears when a user hovers over the control.","title":"B. &lt;Uniform&gt; (The Controls)"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/#c-page-and-col-the-layout","text":"These organize your controls so the UI isn't just one long list. - Pages : Tabs at the bottom of the node. - Columns : Vertical groups within a page.","title":"C. &lt;Page&gt; and &lt;Col&gt; (The Layout)"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/#3-special-control-types","text":"The XML allows you to change how a value is presented: - PopUp : Turns a number into a dropdown list (e.g., 0 = \"Linear\", 1 = \"Log\"). - Colour : Adds a color picker instead of three separate R, G, B sliders. - Curve : Provides a graph editor for complex changes over time.","title":"3. Special Control Types"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/#4-smart-ui-conditional-logic","text":"You can make your UI \"smart\" using UIConditions . For example, you can hide the \"Blur Amount\" slider unless the \"Enable Blur\" checkbox is checked. This keeps the interface clean and prevents users from changing settings that don't do anything.","title":"4. Smart UI (Conditional logic)"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/#5-key-tip-the-adsk_-prefix","text":"If you name a variable in your GLSL starting with adsk_ (like adsk_time ), Flame will hide it from the UI. This is useful for internal math that the user shouldn't touch.","title":"5. Key Tip: The adsk_ Prefix"},{"location":"insight/shader_builder_api/insight-shader_builder_xml/#6-key-takeaway-for-beginners","text":"The XML file is your way of communicating with the artist. A well-organized XML makes a complex shader feel like a simple, built-in tool. If you can't find a setting, look for the shader_builder -x command\u2014it's the best way to start building your custom interface.","title":"6. Key Takeaway for Beginners"},{"location":"insight/shader_builder_api/insight-shader_presets/","text":"Insight: Creating Shader Presets This document explains how to create Presets for your Matchbox or Lightbox shaders. Presets allow you to save specific settings (like a \"Sepia\" look or a \"Heavy Blur\" look) so users don't have to start from scratch. Target Audience: Novice programmers and tool creators. 1. What is a Preset? A preset is a small XML file that tells Flame: \"When this shader loads, set the 'Gain' to 0.5 and the 'Color' to Blue.\" In the Flame UI, these appear in the \"Presets\" dropdown menu at the top of the node settings. 2. The \"Print to Shell\" Workflow You don't have to write preset code by hand. Flame can write it for you! Adjust Settings: Load your shader in Flame and move the sliders until you have a \"look\" you like. Print XML: Go to the Node Prefs menu and click the UI XML Shell Printout button. Find the Code: Look at the terminal/shell window where you launched Flame. You will see a block of XML code starting with <Presets> . Save: Copy that code into a new text file. 3. Saving the File To make the preset work, you must name the file correctly: - Rule: <shader_name>.preset.xml - Example: If your shader is MyGlow.glsl , your preset file must be MyGlow.preset.xml . Place this file in the same folder as your .glsl and .xml files. 4. Organizing Multiple Presets You can have many looks inside one file. Just add more <Preset> blocks: <Presets> <Preset Name=\"Warm Glow\"> ... settings for warm glow ... </Preset> <Preset Name=\"Cool Blue\"> ... settings for cool blue ... </Preset> </Presets> 5. Why use Presets? Efficiency: Give artists a head start by providing common settings. Guidance: Show what your shader is capable of by creating a few extreme \"demo\" looks. Sharing: Artists can send you their shell printouts to include in your next update! 6. Key Takeaway for Beginners Presets are the \"Finishing Touch\" for a custom tool. By spending 5 minutes \"printing\" a few cool looks to the shell, you make your shader much more useful and professional for the final artist.","title":"Insight: Creating Shader Presets"},{"location":"insight/shader_builder_api/insight-shader_presets/#insight-creating-shader-presets","text":"This document explains how to create Presets for your Matchbox or Lightbox shaders. Presets allow you to save specific settings (like a \"Sepia\" look or a \"Heavy Blur\" look) so users don't have to start from scratch. Target Audience: Novice programmers and tool creators.","title":"Insight: Creating Shader Presets"},{"location":"insight/shader_builder_api/insight-shader_presets/#1-what-is-a-preset","text":"A preset is a small XML file that tells Flame: \"When this shader loads, set the 'Gain' to 0.5 and the 'Color' to Blue.\" In the Flame UI, these appear in the \"Presets\" dropdown menu at the top of the node settings.","title":"1. What is a Preset?"},{"location":"insight/shader_builder_api/insight-shader_presets/#2-the-print-to-shell-workflow","text":"You don't have to write preset code by hand. Flame can write it for you! Adjust Settings: Load your shader in Flame and move the sliders until you have a \"look\" you like. Print XML: Go to the Node Prefs menu and click the UI XML Shell Printout button. Find the Code: Look at the terminal/shell window where you launched Flame. You will see a block of XML code starting with <Presets> . Save: Copy that code into a new text file.","title":"2. The \"Print to Shell\" Workflow"},{"location":"insight/shader_builder_api/insight-shader_presets/#3-saving-the-file","text":"To make the preset work, you must name the file correctly: - Rule: <shader_name>.preset.xml - Example: If your shader is MyGlow.glsl , your preset file must be MyGlow.preset.xml . Place this file in the same folder as your .glsl and .xml files.","title":"3. Saving the File"},{"location":"insight/shader_builder_api/insight-shader_presets/#4-organizing-multiple-presets","text":"You can have many looks inside one file. Just add more <Preset> blocks: <Presets> <Preset Name=\"Warm Glow\"> ... settings for warm glow ... </Preset> <Preset Name=\"Cool Blue\"> ... settings for cool blue ... </Preset> </Presets>","title":"4. Organizing Multiple Presets"},{"location":"insight/shader_builder_api/insight-shader_presets/#5-why-use-presets","text":"Efficiency: Give artists a head start by providing common settings. Guidance: Show what your shader is capable of by creating a few extreme \"demo\" looks. Sharing: Artists can send you their shell printouts to include in your next update!","title":"5. Why use Presets?"},{"location":"insight/shader_builder_api/insight-shader_presets/#6-key-takeaway-for-beginners","text":"Presets are the \"Finishing Touch\" for a custom tool. By spending 5 minutes \"printing\" a few cool looks to the shell, you make your shader much more useful and professional for the final artist.","title":"6. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-backburner_architecture/","text":"Insight: Backburner Network Architecture This document explains the \"Engine\" behind Flame's background rendering and how it coordinates multiple computers to get work done faster. Target Audience: Novice technical artists interested in render farms and distributed computing. 1. The Three Main Players Backburner is a system that splits a big job into small pieces and sends them to different machines. It has three main components: A. The Backburner Manager (The Boss) The Manager is the \"Brain\" of the operation. - It receives jobs from Flame artists. - It looks at all the computers on the network and decides who is free to work. - It keeps a list of every job\u2014what is \"Active,\" \"Waiting,\" or \"Done.\" B. The Backburner Server (The Worker) This is a program running on one or more machines (Render Nodes). - It waits for the Manager to give it a job. - When it gets a job, it starts the rendering engine (like Burn ) and creates the actual frames. C. The Backburner Monitor (The Dashboard) This is the interface the humans use. - It allows you to see the progress of your renders. - You can use it to \"Pause,\" \"Restart,\" or \"Prioritize\" certain jobs if you are in a rush. 2. How a Job Moves Submit: The artist hits \"Render\" in Flame. Assign: The Manager finds an available Server. Execute: The Server renders the frames. Finish: The frames are saved to the server, and the Manager marks the job as \"Complete.\" 3. Why is this useful? Backburner allows you to keep working in Flame while your computer renders in the background. Or, you can use 50 other computers on your network to render a long movie in minutes instead of hours! 4. Key Takeaway for Beginners Backburner is a \"Traffic Cop\" for renders. It ensures that every computer in your studio is working as efficiently as possible, and it gives you a central place to track all that hard work.","title":"Insight: Backburner Network Architecture"},{"location":"insight/wiretap_sdk/insight-backburner_architecture/#insight-backburner-network-architecture","text":"This document explains the \"Engine\" behind Flame's background rendering and how it coordinates multiple computers to get work done faster. Target Audience: Novice technical artists interested in render farms and distributed computing.","title":"Insight: Backburner Network Architecture"},{"location":"insight/wiretap_sdk/insight-backburner_architecture/#1-the-three-main-players","text":"Backburner is a system that splits a big job into small pieces and sends them to different machines. It has three main components:","title":"1. The Three Main Players"},{"location":"insight/wiretap_sdk/insight-backburner_architecture/#a-the-backburner-manager-the-boss","text":"The Manager is the \"Brain\" of the operation. - It receives jobs from Flame artists. - It looks at all the computers on the network and decides who is free to work. - It keeps a list of every job\u2014what is \"Active,\" \"Waiting,\" or \"Done.\"","title":"A. The Backburner Manager (The Boss)"},{"location":"insight/wiretap_sdk/insight-backburner_architecture/#b-the-backburner-server-the-worker","text":"This is a program running on one or more machines (Render Nodes). - It waits for the Manager to give it a job. - When it gets a job, it starts the rendering engine (like Burn ) and creates the actual frames.","title":"B. The Backburner Server (The Worker)"},{"location":"insight/wiretap_sdk/insight-backburner_architecture/#c-the-backburner-monitor-the-dashboard","text":"This is the interface the humans use. - It allows you to see the progress of your renders. - You can use it to \"Pause,\" \"Restart,\" or \"Prioritize\" certain jobs if you are in a rush.","title":"C. The Backburner Monitor (The Dashboard)"},{"location":"insight/wiretap_sdk/insight-backburner_architecture/#2-how-a-job-moves","text":"Submit: The artist hits \"Render\" in Flame. Assign: The Manager finds an available Server. Execute: The Server renders the frames. Finish: The frames are saved to the server, and the Manager marks the job as \"Complete.\"","title":"2. How a Job Moves"},{"location":"insight/wiretap_sdk/insight-backburner_architecture/#3-why-is-this-useful","text":"Backburner allows you to keep working in Flame while your computer renders in the background. Or, you can use 50 other computers on your network to render a long movie in minutes instead of hours!","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-backburner_architecture/#4-key-takeaway-for-beginners","text":"Backburner is a \"Traffic Cop\" for renders. It ensures that every computer in your studio is working as efficiently as possible, and it gives you a central place to track all that hard work.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-backburner_job_archive_metadata/","text":"Insight: Backburner Job Archive Metadata This document explains how to quickly look at the history of everything your render farm has ever done. Target Audience: Novice programmers interested in database history and reporting. 1. What is the Job Archive? When a job is finished and old, Backburner moves it from the active /jobs folder to the /archive folder. This keeps the active list clean and fast. 2. The \"Super Query\" Normally, if you want to know about 100 jobs, you have to ask 100 questions. That's slow! Wiretap has a \"Super Query\" for the archive. When you ask for metadata on the /archive node, it gives you a giant list of every archived job all at once. <info> <job id=\"101\" name=\"Shot_01\" user=\"John\" ... /> <job id=\"102\" name=\"Shot_02\" user=\"Jane\" ... /> </info> 3. Why is this useful? Auditing: You can see exactly what was rendered three months ago. Speed: It is much faster for your script to download one big list than to ask for jobs one-by-one. Cleanup: You can look at the endTime of all archived jobs and decide which ones are old enough to be deleted forever. 4. Key Takeaway for Beginners The /archive node is the \"History Book\" of your studio. By using the info stream on this node, you can get a summary of months of work in just a few seconds. It is the most efficient way to build long-term reports.","title":"Insight: Backburner Job Archive Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_job_archive_metadata/#insight-backburner-job-archive-metadata","text":"This document explains how to quickly look at the history of everything your render farm has ever done. Target Audience: Novice programmers interested in database history and reporting.","title":"Insight: Backburner Job Archive Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_job_archive_metadata/#1-what-is-the-job-archive","text":"When a job is finished and old, Backburner moves it from the active /jobs folder to the /archive folder. This keeps the active list clean and fast.","title":"1. What is the Job Archive?"},{"location":"insight/wiretap_sdk/insight-backburner_job_archive_metadata/#2-the-super-query","text":"Normally, if you want to know about 100 jobs, you have to ask 100 questions. That's slow! Wiretap has a \"Super Query\" for the archive. When you ask for metadata on the /archive node, it gives you a giant list of every archived job all at once. <info> <job id=\"101\" name=\"Shot_01\" user=\"John\" ... /> <job id=\"102\" name=\"Shot_02\" user=\"Jane\" ... /> </info>","title":"2. The \"Super Query\""},{"location":"insight/wiretap_sdk/insight-backburner_job_archive_metadata/#3-why-is-this-useful","text":"Auditing: You can see exactly what was rendered three months ago. Speed: It is much faster for your script to download one big list than to ask for jobs one-by-one. Cleanup: You can look at the endTime of all archived jobs and decide which ones are old enough to be deleted forever.","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-backburner_job_archive_metadata/#4-key-takeaway-for-beginners","text":"The /archive node is the \"History Book\" of your studio. By using the info stream on this node, you can get a summary of months of work in just a few seconds. It is the most efficient way to build long-term reports.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-backburner_job_list_metadata/","text":"Insight: Backburner Job List Metadata This document explains how to get a detailed status report of all Active renders currently happening in your studio. Target Audience: Novice programmers interested in high-performance data querying. 1. The Active Overview Just like the archive, the active /jobs node has a \"Super Query\" feature. When you ask for its info metadata, it returns a list of every job currently waiting or rendering. It includes live details like: - percentTasksCompleted : How close is the job to being done? - nbFailedServers : Are any computers struggling with this specific job? - order : Where is this job in the \"Lineup\"? 2. Advanced Filtering (The \"Fields\" trick) If you have 1,000 jobs, the XML file can get huge and slow. You can use Filters to ask for only the pieces you need. Example: \"I only want the Name and the ID, don't send me the whole description.\" The Filter Code: <Fields id='1' name='1'/> 3. Comparison Queries You can even ask complex questions using the <Comparison> tag: - \"Show me all jobs that are 'complete'.\" - \"Show me all jobs submitted by user 'JohnDoe'.\" 4. Why is this useful? This is the power behind every professional \"Render Monitor\" dashboard. Instead of clicking through a slow interface, your script can ask for a tiny, filtered list of \"Only failed jobs\" and alert you instantly when a render hits a snag. 5. Key Takeaway for Beginners The /jobs node is the \"Live Status Board\" . By using filters and comparisons, you can get exactly the data you need (like \"Only show me the progress of V2 shots\") without wasting time downloading information you don't care about.","title":"Insight: Backburner Job List Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_job_list_metadata/#insight-backburner-job-list-metadata","text":"This document explains how to get a detailed status report of all Active renders currently happening in your studio. Target Audience: Novice programmers interested in high-performance data querying.","title":"Insight: Backburner Job List Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_job_list_metadata/#1-the-active-overview","text":"Just like the archive, the active /jobs node has a \"Super Query\" feature. When you ask for its info metadata, it returns a list of every job currently waiting or rendering. It includes live details like: - percentTasksCompleted : How close is the job to being done? - nbFailedServers : Are any computers struggling with this specific job? - order : Where is this job in the \"Lineup\"?","title":"1. The Active Overview"},{"location":"insight/wiretap_sdk/insight-backburner_job_list_metadata/#2-advanced-filtering-the-fields-trick","text":"If you have 1,000 jobs, the XML file can get huge and slow. You can use Filters to ask for only the pieces you need. Example: \"I only want the Name and the ID, don't send me the whole description.\" The Filter Code: <Fields id='1' name='1'/>","title":"2. Advanced Filtering (The \"Fields\" trick)"},{"location":"insight/wiretap_sdk/insight-backburner_job_list_metadata/#3-comparison-queries","text":"You can even ask complex questions using the <Comparison> tag: - \"Show me all jobs that are 'complete'.\" - \"Show me all jobs submitted by user 'JohnDoe'.\"","title":"3. Comparison Queries"},{"location":"insight/wiretap_sdk/insight-backburner_job_list_metadata/#4-why-is-this-useful","text":"This is the power behind every professional \"Render Monitor\" dashboard. Instead of clicking through a slow interface, your script can ask for a tiny, filtered list of \"Only failed jobs\" and alert you instantly when a render hits a snag.","title":"4. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-backburner_job_list_metadata/#5-key-takeaway-for-beginners","text":"The /jobs node is the \"Live Status Board\" . By using filters and comparisons, you can get exactly the data you need (like \"Only show me the progress of V2 shots\") without wasting time downloading information you don't care about.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-backburner_job_metadata/","text":"Insight: Backburner Job Metadata This document explains the information (Tags) attached to a render job in Backburner. Understanding these tags allows you to track exactly how your renders are performing. Target Audience: Novice programmers interested in status monitoring and reporting. 1. The Four Metadata Streams Every job in Backburner has four different \"Folders\" of information: A. info (The Overview) This is the most important stream. It contains the basic \"ID Card\" for the job: - percentTasksCompleted : How much of the render is done? - submittedTime : When did the artist hit the button? - lastError : If it failed, why? B. state (The Activity) A simple tag that tells you what the job is doing right now: - waiting : Ready to work. - active : Currently rendering. - complete : Successfully finished. - suspended : On hold. C. tasks (The Granular View) A job is often split into many small \"Tasks\" (like 10 frames each). This stream lists every single task, which machine worked on it, and how many milliseconds it took. D. details / xmlDetails (Custom Info) A secret compartment for technical settings. This is where Flame stores specific render instructions like \"Use Motion Blur\" or \"Output at 4K.\" 2. Why is this useful? By reading the info and tasks streams, you can build a Studio Report . You can calculate exactly how many hours your render farm spent on a specific project, which machines are the fastest, and which artists are submitting the most jobs. 3. Key Takeaway for Beginners Job Metadata is \"Live Intelligence.\" Instead of guessing if a render will be done by lunch, your script can read the percentTasksCompleted tag and tell you exactly how much work is left!","title":"Insight: Backburner Job Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_job_metadata/#insight-backburner-job-metadata","text":"This document explains the information (Tags) attached to a render job in Backburner. Understanding these tags allows you to track exactly how your renders are performing. Target Audience: Novice programmers interested in status monitoring and reporting.","title":"Insight: Backburner Job Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_job_metadata/#1-the-four-metadata-streams","text":"Every job in Backburner has four different \"Folders\" of information:","title":"1. The Four Metadata Streams"},{"location":"insight/wiretap_sdk/insight-backburner_job_metadata/#a-info-the-overview","text":"This is the most important stream. It contains the basic \"ID Card\" for the job: - percentTasksCompleted : How much of the render is done? - submittedTime : When did the artist hit the button? - lastError : If it failed, why?","title":"A. info (The Overview)"},{"location":"insight/wiretap_sdk/insight-backburner_job_metadata/#b-state-the-activity","text":"A simple tag that tells you what the job is doing right now: - waiting : Ready to work. - active : Currently rendering. - complete : Successfully finished. - suspended : On hold.","title":"B. state (The Activity)"},{"location":"insight/wiretap_sdk/insight-backburner_job_metadata/#c-tasks-the-granular-view","text":"A job is often split into many small \"Tasks\" (like 10 frames each). This stream lists every single task, which machine worked on it, and how many milliseconds it took.","title":"C. tasks (The Granular View)"},{"location":"insight/wiretap_sdk/insight-backburner_job_metadata/#d-details-xmldetails-custom-info","text":"A secret compartment for technical settings. This is where Flame stores specific render instructions like \"Use Motion Blur\" or \"Output at 4K.\"","title":"D. details / xmlDetails (Custom Info)"},{"location":"insight/wiretap_sdk/insight-backburner_job_metadata/#2-why-is-this-useful","text":"By reading the info and tasks streams, you can build a Studio Report . You can calculate exactly how many hours your render farm spent on a specific project, which machines are the fastest, and which artists are submitting the most jobs.","title":"2. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-backburner_job_metadata/#3-key-takeaway-for-beginners","text":"Job Metadata is \"Live Intelligence.\" Instead of guessing if a render will be done by lunch, your script can read the percentTasksCompleted tag and tell you exactly how much work is left!","title":"3. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-backburner_manager_metadata/","text":"Insight: Backburner Manager Metadata This document explains the \"Global Settings\" for your render farm. These settings control the behavior of the entire Backburner system. Target Audience: Novice technical artists and system administrators. 1. The Manager's Rulebook The Backburner Manager has an info stream that acts as the \"Rulebook\" for all computers on the farm. By changing these tags, you change how every job is handled. Key Rules: retryCount : If a computer crashes during a render, how many times should the Manager try again? (Usually set to 3). maxConcurrentJobs : How many jobs are allowed to run at the exact same time across the whole farm? archiveDays : How long should a finished job sit in the \"Recent\" list before being moved to the \"Old\" archive? logLevel : How much detail should the Manager write to its diary? (Set to debug if you are trying to find a bug). 2. Security and Admins The Manager also keeps a list of administrators . These are the only users allowed to cancel someone else's render or change the global rules. restrictRoot : A safety switch. If this is on, even the \"Superuser\" (Root) cannot send jobs from a remote computer. 3. Why is this useful? By reading the Manager's metadata, your script can verify the health of the farm. - You can check if the mailServer is set up correctly so artists get their \"Render Done\" emails. - You can automatically increase the retryCount if the network is having a bad day. 4. Key Takeaway for Beginners The Manager Metadata is the \"Control Panel\" for the studio. It defines the \"Policy\" for how work gets done. Understanding these tags is the first step to managing a professional, reliable render farm.","title":"Insight: Backburner Manager Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_manager_metadata/#insight-backburner-manager-metadata","text":"This document explains the \"Global Settings\" for your render farm. These settings control the behavior of the entire Backburner system. Target Audience: Novice technical artists and system administrators.","title":"Insight: Backburner Manager Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_manager_metadata/#1-the-managers-rulebook","text":"The Backburner Manager has an info stream that acts as the \"Rulebook\" for all computers on the farm. By changing these tags, you change how every job is handled.","title":"1. The Manager's Rulebook"},{"location":"insight/wiretap_sdk/insight-backburner_manager_metadata/#key-rules","text":"retryCount : If a computer crashes during a render, how many times should the Manager try again? (Usually set to 3). maxConcurrentJobs : How many jobs are allowed to run at the exact same time across the whole farm? archiveDays : How long should a finished job sit in the \"Recent\" list before being moved to the \"Old\" archive? logLevel : How much detail should the Manager write to its diary? (Set to debug if you are trying to find a bug).","title":"Key Rules:"},{"location":"insight/wiretap_sdk/insight-backburner_manager_metadata/#2-security-and-admins","text":"The Manager also keeps a list of administrators . These are the only users allowed to cancel someone else's render or change the global rules. restrictRoot : A safety switch. If this is on, even the \"Superuser\" (Root) cannot send jobs from a remote computer.","title":"2. Security and Admins"},{"location":"insight/wiretap_sdk/insight-backburner_manager_metadata/#3-why-is-this-useful","text":"By reading the Manager's metadata, your script can verify the health of the farm. - You can check if the mailServer is set up correctly so artists get their \"Render Done\" emails. - You can automatically increase the retryCount if the network is having a bad day.","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-backburner_manager_metadata/#4-key-takeaway-for-beginners","text":"The Manager Metadata is the \"Control Panel\" for the studio. It defines the \"Policy\" for how work gets done. Understanding these tags is the first step to managing a professional, reliable render farm.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-backburner_node_hierarchy/","text":"Insight: Backburner Node Hierarchy This document explains the organizational map of the Backburner Manager . Just like Flame projects, Backburner uses a tree structure to keep track of computers and tasks. Target Audience: Novice programmers interested in system organization. 1. The Map of the Manager The Backburner hierarchy has four main branches: A. The Manager ( MANAGER/ ) The root of the whole tree. It holds the overall settings for the entire render farm. B. The Server List ( SERVERLIST/ ) A list of every computer (Render Node) that has introduced itself to the Manager. - Each computer has its own SERVER node. - If a computer disappears (unplugged or crashed), it is marked as \"Absent.\" C. The Server Group List ( SERVERGROUPLIST/ ) Where you can group computers together. - Example: You might create a group called \"Super_Fast_Nodes\" that only contains the newest computers in the studio. D. The Job List ( JOBLIST/ ) The most active part of the tree. It contains every JOB currently being processed. - When a job is completely finished and old, it moves to the Archive branch. 2. Using Metadata Each node in this tree has \"Tags\" (Metadata). - A Job Node has tags telling you the percentage finished. - A Server Node has tags telling you if the computer is currently \"Busy\" or \"Idle.\" 3. Why is this useful? By \"Walking\" through this tree, your Python script can build its own dashboard. You can write a script that says: \"Find all servers in the 'Super_Fast' group and tell me how many of them are currently Idle.\" 4. Key Takeaway for Beginners Backburner's hierarchy is a Live Status Map . It gives you a birds-eye view of every worker and every task in your studio, organized into a simple tree that your code can easily read.","title":"Insight: Backburner Node Hierarchy"},{"location":"insight/wiretap_sdk/insight-backburner_node_hierarchy/#insight-backburner-node-hierarchy","text":"This document explains the organizational map of the Backburner Manager . Just like Flame projects, Backburner uses a tree structure to keep track of computers and tasks. Target Audience: Novice programmers interested in system organization.","title":"Insight: Backburner Node Hierarchy"},{"location":"insight/wiretap_sdk/insight-backburner_node_hierarchy/#1-the-map-of-the-manager","text":"The Backburner hierarchy has four main branches:","title":"1. The Map of the Manager"},{"location":"insight/wiretap_sdk/insight-backburner_node_hierarchy/#a-the-manager-manager","text":"The root of the whole tree. It holds the overall settings for the entire render farm.","title":"A. The Manager (MANAGER/)"},{"location":"insight/wiretap_sdk/insight-backburner_node_hierarchy/#b-the-server-list-serverlist","text":"A list of every computer (Render Node) that has introduced itself to the Manager. - Each computer has its own SERVER node. - If a computer disappears (unplugged or crashed), it is marked as \"Absent.\"","title":"B. The Server List (SERVERLIST/)"},{"location":"insight/wiretap_sdk/insight-backburner_node_hierarchy/#c-the-server-group-list-servergrouplist","text":"Where you can group computers together. - Example: You might create a group called \"Super_Fast_Nodes\" that only contains the newest computers in the studio.","title":"C. The Server Group List (SERVERGROUPLIST/)"},{"location":"insight/wiretap_sdk/insight-backburner_node_hierarchy/#d-the-job-list-joblist","text":"The most active part of the tree. It contains every JOB currently being processed. - When a job is completely finished and old, it moves to the Archive branch.","title":"D. The Job List (JOBLIST/)"},{"location":"insight/wiretap_sdk/insight-backburner_node_hierarchy/#2-using-metadata","text":"Each node in this tree has \"Tags\" (Metadata). - A Job Node has tags telling you the percentage finished. - A Server Node has tags telling you if the computer is currently \"Busy\" or \"Idle.\"","title":"2. Using Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_node_hierarchy/#3-why-is-this-useful","text":"By \"Walking\" through this tree, your Python script can build its own dashboard. You can write a script that says: \"Find all servers in the 'Super_Fast' group and tell me how many of them are currently Idle.\"","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-backburner_node_hierarchy/#4-key-takeaway-for-beginners","text":"Backburner's hierarchy is a Live Status Map . It gives you a birds-eye view of every worker and every task in your studio, organized into a simple tree that your code can easily read.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-backburner_overview/","text":"Insight: Backburner Overview This document provides a high-level summary of Backburner , Flame's system for managing background work. Target Audience: Novice programmers and studio artists. 1. What is Backburner? Rendering a movie can take hours. If you did this inside Flame, your computer would be \"Locked\" and you couldn't keep working. Backburner is the solution. It is a \"Background Manager\" that takes your render request and handles it on a different computer (or in the background of your own computer) so you can keep editing. 2. Why is it in the Wiretap SDK? The Backburner Manager is actually a Wiretap Server . This is great news for programmers! It means you can use the same code you use to find clips to also find render jobs. 3. What can you do with it? Using the API, you can build your own custom tools to: - Monitor: See exactly which frame a render is on. - Control: Pause a job if you need more bandwidth, or Restart a job if it failed. - Automate: Submit hundreds of renders at once from a script. 4. Key Takeaway for Beginners Backburner is the \"Task Manager\" for your entire studio. It coordinates the \"Heavy Lifting\" so that artists can stay focused on being creative. By mastering the Backburner API, you can build a pipeline that renders while you sleep.","title":"Insight: Backburner Overview"},{"location":"insight/wiretap_sdk/insight-backburner_overview/#insight-backburner-overview","text":"This document provides a high-level summary of Backburner , Flame's system for managing background work. Target Audience: Novice programmers and studio artists.","title":"Insight: Backburner Overview"},{"location":"insight/wiretap_sdk/insight-backburner_overview/#1-what-is-backburner","text":"Rendering a movie can take hours. If you did this inside Flame, your computer would be \"Locked\" and you couldn't keep working. Backburner is the solution. It is a \"Background Manager\" that takes your render request and handles it on a different computer (or in the background of your own computer) so you can keep editing.","title":"1. What is Backburner?"},{"location":"insight/wiretap_sdk/insight-backburner_overview/#2-why-is-it-in-the-wiretap-sdk","text":"The Backburner Manager is actually a Wiretap Server . This is great news for programmers! It means you can use the same code you use to find clips to also find render jobs.","title":"2. Why is it in the Wiretap SDK?"},{"location":"insight/wiretap_sdk/insight-backburner_overview/#3-what-can-you-do-with-it","text":"Using the API, you can build your own custom tools to: - Monitor: See exactly which frame a render is on. - Control: Pause a job if you need more bandwidth, or Restart a job if it failed. - Automate: Submit hundreds of renders at once from a script.","title":"3. What can you do with it?"},{"location":"insight/wiretap_sdk/insight-backburner_overview/#4-key-takeaway-for-beginners","text":"Backburner is the \"Task Manager\" for your entire studio. It coordinates the \"Heavy Lifting\" so that artists can stay focused on being creative. By mastering the Backburner API, you can build a pipeline that renders while you sleep.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-backburner_server_group_metadata/","text":"Insight: Server Group Metadata This document explains how to organize your computers into teams (Groups) and how to manage those groups using Wiretap. Target Audience: Novice system administrators and pipeline developers. 1. What is a Server Group? A Server Group is a collection of computers that you can target as a single unit. Instead of sending a job to one specific machine, you send it to \"The Team.\" Example: You might create a group called \"GPU_FARM\" for jobs that need high-end graphics cards. 2. Reading the Group Info Every group has an info stream that tells you: - name : The name of the team (e.g., \"Daily_Render_Nodes\"). - servers : A list of every computer currently in that team. - editable : Tells you if you have permission to change who is in the team. 3. Why is this useful? Prioritization: You can reserve your fastest machines for \"Rush\" jobs by putting them in a special group. Organization: You can separate machines by OS (e.g., \"Linux_Nodes\" vs. \"Windows_Nodes\"). Automation: Your pipeline script can look at a job's requirements and automatically pick the best Server Group to handle it. 4. Key Takeaway for Beginners Server Groups are the \"Teams\" of your render farm. By grouping your computers, you make it much easier to manage a large studio. Instead of managing 100 individual computers, you just manage 5 specialized groups.","title":"Insight: Server Group Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_server_group_metadata/#insight-server-group-metadata","text":"This document explains how to organize your computers into teams (Groups) and how to manage those groups using Wiretap. Target Audience: Novice system administrators and pipeline developers.","title":"Insight: Server Group Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_server_group_metadata/#1-what-is-a-server-group","text":"A Server Group is a collection of computers that you can target as a single unit. Instead of sending a job to one specific machine, you send it to \"The Team.\" Example: You might create a group called \"GPU_FARM\" for jobs that need high-end graphics cards.","title":"1. What is a Server Group?"},{"location":"insight/wiretap_sdk/insight-backburner_server_group_metadata/#2-reading-the-group-info","text":"Every group has an info stream that tells you: - name : The name of the team (e.g., \"Daily_Render_Nodes\"). - servers : A list of every computer currently in that team. - editable : Tells you if you have permission to change who is in the team.","title":"2. Reading the Group Info"},{"location":"insight/wiretap_sdk/insight-backburner_server_group_metadata/#3-why-is-this-useful","text":"Prioritization: You can reserve your fastest machines for \"Rush\" jobs by putting them in a special group. Organization: You can separate machines by OS (e.g., \"Linux_Nodes\" vs. \"Windows_Nodes\"). Automation: Your pipeline script can look at a job's requirements and automatically pick the best Server Group to handle it.","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-backburner_server_group_metadata/#4-key-takeaway-for-beginners","text":"Server Groups are the \"Teams\" of your render farm. By grouping your computers, you make it much easier to manage a large studio. Instead of managing 100 individual computers, you just manage 5 specialized groups.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-backburner_server_metadata/","text":"Insight: Backburner Server Metadata This document explains the information (Tags) attached to the individual computers (Servers) in your render farm. Target Audience: Novice technical artists and system administrators. 1. Monitoring the Workers Every server in the Backburner farm has an info stream that tells you its health and status: state : Is the computer Idle (waiting for work), Active (rendering), or Absent (turned off)? perfIndex : A score from 0 to 1. A score of 1.0 means this is the fastest machine in the building. plugins : A list of what this machine can do. For example, does it have Burn installed for rendering video? 2. Setting a Schedule One of the coolest features of Backburner is the schedule stream. You can tell a machine exactly when it is allowed to work. The Math: The schedule is stored as a 24-bit number (one bit for every hour of the day). Use Case: You can set a rule that says: \"Machine #10 is a powerful artist workstation. It should only render between 7 PM and 7 AM when the artist is home sleeping.\" 3. Why is this useful? Efficiency: You can ensure that heavy renders don't slow down artists while they are working. Troubleshooting: If a machine is constantly in an \"Error\" state, you can find it quickly in the metadata and fix it. Description: You can add custom notes like \"Node under the window\" or \"Needs more RAM\" to help you keep track of physical machines. 4. Key Takeaway for Beginners Server Metadata is the \"Health Report\" for your computers. By reading the state and perfIndex , you can make sure your studio's hardware is being used to its full potential without interrupting the creative team.","title":"Insight: Backburner Server Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_server_metadata/#insight-backburner-server-metadata","text":"This document explains the information (Tags) attached to the individual computers (Servers) in your render farm. Target Audience: Novice technical artists and system administrators.","title":"Insight: Backburner Server Metadata"},{"location":"insight/wiretap_sdk/insight-backburner_server_metadata/#1-monitoring-the-workers","text":"Every server in the Backburner farm has an info stream that tells you its health and status: state : Is the computer Idle (waiting for work), Active (rendering), or Absent (turned off)? perfIndex : A score from 0 to 1. A score of 1.0 means this is the fastest machine in the building. plugins : A list of what this machine can do. For example, does it have Burn installed for rendering video?","title":"1. Monitoring the Workers"},{"location":"insight/wiretap_sdk/insight-backburner_server_metadata/#2-setting-a-schedule","text":"One of the coolest features of Backburner is the schedule stream. You can tell a machine exactly when it is allowed to work. The Math: The schedule is stored as a 24-bit number (one bit for every hour of the day). Use Case: You can set a rule that says: \"Machine #10 is a powerful artist workstation. It should only render between 7 PM and 7 AM when the artist is home sleeping.\"","title":"2. Setting a Schedule"},{"location":"insight/wiretap_sdk/insight-backburner_server_metadata/#3-why-is-this-useful","text":"Efficiency: You can ensure that heavy renders don't slow down artists while they are working. Troubleshooting: If a machine is constantly in an \"Error\" state, you can find it quickly in the metadata and fix it. Description: You can add custom notes like \"Node under the window\" or \"Needs more RAM\" to help you keep track of physical machines.","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-backburner_server_metadata/#4-key-takeaway-for-beginners","text":"Server Metadata is the \"Health Report\" for your computers. By reading the state and perfIndex , you can make sure your studio's hardware is being used to its full potential without interrupting the creative team.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-backburner_terminology/","text":"Insight: Backburner Terminology This document explains the specific \"Vocabulary\" used when talking about Flame's background rendering system. Target Audience: Novice programmers learning about distributed rendering. 1. The Core Components Backburner: The name of the entire system that manages background jobs. Job: A specific task (like \"Render the car commercial\"). A job is made up of many small parts. Backburner Manager: The \"Central Brain\" that decides which computer does which job. Backburner Server: The program on each computer that actually does the work. 2. Technical Infrastructure Renderer / Rendering Engine: The \"Machine\" inside the computer that draws the pictures (e.g., Burn ). Processing Engine: A machine that does non-picture tasks, like moving files or zipping folders. Plug-in / Adapter: The \"Translator\" that allows the Backburner Manager to talk to different software (like Flame, 3ds Max, or Maya). 3. Why is this useful? Knowing these terms helps you understand where a problem is happening. - If your job won't start, the Manager might be down. - If the frames are coming out black, the Server or the Renderer might have a problem. 4. Key Takeaway for Beginners Backburner is like a Construction Site . The Job is the building, the Manager is the foreman with the clipboard, and the Servers are the individual workers. The Adapters are the specific tools (hammers, saws) they use to get the job done.","title":"Insight: Backburner Terminology"},{"location":"insight/wiretap_sdk/insight-backburner_terminology/#insight-backburner-terminology","text":"This document explains the specific \"Vocabulary\" used when talking about Flame's background rendering system. Target Audience: Novice programmers learning about distributed rendering.","title":"Insight: Backburner Terminology"},{"location":"insight/wiretap_sdk/insight-backburner_terminology/#1-the-core-components","text":"Backburner: The name of the entire system that manages background jobs. Job: A specific task (like \"Render the car commercial\"). A job is made up of many small parts. Backburner Manager: The \"Central Brain\" that decides which computer does which job. Backburner Server: The program on each computer that actually does the work.","title":"1. The Core Components"},{"location":"insight/wiretap_sdk/insight-backburner_terminology/#2-technical-infrastructure","text":"Renderer / Rendering Engine: The \"Machine\" inside the computer that draws the pictures (e.g., Burn ). Processing Engine: A machine that does non-picture tasks, like moving files or zipping folders. Plug-in / Adapter: The \"Translator\" that allows the Backburner Manager to talk to different software (like Flame, 3ds Max, or Maya).","title":"2. Technical Infrastructure"},{"location":"insight/wiretap_sdk/insight-backburner_terminology/#3-why-is-this-useful","text":"Knowing these terms helps you understand where a problem is happening. - If your job won't start, the Manager might be down. - If the frames are coming out black, the Server or the Renderer might have a problem.","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-backburner_terminology/#4-key-takeaway-for-beginners","text":"Backburner is like a Construction Site . The Job is the building, the Manager is the foreman with the clipboard, and the Servers are the individual workers. The Adapters are the specific tools (hammers, saws) they use to get the job done.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-basic_programming_issues/","text":"Insight: Basic Programming Issues This document explains the fundamental \"Rules of the Road\" when writing code for Wiretap. Target Audience: Novice programmers learning the API's syntax and behavior. 1. The \"WireTap\" Nameplate Every class and function in the SDK starts with the word WireTap . - Why? This is called Namespacing . it ensures that if your code uses other libraries (like a standard math library), the names won't clash and cause confusion for the computer. 2. Strings and the WireTapStr Class In C++, \"Strings\" (text) can be tricky. Wiretap uses its own simplified version of text called WireTapStr . - Important: If you want to use Wiretap text in your own script, you usually have to \"Copy\" it into your own text variables first. 3. Error Handling (The Success Switch) Every time you ask Wiretap to do something, it doesn't just \"do it\"\u2014it tells you True (I did it!) or False (I couldn't do it). - Pro Tip: Always wrap your Wiretap commands in an \"If Statement.\" if handle.renameNode(\"NewName\") == False: print(handle.lastError()) 4. Multi-Threading (Can I do two things at once?) Wiretap allows you to use different threads (running different parts of your script simultaneously), but there is a catch: - The Rule: You can't share one \"Remote Control\" (Handle) between two threads. - The Solution: If you have two threads, give each one its own unique handle to the clip. 5. Key Takeaway for Beginners The Wiretap API is built for Stability . It uses strict namespacing, custom text types, and a standard True/False success check to ensure that your studio's automation is reliable and doesn't crash when things get complicated.","title":"Insight: Basic Programming Issues"},{"location":"insight/wiretap_sdk/insight-basic_programming_issues/#insight-basic-programming-issues","text":"This document explains the fundamental \"Rules of the Road\" when writing code for Wiretap. Target Audience: Novice programmers learning the API's syntax and behavior.","title":"Insight: Basic Programming Issues"},{"location":"insight/wiretap_sdk/insight-basic_programming_issues/#1-the-wiretap-nameplate","text":"Every class and function in the SDK starts with the word WireTap . - Why? This is called Namespacing . it ensures that if your code uses other libraries (like a standard math library), the names won't clash and cause confusion for the computer.","title":"1. The \"WireTap\" Nameplate"},{"location":"insight/wiretap_sdk/insight-basic_programming_issues/#2-strings-and-the-wiretapstr-class","text":"In C++, \"Strings\" (text) can be tricky. Wiretap uses its own simplified version of text called WireTapStr . - Important: If you want to use Wiretap text in your own script, you usually have to \"Copy\" it into your own text variables first.","title":"2. Strings and the WireTapStr Class"},{"location":"insight/wiretap_sdk/insight-basic_programming_issues/#3-error-handling-the-success-switch","text":"Every time you ask Wiretap to do something, it doesn't just \"do it\"\u2014it tells you True (I did it!) or False (I couldn't do it). - Pro Tip: Always wrap your Wiretap commands in an \"If Statement.\" if handle.renameNode(\"NewName\") == False: print(handle.lastError())","title":"3. Error Handling (The Success Switch)"},{"location":"insight/wiretap_sdk/insight-basic_programming_issues/#4-multi-threading-can-i-do-two-things-at-once","text":"Wiretap allows you to use different threads (running different parts of your script simultaneously), but there is a catch: - The Rule: You can't share one \"Remote Control\" (Handle) between two threads. - The Solution: If you have two threads, give each one its own unique handle to the clip.","title":"4. Multi-Threading (Can I do two things at once?)"},{"location":"insight/wiretap_sdk/insight-basic_programming_issues/#5-key-takeaway-for-beginners","text":"The Wiretap API is built for Stability . It uses strict namespacing, custom text types, and a standard True/False success check to ensure that your studio's automation is reliable and doesn't crash when things get complicated.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-clip_format_metadata/","text":"Insight: Clip Format Metadata This document explains the technical \"DNA\" of a clip\u2014its format, resolution, and original source metadata. Target Audience: Novice programmers interested in technical metadata and file properties. 1. What is Clip Format? Every video clip in Flame has a specific \"Identity\": - \"I am 1920x1080.\" - \"I am 10-bit color.\" - \"I play at 24 frames per second.\" The WireTapClipFormat class is the tool you use to read these specific properties. 2. Accessing the Source Data When you import a file (like an R3D or an OpenEXR) into Flame, Flame keeps a \"Receipt\" of where that file came from and all its original settings. This is called the SourceData stream. The Format: The SourceData is written in MIO XML , which is very similar to the \"Open Clip\" format. The Command: You use getMetadata with the -s SourceData flag to see it. 3. Why is this useful? Verification: You can write a script that checks every clip in a library to make sure they are all the same resolution. Lineage: You can look at the SourceData to find the exact file path on the server where the original media lives, even if someone renamed the clip in Flame. Audio Info: For audio clips, there is a matching class called WireTapAudioClipFormat that tells you things like the sample rate (e.g., 48kHz). 4. Key Takeaway for Beginners Think of Clip Format as the \"Spec Sheet\" for your video. While the info metadata tells you the name and date, the ClipFormat tells you the technical details you need to process the images correctly.","title":"Insight: Clip Format Metadata"},{"location":"insight/wiretap_sdk/insight-clip_format_metadata/#insight-clip-format-metadata","text":"This document explains the technical \"DNA\" of a clip\u2014its format, resolution, and original source metadata. Target Audience: Novice programmers interested in technical metadata and file properties.","title":"Insight: Clip Format Metadata"},{"location":"insight/wiretap_sdk/insight-clip_format_metadata/#1-what-is-clip-format","text":"Every video clip in Flame has a specific \"Identity\": - \"I am 1920x1080.\" - \"I am 10-bit color.\" - \"I play at 24 frames per second.\" The WireTapClipFormat class is the tool you use to read these specific properties.","title":"1. What is Clip Format?"},{"location":"insight/wiretap_sdk/insight-clip_format_metadata/#2-accessing-the-source-data","text":"When you import a file (like an R3D or an OpenEXR) into Flame, Flame keeps a \"Receipt\" of where that file came from and all its original settings. This is called the SourceData stream. The Format: The SourceData is written in MIO XML , which is very similar to the \"Open Clip\" format. The Command: You use getMetadata with the -s SourceData flag to see it.","title":"2. Accessing the Source Data"},{"location":"insight/wiretap_sdk/insight-clip_format_metadata/#3-why-is-this-useful","text":"Verification: You can write a script that checks every clip in a library to make sure they are all the same resolution. Lineage: You can look at the SourceData to find the exact file path on the server where the original media lives, even if someone renamed the clip in Flame. Audio Info: For audio clips, there is a matching class called WireTapAudioClipFormat that tells you things like the sample rate (e.g., 48kHz).","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-clip_format_metadata/#4-key-takeaway-for-beginners","text":"Think of Clip Format as the \"Spec Sheet\" for your video. While the info metadata tells you the name and date, the ClipFormat tells you the technical details you need to process the images correctly.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-clip_node_edl/","text":"Insight: Clip Node Metadata (EDL) This document explains the EDL (Edit Decision List) metadata stream inside a Flame clip. This is how Flame stores the \"Edit Instructions\" for a timeline. Target Audience: Novice technical artists interested in conforming and editorial workflows. 1. What is a Wiretap EDL? In the old days of film editing, an EDL was a simple text file that told a machine: \"Take 5 seconds from Tape A and join it to 10 seconds from Tape B.\" Wiretap uses a modern version of this called the CMX 3600 format, but it adds special \"Autodesk Tags\" (starting with DLEDL: ) to store extra info that normal EDLs can't handle. 2. Reading the \"Map\" When you look at a Wiretap EDL, you will see lines like these: FCM: NON-DROP FRAME : Tells you if the clock skips numbers to stay accurate. DLEDL: SOURCEID : A unique ID for the original clip. This is much more reliable than just using a name like \"v1.\" DLEDL: EDIT:0 FRAME : A specific hex code (like 0x2581... ) that identifies every single image in the edit. DLEDL: REEL : The full name of the tape or folder where the media lives. 3. Transitions and Virtual Sources The EDL even handles complex things: - Dissolves: These are marked with a D followed by the number of frames (e.g., D 004 ). - Virtual Tapes: If a clip was generated inside Flame (like a solid Green color or SMPTE bars), the EDL gives it a \"Virtual\" tape name like GREEN or COLOUR . 4. Why is this useful? By reading the EDL stream, your script can perfectly reconstruct a timeline in another application or database. You can see exactly which frames were used from which files without ever having to open the project in Flame. 5. Key Takeaway for Beginners The EDL is the \"Recipe\" for your timeline. While the media files are the ingredients, the EDL tells Flame exactly how to \"Cook\" them\u2014which parts to cut, where to overlap them, and which frame IDs to pull from the server.","title":"Insight: Clip Node Metadata (EDL)"},{"location":"insight/wiretap_sdk/insight-clip_node_edl/#insight-clip-node-metadata-edl","text":"This document explains the EDL (Edit Decision List) metadata stream inside a Flame clip. This is how Flame stores the \"Edit Instructions\" for a timeline. Target Audience: Novice technical artists interested in conforming and editorial workflows.","title":"Insight: Clip Node Metadata (EDL)"},{"location":"insight/wiretap_sdk/insight-clip_node_edl/#1-what-is-a-wiretap-edl","text":"In the old days of film editing, an EDL was a simple text file that told a machine: \"Take 5 seconds from Tape A and join it to 10 seconds from Tape B.\" Wiretap uses a modern version of this called the CMX 3600 format, but it adds special \"Autodesk Tags\" (starting with DLEDL: ) to store extra info that normal EDLs can't handle.","title":"1. What is a Wiretap EDL?"},{"location":"insight/wiretap_sdk/insight-clip_node_edl/#2-reading-the-map","text":"When you look at a Wiretap EDL, you will see lines like these: FCM: NON-DROP FRAME : Tells you if the clock skips numbers to stay accurate. DLEDL: SOURCEID : A unique ID for the original clip. This is much more reliable than just using a name like \"v1.\" DLEDL: EDIT:0 FRAME : A specific hex code (like 0x2581... ) that identifies every single image in the edit. DLEDL: REEL : The full name of the tape or folder where the media lives.","title":"2. Reading the \"Map\""},{"location":"insight/wiretap_sdk/insight-clip_node_edl/#3-transitions-and-virtual-sources","text":"The EDL even handles complex things: - Dissolves: These are marked with a D followed by the number of frames (e.g., D 004 ). - Virtual Tapes: If a clip was generated inside Flame (like a solid Green color or SMPTE bars), the EDL gives it a \"Virtual\" tape name like GREEN or COLOUR .","title":"3. Transitions and Virtual Sources"},{"location":"insight/wiretap_sdk/insight-clip_node_edl/#4-why-is-this-useful","text":"By reading the EDL stream, your script can perfectly reconstruct a timeline in another application or database. You can see exactly which frames were used from which files without ever having to open the project in Flame.","title":"4. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-clip_node_edl/#5-key-takeaway-for-beginners","text":"The EDL is the \"Recipe\" for your timeline. While the media files are the ingredients, the EDL tells Flame exactly how to \"Cook\" them\u2014which parts to cut, where to overlap them, and which frame IDs to pull from the server.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-creating_backburner_jobs/","text":"Insight: Creating and Submitting Jobs This document explains how your Python script can \"Hire\" Backburner to do a job for you. Target Audience: Novice programmers interested in task automation. 1. The 5-Step Process Submitting a job to the render farm follows a strict sequence: Create the Node: You build a new \"Empty\" job in the /jobs folder. Add General Info: You tell Backburner basic things like \"What is the name of this job?\" and \"Which plugin should I use (e.g., Burn)?\" Add Detailed Instructions: (Optional) You can give specific render settings, like \"Use 4x Anti-Aliasing.\" Attach Files: (Optional) If the job needs a specific setup file to run, you can \"push\" that file directly into the job node. Go!: When you first create a job, it is Suspended (Sleeping). You must change its status to Waiting to tell the farm to start working. 2. Mandatory Info Backburner won't work unless you provide two key details: - pluginName : Which software should run this job? - numTasks : How many pieces should this job be split into? 3. Why is this useful? Normally, an artist has to hit \"Render\" manually inside Flame. With this API, you can write a script that says: \"Every night at midnight, find all finished edits and submit them to Backburner to create review movies.\" It turns manual \"Clicking\" into automatic \"Processing.\" 4. Key Takeaway for Beginners Creating a job is like Filling out a Form . You create the form (the node), fill in the blanks (the metadata), and then hand it to the manager (changing status to 'Waiting'). Once the manager has the form, the rest happens automatically!","title":"Insight: Creating and Submitting Jobs"},{"location":"insight/wiretap_sdk/insight-creating_backburner_jobs/#insight-creating-and-submitting-jobs","text":"This document explains how your Python script can \"Hire\" Backburner to do a job for you. Target Audience: Novice programmers interested in task automation.","title":"Insight: Creating and Submitting Jobs"},{"location":"insight/wiretap_sdk/insight-creating_backburner_jobs/#1-the-5-step-process","text":"Submitting a job to the render farm follows a strict sequence: Create the Node: You build a new \"Empty\" job in the /jobs folder. Add General Info: You tell Backburner basic things like \"What is the name of this job?\" and \"Which plugin should I use (e.g., Burn)?\" Add Detailed Instructions: (Optional) You can give specific render settings, like \"Use 4x Anti-Aliasing.\" Attach Files: (Optional) If the job needs a specific setup file to run, you can \"push\" that file directly into the job node. Go!: When you first create a job, it is Suspended (Sleeping). You must change its status to Waiting to tell the farm to start working.","title":"1. The 5-Step Process"},{"location":"insight/wiretap_sdk/insight-creating_backburner_jobs/#2-mandatory-info","text":"Backburner won't work unless you provide two key details: - pluginName : Which software should run this job? - numTasks : How many pieces should this job be split into?","title":"2. Mandatory Info"},{"location":"insight/wiretap_sdk/insight-creating_backburner_jobs/#3-why-is-this-useful","text":"Normally, an artist has to hit \"Render\" manually inside Flame. With this API, you can write a script that says: \"Every night at midnight, find all finished edits and submit them to Backburner to create review movies.\" It turns manual \"Clicking\" into automatic \"Processing.\"","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-creating_backburner_jobs/#4-key-takeaway-for-beginners","text":"Creating a job is like Filling out a Form . You create the form (the node), fill in the blanks (the metadata), and then hand it to the manager (changing status to 'Waiting'). Once the manager has the form, the rest happens automatically!","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-gateway_formats/","text":"Insight: Supported Ingest Formats This document explains the two main ways video is stored on your hard drive and how the Wiretap Gateway understands them. Target Audience: Novice programmers and technical artists. 1. Image Sequences (The \"Stack of Photos\") An image sequence is a folder full of files, where each file is exactly one frame of video. - Common Formats: DPX, OpenEXR, TIFF, Cineon. - Easy to Identify: You can usually tell what's inside just by looking at the file extension (e.g., .exr ). 2. Container Formats (The \"Box of Chocolate\") A container (or \"Wrapper\") is one single file that holds many different things inside it (Video, Audio, Metadata). - Common Formats: QuickTime ( .mov ), MXF, RED ( .r3d ). - The Catch: You can't tell what's inside just by the extension. A .mov file could be a low-res preview or a high-res master. 3. How the Gateway Helps The Wiretap Gateway is built to handle both. - It automatically \"Groups\" a stack of 10,000 DPX files into a single Clip node. - It \"Unwraps\" container files like ProRes or RED files so you can stream the video frames inside them across the network. 4. Key Takeaway for Beginners The Gateway is your \"Universal Decoder.\" It doesn't matter if your footage is a giant list of EXR images or a single compressed QuickTime file\u2014the Gateway translates them all into the same \"Language\" so your Wiretap scripts can read them the same way.","title":"Insight: Supported Ingest Formats"},{"location":"insight/wiretap_sdk/insight-gateway_formats/#insight-supported-ingest-formats","text":"This document explains the two main ways video is stored on your hard drive and how the Wiretap Gateway understands them. Target Audience: Novice programmers and technical artists.","title":"Insight: Supported Ingest Formats"},{"location":"insight/wiretap_sdk/insight-gateway_formats/#1-image-sequences-the-stack-of-photos","text":"An image sequence is a folder full of files, where each file is exactly one frame of video. - Common Formats: DPX, OpenEXR, TIFF, Cineon. - Easy to Identify: You can usually tell what's inside just by looking at the file extension (e.g., .exr ).","title":"1. Image Sequences (The \"Stack of Photos\")"},{"location":"insight/wiretap_sdk/insight-gateway_formats/#2-container-formats-the-box-of-chocolate","text":"A container (or \"Wrapper\") is one single file that holds many different things inside it (Video, Audio, Metadata). - Common Formats: QuickTime ( .mov ), MXF, RED ( .r3d ). - The Catch: You can't tell what's inside just by the extension. A .mov file could be a low-res preview or a high-res master.","title":"2. Container Formats (The \"Box of Chocolate\")"},{"location":"insight/wiretap_sdk/insight-gateway_formats/#3-how-the-gateway-helps","text":"The Wiretap Gateway is built to handle both. - It automatically \"Groups\" a stack of 10,000 DPX files into a single Clip node. - It \"Unwraps\" container files like ProRes or RED files so you can stream the video frames inside them across the network.","title":"3. How the Gateway Helps"},{"location":"insight/wiretap_sdk/insight-gateway_formats/#4-key-takeaway-for-beginners","text":"The Gateway is your \"Universal Decoder.\" It doesn't matter if your footage is a giant list of EXR images or a single compressed QuickTime file\u2014the Gateway translates them all into the same \"Language\" so your Wiretap scripts can read them the same way.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-gateway_node_hierarchy/","text":"Insight: The Gateway Node Hierarchy This document explains how the Wiretap Gateway looks at your computer's hard drive and turns it into a neat, organized list of clips. Target Audience: Novice programmers interested in file systems and media browsing. 1. What is the Gateway Hierarchy? The Gateway is like a Translator . It looks at a messy folder full of DPX or ProRes files and translates them into standard Wiretap Nodes. DIR : A standard folder on your hard drive. CLIP : A \"Smart\" node that groups multiple frames (like shot.001.dpx to shot.100.dpx ) into a single object. HIRES : The actual video data inside the clip. 2. Multi-Process Design To keep everything fast, the Gateway uses two types of processes: 1. The Main Process: The \"Boss\" that handles the startup. 2. The Session Processes: A private \"Assistant\" created just for your script. This assistant keeps track of what you are doing so you don't interfere with other users on the network. 3. Warning: Node IDs are \"Black Boxes\" A Node ID might look like a simple piece of text, but never try to guess what it means . - The Rule: Always ask the \"Parent\" node for the list of its children. Don't try to build a Node ID manually, or your script will break when you update Flame! 4. Key Takeaway for Beginners The Gateway is your \"Window\" to the outside world. It turns raw files on a hard drive into professional Flame clips that your scripts can read and process. Always use the wiretap_get_children command to explore this hierarchy safely.","title":"Insight: The Gateway Node Hierarchy"},{"location":"insight/wiretap_sdk/insight-gateway_node_hierarchy/#insight-the-gateway-node-hierarchy","text":"This document explains how the Wiretap Gateway looks at your computer's hard drive and turns it into a neat, organized list of clips. Target Audience: Novice programmers interested in file systems and media browsing.","title":"Insight: The Gateway Node Hierarchy"},{"location":"insight/wiretap_sdk/insight-gateway_node_hierarchy/#1-what-is-the-gateway-hierarchy","text":"The Gateway is like a Translator . It looks at a messy folder full of DPX or ProRes files and translates them into standard Wiretap Nodes. DIR : A standard folder on your hard drive. CLIP : A \"Smart\" node that groups multiple frames (like shot.001.dpx to shot.100.dpx ) into a single object. HIRES : The actual video data inside the clip.","title":"1. What is the Gateway Hierarchy?"},{"location":"insight/wiretap_sdk/insight-gateway_node_hierarchy/#2-multi-process-design","text":"To keep everything fast, the Gateway uses two types of processes: 1. The Main Process: The \"Boss\" that handles the startup. 2. The Session Processes: A private \"Assistant\" created just for your script. This assistant keeps track of what you are doing so you don't interfere with other users on the network.","title":"2. Multi-Process Design"},{"location":"insight/wiretap_sdk/insight-gateway_node_hierarchy/#3-warning-node-ids-are-black-boxes","text":"A Node ID might look like a simple piece of text, but never try to guess what it means . - The Rule: Always ask the \"Parent\" node for the list of its children. Don't try to build a Node ID manually, or your script will break when you update Flame!","title":"3. Warning: Node IDs are \"Black Boxes\""},{"location":"insight/wiretap_sdk/insight-gateway_node_hierarchy/#4-key-takeaway-for-beginners","text":"The Gateway is your \"Window\" to the outside world. It turns raw files on a hard drive into professional Flame clips that your scripts can read and process. Always use the wiretap_get_children command to explore this hierarchy safely.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-getting_started/","text":"Insight: Getting Started with Wiretap This document explains the first steps to using the Wiretap SDK and the three different ways you can interact with it. Target Audience: Novice programmers and technical artists looking for the best \"Entry Point.\" 1. Prerequisites Before you can write code, you need to download and install the Wiretap Client SDK from Autodesk. This puts the necessary \"Tools\" and \"Libraries\" on your computer so your scripts can talk to Flame. 2. Three Ways to Play Autodesk provides three ways to use the API, depending on your skill level and needs: A. Command Line Tools (For Everyone) These are pre-written programs you can run in your terminal. They allow you to \"See\" the API in action without writing a single line of code. - Best for: Quick tests, finding Node IDs, and seeing if your network is connected. B. Python Modules (For Rapid Scripting) Python is the most common way to use Wiretap. You don't have to compile your code, and you can see results instantly. - Best for: Automation, studio pipelines, and small utility tools. C. C++ Classes (For Developers) This is for high-performance, professional application building. It is more complex but offers the most speed and control. - Best for: Building standalone apps that need to move massive amounts of video data very quickly. 3. Key Takeaway for Beginners Start with the Command Line Tools ! Run a command like wiretap_get_node_info just to see how the computer responds. Once you understand how the system \"looks,\" moving to Python will be much easier because you'll already know what data to expect.","title":"Insight: Getting Started with Wiretap"},{"location":"insight/wiretap_sdk/insight-getting_started/#insight-getting-started-with-wiretap","text":"This document explains the first steps to using the Wiretap SDK and the three different ways you can interact with it. Target Audience: Novice programmers and technical artists looking for the best \"Entry Point.\"","title":"Insight: Getting Started with Wiretap"},{"location":"insight/wiretap_sdk/insight-getting_started/#1-prerequisites","text":"Before you can write code, you need to download and install the Wiretap Client SDK from Autodesk. This puts the necessary \"Tools\" and \"Libraries\" on your computer so your scripts can talk to Flame.","title":"1. Prerequisites"},{"location":"insight/wiretap_sdk/insight-getting_started/#2-three-ways-to-play","text":"Autodesk provides three ways to use the API, depending on your skill level and needs:","title":"2. Three Ways to Play"},{"location":"insight/wiretap_sdk/insight-getting_started/#a-command-line-tools-for-everyone","text":"These are pre-written programs you can run in your terminal. They allow you to \"See\" the API in action without writing a single line of code. - Best for: Quick tests, finding Node IDs, and seeing if your network is connected.","title":"A. Command Line Tools (For Everyone)"},{"location":"insight/wiretap_sdk/insight-getting_started/#b-python-modules-for-rapid-scripting","text":"Python is the most common way to use Wiretap. You don't have to compile your code, and you can see results instantly. - Best for: Automation, studio pipelines, and small utility tools.","title":"B. Python Modules (For Rapid Scripting)"},{"location":"insight/wiretap_sdk/insight-getting_started/#c-c-classes-for-developers","text":"This is for high-performance, professional application building. It is more complex but offers the most speed and control. - Best for: Building standalone apps that need to move massive amounts of video data very quickly.","title":"C. C++ Classes (For Developers)"},{"location":"insight/wiretap_sdk/insight-getting_started/#3-key-takeaway-for-beginners","text":"Start with the Command Line Tools ! Run a command like wiretap_get_node_info just to see how the computer responds. Once you understand how the system \"looks,\" moving to Python will be much easier because you'll already know what data to expect.","title":"3. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-ifffs_node_hierarchy/","text":"Insight: The IFFFS Node Hierarchy This document explains the tree-like structure inside a Flame project. Understanding this \"Map\" is essential for finding and modifying clips using the Wiretap API. Target Audience: Novice programmers interested in database structures. 1. The Tree Analogy Think of a Flame project like a tree. You start at the trunk and follow the branches until you find the \"Leaves\" (the actual frames of video). The Hierarchy: 1. PROJECT: The trunk. Contains everything for a specific job. 2. WORKSPACE: A large branch. Usually one for every artist on the project. 3. DESKTOP: A smaller branch. Where the current active work lives. 4. LIBRARY: A folder where you store your clips. 5. REEL: A group inside a library. 6. CLIP: The final branch. 7. HIRES / VERSION: The leaves. The actual images you see on the screen. 2. Important Node Types PROJECT : The top level. LIBRARY : The primary place where clips are organized. CLIP : This node doesn't hold the pictures itself; it is a container for Versions . HIRES : This is the child of a Clip that actually holds the high-resolution images. 3. The \"Commit\" Concept When you make a change via the API (like renaming a clip), Wiretap doesn't save it to the hard drive immediately. It waits 2 seconds to see if you have more changes. - Manual Save: You can force a save by sending a COMMIT command. This is like hitting \"Ctrl+S\" in a text editor. 4. Why is this useful? By knowing this hierarchy, you can write a script that says: \"Go to Project: 'Car_Ad', find Library: 'Daily_Renders', and list every CLIP inside it.\" Without this map, you'd be lost in thousands of files with no way to find the one you need. 5. Key Takeaway for Beginners Everything in Flame is a Node . To find anything, you just start at the top (The Project) and \"Walk\" down the tree using Node IDs until you reach your destination.","title":"Insight: The IFFFS Node Hierarchy"},{"location":"insight/wiretap_sdk/insight-ifffs_node_hierarchy/#insight-the-ifffs-node-hierarchy","text":"This document explains the tree-like structure inside a Flame project. Understanding this \"Map\" is essential for finding and modifying clips using the Wiretap API. Target Audience: Novice programmers interested in database structures.","title":"Insight: The IFFFS Node Hierarchy"},{"location":"insight/wiretap_sdk/insight-ifffs_node_hierarchy/#1-the-tree-analogy","text":"Think of a Flame project like a tree. You start at the trunk and follow the branches until you find the \"Leaves\" (the actual frames of video). The Hierarchy: 1. PROJECT: The trunk. Contains everything for a specific job. 2. WORKSPACE: A large branch. Usually one for every artist on the project. 3. DESKTOP: A smaller branch. Where the current active work lives. 4. LIBRARY: A folder where you store your clips. 5. REEL: A group inside a library. 6. CLIP: The final branch. 7. HIRES / VERSION: The leaves. The actual images you see on the screen.","title":"1. The Tree Analogy"},{"location":"insight/wiretap_sdk/insight-ifffs_node_hierarchy/#2-important-node-types","text":"PROJECT : The top level. LIBRARY : The primary place where clips are organized. CLIP : This node doesn't hold the pictures itself; it is a container for Versions . HIRES : This is the child of a Clip that actually holds the high-resolution images.","title":"2. Important Node Types"},{"location":"insight/wiretap_sdk/insight-ifffs_node_hierarchy/#3-the-commit-concept","text":"When you make a change via the API (like renaming a clip), Wiretap doesn't save it to the hard drive immediately. It waits 2 seconds to see if you have more changes. - Manual Save: You can force a save by sending a COMMIT command. This is like hitting \"Ctrl+S\" in a text editor.","title":"3. The \"Commit\" Concept"},{"location":"insight/wiretap_sdk/insight-ifffs_node_hierarchy/#4-why-is-this-useful","text":"By knowing this hierarchy, you can write a script that says: \"Go to Project: 'Car_Ad', find Library: 'Daily_Renders', and list every CLIP inside it.\" Without this map, you'd be lost in thousands of files with no way to find the one you need.","title":"4. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-ifffs_node_hierarchy/#5-key-takeaway-for-beginners","text":"Everything in Flame is a Node . To find anything, you just start at the top (The Project) and \"Walk\" down the tree using Node IDs until you reach your destination.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-ifffs_troubleshooting/","text":"Insight: IFFFS Troubleshooting (Unlinked Media) This document explains a common \"Gotcha\" when using Wiretap to build timelines in Flame: why media sometimes appears \"Unlinked\" (Offline). Target Audience: Novice technical artists building automated conforming tools. 1. The \"Online\" Mystery You write a perfect script to build a timeline via Wiretap, but when you open Flame, the clips are all \"Checkerboard\" (No Media). Why? Flame is very strict about where it looks for files. When you create a timeline through the IFFFS Wiretap server, Flame uses two rules to find the media: Rule A: The Same Reel Flame expects the source clips to be in the Same Reel as the timeline you are building. If you put the sources in \"Reel 1\" but build the timeline in \"Reel 2,\" Flame might not look in the right place to link them. Rule B: Tape Name Match Flame identifies clips by their Tape Name . - If your media file says its tape name is SHOT_01 , but your script tells the timeline to look for Shot_01 (lowercase), they won't match! - Tip: Always double-check your metadata for typos or case-sensitivity issues. 2. Why use IFFFS for Timelines? Even with these rules, using IFFFS is the fastest way to build complex edits from the outside. Once you ensure your tape names are consistent and your organizational structure is clean, conforms happen instantly across the network. 3. Key Takeaway for Beginners If your media is offline after a Wiretap conform, check your Organization first. Make sure your source clips and your new timeline are \"Neighbors\" in the same reel, and that their Tape Names match exactly, character for character.","title":"Insight: IFFFS Troubleshooting (Unlinked Media)"},{"location":"insight/wiretap_sdk/insight-ifffs_troubleshooting/#insight-ifffs-troubleshooting-unlinked-media","text":"This document explains a common \"Gotcha\" when using Wiretap to build timelines in Flame: why media sometimes appears \"Unlinked\" (Offline). Target Audience: Novice technical artists building automated conforming tools.","title":"Insight: IFFFS Troubleshooting (Unlinked Media)"},{"location":"insight/wiretap_sdk/insight-ifffs_troubleshooting/#1-the-online-mystery","text":"You write a perfect script to build a timeline via Wiretap, but when you open Flame, the clips are all \"Checkerboard\" (No Media). Why? Flame is very strict about where it looks for files. When you create a timeline through the IFFFS Wiretap server, Flame uses two rules to find the media:","title":"1. The \"Online\" Mystery"},{"location":"insight/wiretap_sdk/insight-ifffs_troubleshooting/#rule-a-the-same-reel","text":"Flame expects the source clips to be in the Same Reel as the timeline you are building. If you put the sources in \"Reel 1\" but build the timeline in \"Reel 2,\" Flame might not look in the right place to link them.","title":"Rule A: The Same Reel"},{"location":"insight/wiretap_sdk/insight-ifffs_troubleshooting/#rule-b-tape-name-match","text":"Flame identifies clips by their Tape Name . - If your media file says its tape name is SHOT_01 , but your script tells the timeline to look for Shot_01 (lowercase), they won't match! - Tip: Always double-check your metadata for typos or case-sensitivity issues.","title":"Rule B: Tape Name Match"},{"location":"insight/wiretap_sdk/insight-ifffs_troubleshooting/#2-why-use-ifffs-for-timelines","text":"Even with these rules, using IFFFS is the fastest way to build complex edits from the outside. Once you ensure your tape names are consistent and your organizational structure is clean, conforms happen instantly across the network.","title":"2. Why use IFFFS for Timelines?"},{"location":"insight/wiretap_sdk/insight-ifffs_troubleshooting/#3-key-takeaway-for-beginners","text":"If your media is offline after a Wiretap conform, check your Organization first. Make sure your source clips and your new timeline are \"Neighbors\" in the same reel, and that their Tape Names match exactly, character for character.","title":"3. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-listing_backburner_jobs/","text":"Insight: Listing Backburner Jobs This document explains how to get a simple list of everything currently happening on your render farm. Target Audience: Novice programmers interested in simple network queries. 1. Where do the jobs live? In the Backburner node hierarchy, all jobs are stored in a branch called /jobs . To see what's happening, you don't need to look at every machine; you just ask the Manager to show you the contents of that folder. 2. Using the Command Line The easiest way to see the list is using the wiretap_get_children tool in your terminal: wiretap_get_children -h localhost:Backburner -n /jobs -h : The machine running the Backburner Manager. -n : The folder you want to look at ( /jobs ). 3. What you get back The command will return a list of Node IDs . Each ID represents one job. You can then use those IDs to ask for more specific info (like the name or status) using the metadata commands. 4. Why is this useful? Listing jobs is the first step for any automated tool. - You might write a script that counts how many jobs are currently \"Waiting.\" - You could create a tool that automatically deletes all \"Completed\" jobs every Friday. 5. Key Takeaway for Beginners Listing is the \"Discovery\" phase. Before you can monitor or control a job, you first have to find its ID. The /jobs folder is the central catalog where every task in the studio is recorded.","title":"Insight: Listing Backburner Jobs"},{"location":"insight/wiretap_sdk/insight-listing_backburner_jobs/#insight-listing-backburner-jobs","text":"This document explains how to get a simple list of everything currently happening on your render farm. Target Audience: Novice programmers interested in simple network queries.","title":"Insight: Listing Backburner Jobs"},{"location":"insight/wiretap_sdk/insight-listing_backburner_jobs/#1-where-do-the-jobs-live","text":"In the Backburner node hierarchy, all jobs are stored in a branch called /jobs . To see what's happening, you don't need to look at every machine; you just ask the Manager to show you the contents of that folder.","title":"1. Where do the jobs live?"},{"location":"insight/wiretap_sdk/insight-listing_backburner_jobs/#2-using-the-command-line","text":"The easiest way to see the list is using the wiretap_get_children tool in your terminal: wiretap_get_children -h localhost:Backburner -n /jobs -h : The machine running the Backburner Manager. -n : The folder you want to look at ( /jobs ).","title":"2. Using the Command Line"},{"location":"insight/wiretap_sdk/insight-listing_backburner_jobs/#3-what-you-get-back","text":"The command will return a list of Node IDs . Each ID represents one job. You can then use those IDs to ask for more specific info (like the name or status) using the metadata commands.","title":"3. What you get back"},{"location":"insight/wiretap_sdk/insight-listing_backburner_jobs/#4-why-is-this-useful","text":"Listing jobs is the first step for any automated tool. - You might write a script that counts how many jobs are currently \"Waiting.\" - You could create a tool that automatically deletes all \"Completed\" jobs every Friday.","title":"4. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-listing_backburner_jobs/#5-key-takeaway-for-beginners","text":"Listing is the \"Discovery\" phase. Before you can monitor or control a job, you first have to find its ID. The /jobs folder is the central catalog where every task in the studio is recorded.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-listing_backburner_servers/","text":"Insight: Listing Backburner Servers This document explains how to get a list of every computer (Render Node) currently registered with your Backburner farm. Target Audience: Novice technical artists and IT support. 1. Where do the workers live? In the Backburner node hierarchy, all computers are listed in a branch called /servers . 2. Using the Command Line To see every computer on your farm, use the wiretap_get_children tool: wiretap_get_children -h localhost:Backburner -n /servers -h : The machine running the Backburner Manager. -n : The folder containing the computer list ( /servers ). 3. What you get back The command will return a list of Hostnames (e.g., RenderNode01 , ArtistWorkstation , BladeServer ). You can then use these hostnames to check the health of each machine individually. 4. Why is this useful? Network Audit: Quickly see if any computers have gone missing from the farm. Dynamic Targeting: You can write a script that finds every idle machine and assigns them a high-priority task. Troubleshooting: Confirm that a new computer has successfully \"Joined\" the farm after installation. 5. Key Takeaway for Beginners The /servers node is the \"Staff Roster\" of your studio. It tells you exactly who is available to work. By querying this list, you can keep your studio's rendering resources organized and accounted for.","title":"Insight: Listing Backburner Servers"},{"location":"insight/wiretap_sdk/insight-listing_backburner_servers/#insight-listing-backburner-servers","text":"This document explains how to get a list of every computer (Render Node) currently registered with your Backburner farm. Target Audience: Novice technical artists and IT support.","title":"Insight: Listing Backburner Servers"},{"location":"insight/wiretap_sdk/insight-listing_backburner_servers/#1-where-do-the-workers-live","text":"In the Backburner node hierarchy, all computers are listed in a branch called /servers .","title":"1. Where do the workers live?"},{"location":"insight/wiretap_sdk/insight-listing_backburner_servers/#2-using-the-command-line","text":"To see every computer on your farm, use the wiretap_get_children tool: wiretap_get_children -h localhost:Backburner -n /servers -h : The machine running the Backburner Manager. -n : The folder containing the computer list ( /servers ).","title":"2. Using the Command Line"},{"location":"insight/wiretap_sdk/insight-listing_backburner_servers/#3-what-you-get-back","text":"The command will return a list of Hostnames (e.g., RenderNode01 , ArtistWorkstation , BladeServer ). You can then use these hostnames to check the health of each machine individually.","title":"3. What you get back"},{"location":"insight/wiretap_sdk/insight-listing_backburner_servers/#4-why-is-this-useful","text":"Network Audit: Quickly see if any computers have gone missing from the farm. Dynamic Targeting: You can write a script that finds every idle machine and assigns them a high-priority task. Troubleshooting: Confirm that a new computer has successfully \"Joined\" the farm after installation.","title":"4. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-listing_backburner_servers/#5-key-takeaway-for-beginners","text":"The /servers node is the \"Staff Roster\" of your studio. It tells you exactly who is available to work. By querying this list, you can keep your studio's rendering resources organized and accounted for.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-listing_backburner_wiretap_servers/","text":"Insight: Listing Backburner Wiretap Servers This document explains the naming rules for Wiretap servers and how to find them on your network. Target Audience: Novice technical artists interested in network identification. 1. The Naming Formula Every Wiretap server ID is made of two parts joined by a colon: Hostname : DatabaseType Hostname : The name of the computer (e.g., workstation01 ). DatabaseType : The \"Language\" it speaks. For background rendering, this is always Backburner . Example: workstation01:Backburner 2. Searching the Network You don't have to guess which machines are running Backburner. You can use the wiretap_server_dump command to \"Scan\" the network for specific types of servers: wiretap_server_dump -d Backburner This will return a list of every machine ready to receive render jobs. 3. Testing the Connection If you want to see if your own computer is ready, you can use the \"Loopback\" address: wiretap_ping -h localhost:Backburner 4. Key Takeaway for Beginners Think of the Wiretap ID as a Radio Station . The Hostname is the frequency, and the DatabaseType is the station name. By using the -d Backburner flag, you are tuning your radio to only hear the rendering stations on your network.","title":"Insight: Listing Backburner Wiretap Servers"},{"location":"insight/wiretap_sdk/insight-listing_backburner_wiretap_servers/#insight-listing-backburner-wiretap-servers","text":"This document explains the naming rules for Wiretap servers and how to find them on your network. Target Audience: Novice technical artists interested in network identification.","title":"Insight: Listing Backburner Wiretap Servers"},{"location":"insight/wiretap_sdk/insight-listing_backburner_wiretap_servers/#1-the-naming-formula","text":"Every Wiretap server ID is made of two parts joined by a colon: Hostname : DatabaseType Hostname : The name of the computer (e.g., workstation01 ). DatabaseType : The \"Language\" it speaks. For background rendering, this is always Backburner . Example: workstation01:Backburner","title":"1. The Naming Formula"},{"location":"insight/wiretap_sdk/insight-listing_backburner_wiretap_servers/#2-searching-the-network","text":"You don't have to guess which machines are running Backburner. You can use the wiretap_server_dump command to \"Scan\" the network for specific types of servers: wiretap_server_dump -d Backburner This will return a list of every machine ready to receive render jobs.","title":"2. Searching the Network"},{"location":"insight/wiretap_sdk/insight-listing_backburner_wiretap_servers/#3-testing-the-connection","text":"If you want to see if your own computer is ready, you can use the \"Loopback\" address: wiretap_ping -h localhost:Backburner","title":"3. Testing the Connection"},{"location":"insight/wiretap_sdk/insight-listing_backburner_wiretap_servers/#4-key-takeaway-for-beginners","text":"Think of the Wiretap ID as a Radio Station . The Hostname is the frequency, and the DatabaseType is the station name. By using the -d Backburner flag, you are tuning your radio to only hear the rendering stations on your network.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-macos_library_paths/","text":"Insight: Build Issues on macOS This document explains a specific technical hurdle you might face when writing Wiretap tools on a Mac: managing dynamic library paths. Target Audience: Novice developers using macOS for studio automation. 1. The macOS \"Hardcoded Path\" Rule On most computers (Linux/Windows), when you write a program, it looks for its \"Engine\" files (Libraries) in a standard list of folders. On macOS , libraries ( .dylib files) often have their exact \"Home Address\" baked right into them. By default, the Wiretap library expects to live in /Library/Frameworks . 2. The Problem If you install the Wiretap SDK in a different folder (like your desktop or a custom project folder), your program will crash because it's still looking for the library in the \"Standard\" location. 3. Two Ways to Fix It A. The \"Shortcut\" (Environment Variable) You can tell your computer to look in a different place just for this session by setting the DYLD_LIBRARY_PATH . This is like giving the computer a temporary set of directions. B. The \"Surgery\" ( install_name_tool ) You can use a built-in Mac tool to \"Rewrite\" the library's address permanently. - Command: install_name_tool -id /New/Path/libwiretap.dylib - Verification: You can use the otool -L command to confirm the change. It's like checking the ID card of the library to make sure it has the new address. 4. Key Takeaway for Beginners If your Mac script won't run and says \"Library not found,\" it's probably because of this hardcoded path rule. Before you give up, try using install_name_tool to tell the library exactly where it is currently living on your hard drive.","title":"Insight: Build Issues on macOS"},{"location":"insight/wiretap_sdk/insight-macos_library_paths/#insight-build-issues-on-macos","text":"This document explains a specific technical hurdle you might face when writing Wiretap tools on a Mac: managing dynamic library paths. Target Audience: Novice developers using macOS for studio automation.","title":"Insight: Build Issues on macOS"},{"location":"insight/wiretap_sdk/insight-macos_library_paths/#1-the-macos-hardcoded-path-rule","text":"On most computers (Linux/Windows), when you write a program, it looks for its \"Engine\" files (Libraries) in a standard list of folders. On macOS , libraries ( .dylib files) often have their exact \"Home Address\" baked right into them. By default, the Wiretap library expects to live in /Library/Frameworks .","title":"1. The macOS \"Hardcoded Path\" Rule"},{"location":"insight/wiretap_sdk/insight-macos_library_paths/#2-the-problem","text":"If you install the Wiretap SDK in a different folder (like your desktop or a custom project folder), your program will crash because it's still looking for the library in the \"Standard\" location.","title":"2. The Problem"},{"location":"insight/wiretap_sdk/insight-macos_library_paths/#3-two-ways-to-fix-it","text":"","title":"3. Two Ways to Fix It"},{"location":"insight/wiretap_sdk/insight-macos_library_paths/#a-the-shortcut-environment-variable","text":"You can tell your computer to look in a different place just for this session by setting the DYLD_LIBRARY_PATH . This is like giving the computer a temporary set of directions.","title":"A. The \"Shortcut\" (Environment Variable)"},{"location":"insight/wiretap_sdk/insight-macos_library_paths/#b-the-surgery-install_name_tool","text":"You can use a built-in Mac tool to \"Rewrite\" the library's address permanently. - Command: install_name_tool -id /New/Path/libwiretap.dylib - Verification: You can use the otool -L command to confirm the change. It's like checking the ID card of the library to make sure it has the new address.","title":"B. The \"Surgery\" (install_name_tool)"},{"location":"insight/wiretap_sdk/insight-macos_library_paths/#4-key-takeaway-for-beginners","text":"If your Mac script won't run and says \"Library not found,\" it's probably because of this hardcoded path rule. Before you give up, try using install_name_tool to tell the library exactly where it is currently living on your hard drive.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-managing_clips/","text":"Insight: Managing Clips This document explains how to handle the most important part of Flame: the Clips . Target Audience: Novice programmers interested in media ingestion and organization. 1. Anatomy of a Clip Node In Wiretap, a \"Clip\" is actually a container that holds different versions of the same video: HIRES : The full-quality original images. LOWRES : The small \"Proxy\" versions used for fast playback. SLATE : A shortcut to the smallest version available. AUDIOSTREAM : The sound attached to the video. 2. Ingesting Media (Three Methods) How do you get a movie into a Flame clip via the API? Method A: Writing Frames (The \"Copy\" way) You manually write raw pixels to a new clip. - Use case: Creating a new clip from scratch inside a script. Method B: Soft-Importing (The \"Reference\" way) You tell Flame where the file is on your server. Flame doesn't copy the file; it just \"Points\" to it. - Use case: The standard way to bring camera footage (like R3D or ProRes) into a project. Method C: Path Linking (The \"Direct\" way) You give Flame a list of file paths. This is the fastest way to build a clip from a sequence of images (like 10,000 DPX files). 3. The \"No Overwrite\" Rule Flame is very protective of its media. You cannot overwrite the frames of an existing clip via the API. - The Workflow: If you want to change a clip, you must create a NEW clip, write the new frames to it, and then delete the old one. 4. Key Takeaway for Beginners Clips are the \"Leaves\" of the Flame tree. By using WireTapClipFormat , you define the technical specs, and by using createClipNode , you build the container. Remember: always prefer \"Soft-Importing\" (Method B) to save disk space and time!","title":"Insight: Managing Clips"},{"location":"insight/wiretap_sdk/insight-managing_clips/#insight-managing-clips","text":"This document explains how to handle the most important part of Flame: the Clips . Target Audience: Novice programmers interested in media ingestion and organization.","title":"Insight: Managing Clips"},{"location":"insight/wiretap_sdk/insight-managing_clips/#1-anatomy-of-a-clip-node","text":"In Wiretap, a \"Clip\" is actually a container that holds different versions of the same video: HIRES : The full-quality original images. LOWRES : The small \"Proxy\" versions used for fast playback. SLATE : A shortcut to the smallest version available. AUDIOSTREAM : The sound attached to the video.","title":"1. Anatomy of a Clip Node"},{"location":"insight/wiretap_sdk/insight-managing_clips/#2-ingesting-media-three-methods","text":"How do you get a movie into a Flame clip via the API?","title":"2. Ingesting Media (Three Methods)"},{"location":"insight/wiretap_sdk/insight-managing_clips/#method-a-writing-frames-the-copy-way","text":"You manually write raw pixels to a new clip. - Use case: Creating a new clip from scratch inside a script.","title":"Method A: Writing Frames (The \"Copy\" way)"},{"location":"insight/wiretap_sdk/insight-managing_clips/#method-b-soft-importing-the-reference-way","text":"You tell Flame where the file is on your server. Flame doesn't copy the file; it just \"Points\" to it. - Use case: The standard way to bring camera footage (like R3D or ProRes) into a project.","title":"Method B: Soft-Importing (The \"Reference\" way)"},{"location":"insight/wiretap_sdk/insight-managing_clips/#method-c-path-linking-the-direct-way","text":"You give Flame a list of file paths. This is the fastest way to build a clip from a sequence of images (like 10,000 DPX files).","title":"Method C: Path Linking (The \"Direct\" way)"},{"location":"insight/wiretap_sdk/insight-managing_clips/#3-the-no-overwrite-rule","text":"Flame is very protective of its media. You cannot overwrite the frames of an existing clip via the API. - The Workflow: If you want to change a clip, you must create a NEW clip, write the new frames to it, and then delete the old one.","title":"3. The \"No Overwrite\" Rule"},{"location":"insight/wiretap_sdk/insight-managing_clips/#4-key-takeaway-for-beginners","text":"Clips are the \"Leaves\" of the Flame tree. By using WireTapClipFormat , you define the technical specs, and by using createClipNode , you build the container. Remember: always prefer \"Soft-Importing\" (Method B) to save disk space and time!","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-managing_containers/","text":"Insight: Managing Containers This document explains how to use \"Folders\" (Containers) to keep your Flame projects organized using the API. Target Audience: Novice programmers interested in project management and organization. 1. What are Containers? In Flame, you don't just dump all your clips in one big pile. You organize them using specialized containers: WORKSPACE : A private area for an artist. DESKTOP : The \"Current Work\" area. LIBRARY : A permanent folder for storing clips. REEL : A smaller group inside a library. BATCH : A special container for complex compositing trees. 2. Navigating and Creating Building a studio standard is easy with the API. You can write a script that says: 1. createNode : Build a new Library called \"Renders_V01.\" 2. wiretap_print_tree : Check to make sure it was built in the right place. 3. can_create_node : Ask if it is legal to put a Reel inside this Folder (The API will tell you \"Yes\" or \"No\"). 3. The \"Exclusive Access\" Rule To keep data safe, Wiretap needs Exclusive Access to change a container. - If an artist has a Library open in Flame and is currently editing it, your script will fail if it tries to rename that Library. - Tip: Always check if the node is \"In Use\" before trying to change its structure. 4. Why use Containers? Standardization is key to a professional studio. By using the API to manage containers, you can ensure that every artist in the building has the exact same \"Daily\" and \"Archive\" folders, making it much easier for people to share work. 5. Key Takeaway for Beginners Containers are the \"Infrastructure\" of your project. They don't hold video data directly; they hold the organization that makes the video data easy to find. Use createNode to build your studio's standardized roadmap!","title":"Insight: Managing Containers"},{"location":"insight/wiretap_sdk/insight-managing_containers/#insight-managing-containers","text":"This document explains how to use \"Folders\" (Containers) to keep your Flame projects organized using the API. Target Audience: Novice programmers interested in project management and organization.","title":"Insight: Managing Containers"},{"location":"insight/wiretap_sdk/insight-managing_containers/#1-what-are-containers","text":"In Flame, you don't just dump all your clips in one big pile. You organize them using specialized containers: WORKSPACE : A private area for an artist. DESKTOP : The \"Current Work\" area. LIBRARY : A permanent folder for storing clips. REEL : A smaller group inside a library. BATCH : A special container for complex compositing trees.","title":"1. What are Containers?"},{"location":"insight/wiretap_sdk/insight-managing_containers/#2-navigating-and-creating","text":"Building a studio standard is easy with the API. You can write a script that says: 1. createNode : Build a new Library called \"Renders_V01.\" 2. wiretap_print_tree : Check to make sure it was built in the right place. 3. can_create_node : Ask if it is legal to put a Reel inside this Folder (The API will tell you \"Yes\" or \"No\").","title":"2. Navigating and Creating"},{"location":"insight/wiretap_sdk/insight-managing_containers/#3-the-exclusive-access-rule","text":"To keep data safe, Wiretap needs Exclusive Access to change a container. - If an artist has a Library open in Flame and is currently editing it, your script will fail if it tries to rename that Library. - Tip: Always check if the node is \"In Use\" before trying to change its structure.","title":"3. The \"Exclusive Access\" Rule"},{"location":"insight/wiretap_sdk/insight-managing_containers/#4-why-use-containers","text":"Standardization is key to a professional studio. By using the API to manage containers, you can ensure that every artist in the building has the exact same \"Daily\" and \"Archive\" folders, making it much easier for people to share work.","title":"4. Why use Containers?"},{"location":"insight/wiretap_sdk/insight-managing_containers/#5-key-takeaway-for-beginners","text":"Containers are the \"Infrastructure\" of your project. They don't hold video data directly; they hold the organization that makes the video data easy to find. Use createNode to build your studio's standardized roadmap!","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-managing_projects/","text":"Insight: Managing Projects and Setups This document explains how to use the API to automatically create, configure, and manage Flame projects. Target Audience: Novice programmers interested in project administration. 1. Creating a New Project Creating a project through the API is like using the \"New Project\" window in Flame, but much faster. - Default Settings: If you just give it a name, Flame uses the standard studio defaults. - Custom Settings (XML): You can provide an XML file to specify exactly how the project should look (e.g., \"This job is 4K,\" or \"Use this specific color policy\"). 2. Using Templates If your studio has a standard \"Master Template\" for all jobs, you can tell the API to use it: <Project> <Template>Studio_Commercial_Template</Template> </Project> This ensures every project starts with the right resolution and folder structure. 3. Managing \"Setups\" A Setup is a small file that saves the settings for a specific Flame tool (like a GMask or a Color Correction). - Streaming: Setups can be large. You use the pushStream and pullStream commands to upload or download these files from the project. 4. Deleting Projects Deleting a project is a two-step process: 1. Empty the Project: You must delete all Libraries inside the project first. 2. Destroy the Node: Once empty, you can permanently remove the project from the workstation. 5. Key Takeaway for Beginners The Project API is the \"Architect\" of your workflow. Instead of artists wasting time setting up folders and choosing resolutions, your script can prepare everything perfectly before they even arrive at their desk.","title":"Insight: Managing Projects and Setups"},{"location":"insight/wiretap_sdk/insight-managing_projects/#insight-managing-projects-and-setups","text":"This document explains how to use the API to automatically create, configure, and manage Flame projects. Target Audience: Novice programmers interested in project administration.","title":"Insight: Managing Projects and Setups"},{"location":"insight/wiretap_sdk/insight-managing_projects/#1-creating-a-new-project","text":"Creating a project through the API is like using the \"New Project\" window in Flame, but much faster. - Default Settings: If you just give it a name, Flame uses the standard studio defaults. - Custom Settings (XML): You can provide an XML file to specify exactly how the project should look (e.g., \"This job is 4K,\" or \"Use this specific color policy\").","title":"1. Creating a New Project"},{"location":"insight/wiretap_sdk/insight-managing_projects/#2-using-templates","text":"If your studio has a standard \"Master Template\" for all jobs, you can tell the API to use it: <Project> <Template>Studio_Commercial_Template</Template> </Project> This ensures every project starts with the right resolution and folder structure.","title":"2. Using Templates"},{"location":"insight/wiretap_sdk/insight-managing_projects/#3-managing-setups","text":"A Setup is a small file that saves the settings for a specific Flame tool (like a GMask or a Color Correction). - Streaming: Setups can be large. You use the pushStream and pullStream commands to upload or download these files from the project.","title":"3. Managing \"Setups\""},{"location":"insight/wiretap_sdk/insight-managing_projects/#4-deleting-projects","text":"Deleting a project is a two-step process: 1. Empty the Project: You must delete all Libraries inside the project first. 2. Destroy the Node: Once empty, you can permanently remove the project from the workstation.","title":"4. Deleting Projects"},{"location":"insight/wiretap_sdk/insight-managing_projects/#5-key-takeaway-for-beginners","text":"The Project API is the \"Architect\" of your workflow. Instead of artists wasting time setting up folders and choosing resolutions, your script can prepare everything perfectly before they even arrive at their desk.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-project_metadata_xml/","text":"Insight: Project Metadata (XML) This document explains the XML structure Flame uses to store project settings like resolution, frame rate, and color management. Target Audience: Novice programmers interested in technical specifications and configuration. 1. What is Project Metadata? When you create a new project in Flame, you set certain \"Rules\"\u2014for example, \"This project is 1920x1080 at 24fps.\" Wiretap stores these rules in an XML stream. 2. Key Settings (The XML Tags) When you look at a project's metadata, you will see these important tags: <FrameWidth> / <FrameHeight> : The \"Size\" of your video. <FrameRate> : How fast it plays (e.g., 24 fps or 29.97 fps NDF ). <AspectRatio> : The shape of the screen (e.g., 1.77778 for 16:9). <ProxyQuality> : How Flame generates low-res \"Proxy\" versions of your media. <OCIOConfigFile> : The path to your color management \"Rulebook.\" 3. Editable vs. Fixed Creation Only: Some settings, like where the media is stored ( <MediaDir> ), can ONLY be set when the project is first created. Always Editable: You can change things like the <Description> or <FrameDepth> (8-bit vs 10-bit) any time you want using the setMetaData command. 4. Why is this useful? By reading this XML, a pipeline script can automatically check if a project is set up correctly according to studio standards. If a project is set to \"8-bit\" when it should be \"16-bit fp,\" the script can flag it or even fix it automatically. 5. Key Takeaway for Beginners Project XML is the \"Birth Certificate\" of a Flame project. It lists every important detail about how video should be handled. If you want to automate project creation, you must master these XML tags!","title":"Insight: Project Metadata (XML)"},{"location":"insight/wiretap_sdk/insight-project_metadata_xml/#insight-project-metadata-xml","text":"This document explains the XML structure Flame uses to store project settings like resolution, frame rate, and color management. Target Audience: Novice programmers interested in technical specifications and configuration.","title":"Insight: Project Metadata (XML)"},{"location":"insight/wiretap_sdk/insight-project_metadata_xml/#1-what-is-project-metadata","text":"When you create a new project in Flame, you set certain \"Rules\"\u2014for example, \"This project is 1920x1080 at 24fps.\" Wiretap stores these rules in an XML stream.","title":"1. What is Project Metadata?"},{"location":"insight/wiretap_sdk/insight-project_metadata_xml/#2-key-settings-the-xml-tags","text":"When you look at a project's metadata, you will see these important tags: <FrameWidth> / <FrameHeight> : The \"Size\" of your video. <FrameRate> : How fast it plays (e.g., 24 fps or 29.97 fps NDF ). <AspectRatio> : The shape of the screen (e.g., 1.77778 for 16:9). <ProxyQuality> : How Flame generates low-res \"Proxy\" versions of your media. <OCIOConfigFile> : The path to your color management \"Rulebook.\"","title":"2. Key Settings (The XML Tags)"},{"location":"insight/wiretap_sdk/insight-project_metadata_xml/#3-editable-vs-fixed","text":"Creation Only: Some settings, like where the media is stored ( <MediaDir> ), can ONLY be set when the project is first created. Always Editable: You can change things like the <Description> or <FrameDepth> (8-bit vs 10-bit) any time you want using the setMetaData command.","title":"3. Editable vs. Fixed"},{"location":"insight/wiretap_sdk/insight-project_metadata_xml/#4-why-is-this-useful","text":"By reading this XML, a pipeline script can automatically check if a project is set up correctly according to studio standards. If a project is set to \"8-bit\" when it should be \"16-bit fp,\" the script can flag it or even fix it automatically.","title":"4. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-project_metadata_xml/#5-key-takeaway-for-beginners","text":"Project XML is the \"Birth Certificate\" of a Flame project. It lists every important detail about how video should be handled. If you want to automate project creation, you must master these XML tags!","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-raw_audio_format/","text":"Insight: Raw Audio Format (DL) This document explains how sound is \"Encoded\" when it travels through the Wiretap network. Target Audience: Novice programmers interested in audio engineering and data types. 1. What is Raw Audio? Raw audio is just a long list of numbers representing sound waves. Wiretap calls this the dlaudio format. 2. Key Formats The API supports three main types of numbers for sound: - int16 : CD Quality. - int24 : Studio Quality. - float : High-end processing (Used for internal mixing). 3. Endianness (The \"Big vs Little\" rule) Computers read numbers in different directions. - Big-endian: Reads the most important digit first. - Little-endian ( _le ): Reads the smallest digit first. Wiretap supports both, and your script must check which one the server is using so the sound doesn't come out as static! 4. Multi-Channel Audio If a clip has multiple tracks (like Stereo Left and Right), Wiretap Interlaces them. - Instead of all the Left samples followed by all the Right samples, it sends them in pairs: L, R, L, R, L, R . - This ensures that the left and right speakers stay perfectly in sync. 5. Key Takeaway for Beginners To read audio in Wiretap, you first ask for the formatTag . This tells you if the samples are Integers or Floats, and if they are Big- or Little-Endian. Once you know that, you just \"De-interlace\" the stream to separate the different speakers.","title":"Insight: Raw Audio Format (DL)"},{"location":"insight/wiretap_sdk/insight-raw_audio_format/#insight-raw-audio-format-dl","text":"This document explains how sound is \"Encoded\" when it travels through the Wiretap network. Target Audience: Novice programmers interested in audio engineering and data types.","title":"Insight: Raw Audio Format (DL)"},{"location":"insight/wiretap_sdk/insight-raw_audio_format/#1-what-is-raw-audio","text":"Raw audio is just a long list of numbers representing sound waves. Wiretap calls this the dlaudio format.","title":"1. What is Raw Audio?"},{"location":"insight/wiretap_sdk/insight-raw_audio_format/#2-key-formats","text":"The API supports three main types of numbers for sound: - int16 : CD Quality. - int24 : Studio Quality. - float : High-end processing (Used for internal mixing).","title":"2. Key Formats"},{"location":"insight/wiretap_sdk/insight-raw_audio_format/#3-endianness-the-big-vs-little-rule","text":"Computers read numbers in different directions. - Big-endian: Reads the most important digit first. - Little-endian ( _le ): Reads the smallest digit first. Wiretap supports both, and your script must check which one the server is using so the sound doesn't come out as static!","title":"3. Endianness (The \"Big vs Little\" rule)"},{"location":"insight/wiretap_sdk/insight-raw_audio_format/#4-multi-channel-audio","text":"If a clip has multiple tracks (like Stereo Left and Right), Wiretap Interlaces them. - Instead of all the Left samples followed by all the Right samples, it sends them in pairs: L, R, L, R, L, R . - This ensures that the left and right speakers stay perfectly in sync.","title":"4. Multi-Channel Audio"},{"location":"insight/wiretap_sdk/insight-raw_audio_format/#5-key-takeaway-for-beginners","text":"To read audio in Wiretap, you first ask for the formatTag . This tells you if the samples are Integers or Floats, and if they are Big- or Little-Endian. Once you know that, you just \"De-interlace\" the stream to separate the different speakers.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-raw_rgb_format/","text":"Insight: Raw RGB Video Format This document explains the technical \"Architecture\" of an image frame when it moves through Wiretap. Target Audience: Novice programmers interested in low-level image data and memory management. 1. Pure Pixel Data When you ask Wiretap for a frame, it doesn't give you a file (like a .jpg). It gives you a Buffer \u2014a giant chunk of memory filled with raw color numbers. Orientation: Flame reads images from Bottom to Top . Components: Every pixel has 3 parts: Red, Green, and Blue . 2. Bit Size (Depth) The \"Bit Size\" tells you how much detail is in every color. Wiretap supports several levels: - 8-bit: Standard quality (256 levels of color). - 10-bit: Professional quality (1,024 levels). - 32-bit float: High-end visual effects (Used for complex lighting and HDR). 3. The \"Padding\" Trick Computers like to read data in neat blocks of 32 bits. If your image width isn't a \"Perfect\" number, Wiretap adds invisible Filler Bits (Padding) to the end of every line. - Why? It makes the computer's CPU work much faster because it doesn't have to \"Guess\" where the next line starts. 4. Calculating Memory If you want to know how much RAM you need to hold a frame, use this formula: Width x Height x Bytes per Pixel = Total Memory Example: A 1080p 8-bit frame is about 6 MB . Example: A 4K 32-bit float frame can be over 100 MB ! 5. Key Takeaway for Beginners Raw RGB is like a \"Map of Numbers.\" There are no shortcuts or compression. To use it in your script, you need to know exactly how many bits each color uses and how many \"Filler\" bits are at the end of each line so you don't accidentally shift the image sideways!","title":"Insight: Raw RGB Video Format"},{"location":"insight/wiretap_sdk/insight-raw_rgb_format/#insight-raw-rgb-video-format","text":"This document explains the technical \"Architecture\" of an image frame when it moves through Wiretap. Target Audience: Novice programmers interested in low-level image data and memory management.","title":"Insight: Raw RGB Video Format"},{"location":"insight/wiretap_sdk/insight-raw_rgb_format/#1-pure-pixel-data","text":"When you ask Wiretap for a frame, it doesn't give you a file (like a .jpg). It gives you a Buffer \u2014a giant chunk of memory filled with raw color numbers. Orientation: Flame reads images from Bottom to Top . Components: Every pixel has 3 parts: Red, Green, and Blue .","title":"1. Pure Pixel Data"},{"location":"insight/wiretap_sdk/insight-raw_rgb_format/#2-bit-size-depth","text":"The \"Bit Size\" tells you how much detail is in every color. Wiretap supports several levels: - 8-bit: Standard quality (256 levels of color). - 10-bit: Professional quality (1,024 levels). - 32-bit float: High-end visual effects (Used for complex lighting and HDR).","title":"2. Bit Size (Depth)"},{"location":"insight/wiretap_sdk/insight-raw_rgb_format/#3-the-padding-trick","text":"Computers like to read data in neat blocks of 32 bits. If your image width isn't a \"Perfect\" number, Wiretap adds invisible Filler Bits (Padding) to the end of every line. - Why? It makes the computer's CPU work much faster because it doesn't have to \"Guess\" where the next line starts.","title":"3. The \"Padding\" Trick"},{"location":"insight/wiretap_sdk/insight-raw_rgb_format/#4-calculating-memory","text":"If you want to know how much RAM you need to hold a frame, use this formula: Width x Height x Bytes per Pixel = Total Memory Example: A 1080p 8-bit frame is about 6 MB . Example: A 4K 32-bit float frame can be over 100 MB !","title":"4. Calculating Memory"},{"location":"insight/wiretap_sdk/insight-raw_rgb_format/#5-key-takeaway-for-beginners","text":"Raw RGB is like a \"Map of Numbers.\" There are no shortcuts or compression. To use it in your script, you need to know exactly how many bits each color uses and how many \"Filler\" bits are at the end of each line so you don't accidentally shift the image sideways!","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-sending_backburner_attachments/","text":"Insight: Sending Job Attachments This document explains how to send large files (like 3D scenes or color LUTs) along with your render job to the farm. Target Audience: Novice programmers interested in data transfer and complex job submission. 1. Metadata vs. Streams Metadata ( details ): Use this for small text instructions (e.g., \"Render Frame 1 to 10\"). Streams ( pushStream ): Use this for large or binary files (e.g., a 500MB project file or a complex texture). 2. The \"Push\" Workflow If your render needs a specific file to work, you don't just tell Backburner where the file is on your computer. You Upload the file to the Backburner Manager. Prepare: Compress your file (e.g., zip it) to make the upload faster. Push: Use the pushStream command to send the file to the Manager. Deploy: When a worker computer (Server) starts your job, the Manager automatically hands it the attachment so it has everything it needs to render. 3. Why is this useful? It ensures that the render farm doesn't need access to your personal computer's hard drive. By \"Attaching\" the files to the job, you are making the job Self-Contained . This is the only way to reliably render complex projects on a large, multi-machine farm. 4. Key Takeaway for Beginners Attachments are the \"Backpack\" for your job. You fill the backpack with all the tools and maps the worker needs, then hand it to the Manager. No matter which machine in the studio does the work, they'll have the backpack ready to go.","title":"Insight: Sending Job Attachments"},{"location":"insight/wiretap_sdk/insight-sending_backburner_attachments/#insight-sending-job-attachments","text":"This document explains how to send large files (like 3D scenes or color LUTs) along with your render job to the farm. Target Audience: Novice programmers interested in data transfer and complex job submission.","title":"Insight: Sending Job Attachments"},{"location":"insight/wiretap_sdk/insight-sending_backburner_attachments/#1-metadata-vs-streams","text":"Metadata ( details ): Use this for small text instructions (e.g., \"Render Frame 1 to 10\"). Streams ( pushStream ): Use this for large or binary files (e.g., a 500MB project file or a complex texture).","title":"1. Metadata vs. Streams"},{"location":"insight/wiretap_sdk/insight-sending_backburner_attachments/#2-the-push-workflow","text":"If your render needs a specific file to work, you don't just tell Backburner where the file is on your computer. You Upload the file to the Backburner Manager. Prepare: Compress your file (e.g., zip it) to make the upload faster. Push: Use the pushStream command to send the file to the Manager. Deploy: When a worker computer (Server) starts your job, the Manager automatically hands it the attachment so it has everything it needs to render.","title":"2. The \"Push\" Workflow"},{"location":"insight/wiretap_sdk/insight-sending_backburner_attachments/#3-why-is-this-useful","text":"It ensures that the render farm doesn't need access to your personal computer's hard drive. By \"Attaching\" the files to the job, you are making the job Self-Contained . This is the only way to reliably render complex projects on a large, multi-machine farm.","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-sending_backburner_attachments/#4-key-takeaway-for-beginners","text":"Attachments are the \"Backpack\" for your job. You fill the backpack with all the tools and maps the worker needs, then hand it to the Manager. No matter which machine in the studio does the work, they'll have the backpack ready to go.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-server_discovery/","text":"Insight: Discovering Wiretap Servers This document explains the \"Three IDs\" Wiretap uses to find and remember machines on your network. Target Audience: Novice technical artists interested in network persistence. 1. The Server ID (The \"Nickname\") The Server ID is what you use to connect for the first time. - Formula: Hostname : ServerType (e.g., Workstation01:IFFFS ). - Flexible: You can use the computer's name OR its IP address (e.g., 192.168.1.50:IFFFS ). 2. The Host UUID (The \"Social Security Number\") A computer's name might change (e.g., if it moves to a different office), but its Host UUID never changes. - Why use it? If you have a script that needs to find the exact same computer every day, use the UUID. It identifies the hardware, not the network name. 3. The Storage ID (The \"Briefcase ID\") A Storage ID identifies the Hard Drive Array connected to a server. - Persistence: If a studio moves a hard drive from \"Computer A\" to \"Computer B,\" the Storage ID stays the same. - The Rule: Professional tools always remember the Storage ID . That way, if the network changes, the script can just scan the network and say: \"Who is holding the briefcase with ID #1234?\" and find the data instantly. 4. Key Takeaway for Beginners To connect to a server today, use the Server ID . To make your script work tomorrow (even if the computer is renamed), ask the server for its Storage ID and save that ID in your database.","title":"Insight: Discovering Wiretap Servers"},{"location":"insight/wiretap_sdk/insight-server_discovery/#insight-discovering-wiretap-servers","text":"This document explains the \"Three IDs\" Wiretap uses to find and remember machines on your network. Target Audience: Novice technical artists interested in network persistence.","title":"Insight: Discovering Wiretap Servers"},{"location":"insight/wiretap_sdk/insight-server_discovery/#1-the-server-id-the-nickname","text":"The Server ID is what you use to connect for the first time. - Formula: Hostname : ServerType (e.g., Workstation01:IFFFS ). - Flexible: You can use the computer's name OR its IP address (e.g., 192.168.1.50:IFFFS ).","title":"1. The Server ID (The \"Nickname\")"},{"location":"insight/wiretap_sdk/insight-server_discovery/#2-the-host-uuid-the-social-security-number","text":"A computer's name might change (e.g., if it moves to a different office), but its Host UUID never changes. - Why use it? If you have a script that needs to find the exact same computer every day, use the UUID. It identifies the hardware, not the network name.","title":"2. The Host UUID (The \"Social Security Number\")"},{"location":"insight/wiretap_sdk/insight-server_discovery/#3-the-storage-id-the-briefcase-id","text":"A Storage ID identifies the Hard Drive Array connected to a server. - Persistence: If a studio moves a hard drive from \"Computer A\" to \"Computer B,\" the Storage ID stays the same. - The Rule: Professional tools always remember the Storage ID . That way, if the network changes, the script can just scan the network and say: \"Who is holding the briefcase with ID #1234?\" and find the data instantly.","title":"3. The Storage ID (The \"Briefcase ID\")"},{"location":"insight/wiretap_sdk/insight-server_discovery/#4-key-takeaway-for-beginners","text":"To connect to a server today, use the Server ID . To make your script work tomorrow (even if the computer is renamed), ask the server for its Storage ID and save that ID in your database.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-setup_cpp/","text":"Insight: Setting up for C++ Developers This document explains the technical \"Ingredients\" you need to build a high-performance Wiretap program in C++. Target Audience: Novice developers interested in low-level systems programming. 1. The Ingredients (Headers and Libraries) To bake a C++ program, you need two things from the SDK: 1. Headers ( .h files): These are in the api/ folder. They tell your code which functions are available. 2. Libraries ( .a or .dylib files): These are in the lib/ folder. They are the \"Engine\" that does the work. 2. Compiling your Code Compiling is the process of turning your human-readable code into a program the computer can run. On Linux (Using GCC): You must link your code against the Wiretap library and standard network tools: g++ my_code.C -o my_app -I ../api ../lib/libwiretapClientAPI.a -lpthread On macOS (Using Clang): It's very similar, but you also need to include Apple's \"Carbon\" and \"SystemConfiguration\" frameworks so Wiretap can talk to the Mac's network settings. 3. Why use C++? C++ is the fastest way to talk to Flame. If your tool needs to move thousands of 4K frames every minute, C++ will give you much better performance than Python. 4. Key Takeaway for Beginners C++ development is like \"Custom Engine Building.\" It's more complex than Python, and you have to manually \"Wire up\" the headers and libraries during compilation. But once it's built, you have the most powerful and efficient tool possible for managing your Flame studio.","title":"Insight: Setting up for C++ Developers"},{"location":"insight/wiretap_sdk/insight-setup_cpp/#insight-setting-up-for-c-developers","text":"This document explains the technical \"Ingredients\" you need to build a high-performance Wiretap program in C++. Target Audience: Novice developers interested in low-level systems programming.","title":"Insight: Setting up for C++ Developers"},{"location":"insight/wiretap_sdk/insight-setup_cpp/#1-the-ingredients-headers-and-libraries","text":"To bake a C++ program, you need two things from the SDK: 1. Headers ( .h files): These are in the api/ folder. They tell your code which functions are available. 2. Libraries ( .a or .dylib files): These are in the lib/ folder. They are the \"Engine\" that does the work.","title":"1. The Ingredients (Headers and Libraries)"},{"location":"insight/wiretap_sdk/insight-setup_cpp/#2-compiling-your-code","text":"Compiling is the process of turning your human-readable code into a program the computer can run.","title":"2. Compiling your Code"},{"location":"insight/wiretap_sdk/insight-setup_cpp/#on-linux-using-gcc","text":"You must link your code against the Wiretap library and standard network tools: g++ my_code.C -o my_app -I ../api ../lib/libwiretapClientAPI.a -lpthread","title":"On Linux (Using GCC):"},{"location":"insight/wiretap_sdk/insight-setup_cpp/#on-macos-using-clang","text":"It's very similar, but you also need to include Apple's \"Carbon\" and \"SystemConfiguration\" frameworks so Wiretap can talk to the Mac's network settings.","title":"On macOS (Using Clang):"},{"location":"insight/wiretap_sdk/insight-setup_cpp/#3-why-use-c","text":"C++ is the fastest way to talk to Flame. If your tool needs to move thousands of 4K frames every minute, C++ will give you much better performance than Python.","title":"3. Why use C++?"},{"location":"insight/wiretap_sdk/insight-setup_cpp/#4-key-takeaway-for-beginners","text":"C++ development is like \"Custom Engine Building.\" It's more complex than Python, and you have to manually \"Wire up\" the headers and libraries during compilation. But once it's built, you have the most powerful and efficient tool possible for managing your Flame studio.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-setup_python/","text":"Insight: Setting up for Python Developers This document explains the easiest way to start writing scripts for Flame using the Python language. Target Audience: Novice programmers interested in rapid automation. 1. The Easiest Way: Use Flame's Python You don't need to install Python yourself! Every Flame workstation already has a professional Python environment installed. - Location: /opt/Autodesk/python/<version>/bin/python - Why use it? It already has the Wiretap libraries pre-installed and ready to go. You can just start writing code! 2. Using External Python If you want to use your own version of Python (like Python 3.11), you can do that too. - You just need to \"Link\" the Wiretap library by copying the libwiretapPythonClientAPI.so file from the SDK into your Python's site-packages folder. 3. How to get Help (The Python Way) The SDK doesn't include a separate manual for Python. Instead, you can ask Python to \"Explain\" itself: Open Python in your terminal. Import the library: import libwiretapPythonClientAPI as wiretap Ask for a list of classes: dir(wiretap) Ask for instructions on a specific tool: help(wiretap.WireTapNodeHandle) 4. Key Takeaway for Beginners Python is the \"Speed Demon\" of development. You don't have to compile your code, and you can get immediate answers using the help() command. If you want to build a tool quickly, always start with Python!","title":"Insight: Setting up for Python Developers"},{"location":"insight/wiretap_sdk/insight-setup_python/#insight-setting-up-for-python-developers","text":"This document explains the easiest way to start writing scripts for Flame using the Python language. Target Audience: Novice programmers interested in rapid automation.","title":"Insight: Setting up for Python Developers"},{"location":"insight/wiretap_sdk/insight-setup_python/#1-the-easiest-way-use-flames-python","text":"You don't need to install Python yourself! Every Flame workstation already has a professional Python environment installed. - Location: /opt/Autodesk/python/<version>/bin/python - Why use it? It already has the Wiretap libraries pre-installed and ready to go. You can just start writing code!","title":"1. The Easiest Way: Use Flame's Python"},{"location":"insight/wiretap_sdk/insight-setup_python/#2-using-external-python","text":"If you want to use your own version of Python (like Python 3.11), you can do that too. - You just need to \"Link\" the Wiretap library by copying the libwiretapPythonClientAPI.so file from the SDK into your Python's site-packages folder.","title":"2. Using External Python"},{"location":"insight/wiretap_sdk/insight-setup_python/#3-how-to-get-help-the-python-way","text":"The SDK doesn't include a separate manual for Python. Instead, you can ask Python to \"Explain\" itself: Open Python in your terminal. Import the library: import libwiretapPythonClientAPI as wiretap Ask for a list of classes: dir(wiretap) Ask for instructions on a specific tool: help(wiretap.WireTapNodeHandle)","title":"3. How to get Help (The Python Way)"},{"location":"insight/wiretap_sdk/insight-setup_python/#4-key-takeaway-for-beginners","text":"Python is the \"Speed Demon\" of development. You don't have to compile your code, and you can get immediate answers using the help() command. If you want to build a tool quickly, always start with Python!","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-traversing_nodes/","text":"Insight: Traversing and Modifying Nodes This document explains how to \"Walk\" through Flame's database and change things using the Wiretap SDK. Target Audience: Novice programmers learning about object manipulation and navigation. 1. The Node Handle ( WireTapNodeHandle ) In Wiretap, you don't \"touch\" a clip directly. Instead, you use a Handle . - Think of a Handle like a Remote Control . You point it at a node (like a clip or project) and press buttons to \"Rename,\" \"Delete,\" or \"Copy\" it. Important Rule: Handles are not \"Live.\" If an artist in Flame renames a clip while your script is running, your handle won't know unless you specifically ask it to refresh. 2. Navigating the Tree To find a specific clip, you use these basic commands: - wiretap_get_root_node : Start at the very top (The Trunk). - wiretap_get_children : See everything \"inside\" the current node. - wiretap_get_parent_node : Move back up one level. 3. Creating and Deleting createNode : Use this to build new Projects or Libraries. createClipNode : A special command just for making clips. destroyNode : The \"Delete\" button. Be careful\u2014this is permanent! 4. Metadata: Reading the \"Tag\" Every node has a Metadata Stream . This is usually an XML file that describes the node. - getMetaData : Read the info (e.g., \"What is the frame rate of this clip?\"). - setMetaData : Write new info (e.g., \"Change the description of this project\"). 5. Key Takeaway for Beginners Think of traversing like using Finder or Windows Explorer , but with code. You \"Open folders\" (Nodes) and \"Read files\" (Metadata) until you find exactly what you are looking for. Once you have the right Node ID , you can use your Handle to modify it.","title":"Insight: Traversing and Modifying Nodes"},{"location":"insight/wiretap_sdk/insight-traversing_nodes/#insight-traversing-and-modifying-nodes","text":"This document explains how to \"Walk\" through Flame's database and change things using the Wiretap SDK. Target Audience: Novice programmers learning about object manipulation and navigation.","title":"Insight: Traversing and Modifying Nodes"},{"location":"insight/wiretap_sdk/insight-traversing_nodes/#1-the-node-handle-wiretapnodehandle","text":"In Wiretap, you don't \"touch\" a clip directly. Instead, you use a Handle . - Think of a Handle like a Remote Control . You point it at a node (like a clip or project) and press buttons to \"Rename,\" \"Delete,\" or \"Copy\" it. Important Rule: Handles are not \"Live.\" If an artist in Flame renames a clip while your script is running, your handle won't know unless you specifically ask it to refresh.","title":"1. The Node Handle (WireTapNodeHandle)"},{"location":"insight/wiretap_sdk/insight-traversing_nodes/#2-navigating-the-tree","text":"To find a specific clip, you use these basic commands: - wiretap_get_root_node : Start at the very top (The Trunk). - wiretap_get_children : See everything \"inside\" the current node. - wiretap_get_parent_node : Move back up one level.","title":"2. Navigating the Tree"},{"location":"insight/wiretap_sdk/insight-traversing_nodes/#3-creating-and-deleting","text":"createNode : Use this to build new Projects or Libraries. createClipNode : A special command just for making clips. destroyNode : The \"Delete\" button. Be careful\u2014this is permanent!","title":"3. Creating and Deleting"},{"location":"insight/wiretap_sdk/insight-traversing_nodes/#4-metadata-reading-the-tag","text":"Every node has a Metadata Stream . This is usually an XML file that describes the node. - getMetaData : Read the info (e.g., \"What is the frame rate of this clip?\"). - setMetaData : Write new info (e.g., \"Change the description of this project\").","title":"4. Metadata: Reading the \"Tag\""},{"location":"insight/wiretap_sdk/insight-traversing_nodes/#5-key-takeaway-for-beginners","text":"Think of traversing like using Finder or Windows Explorer , but with code. You \"Open folders\" (Nodes) and \"Read files\" (Metadata) until you find exactly what you are looking for. Once you have the right Node ID , you can use your Handle to modify it.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-typical_workflows_overview/","text":"Insight: Programming Typical Workflows This document provides an overview of the \"Job Roles\" the Wiretap SDK can perform in your studio. Target Audience: Novice programmers and pipeline technical directors. 1. What can you automate? The Wiretap SDK isn't just for reading data; it's for Taking Action . The typical workflows are divided into three main categories: A. Managing Projects Automatically create new projects, set their resolution and frame rate, and prepare the workspace for the artist. B. Managing Containers Organize your project by creating Libraries, Folders, and Reels. You can build a script that sets up a standardized folder structure for every new job. C. Managing Clips The most common task. Use the API to: - Soft-import media from a server. - Rename or delete old versions. - Build timelines automatically from an EDL. 2. Choosing your Server The workflow you choose depends on which \"Librarian\" you talk to: - Talk to IFFFS to manage Flame's internal database. - Talk to Gateway to browse and ingest files from your hard drives. - Talk to Backburner to handle the rendering of your work. 3. Key Takeaway for Beginners Think of typical workflows as \"Tool Templates.\" Whether you want to build a \"Project Creator\" or a \"Media Browser,\" the SDK documentation provides the logical steps and sample code to get you started.","title":"Insight: Programming Typical Workflows"},{"location":"insight/wiretap_sdk/insight-typical_workflows_overview/#insight-programming-typical-workflows","text":"This document provides an overview of the \"Job Roles\" the Wiretap SDK can perform in your studio. Target Audience: Novice programmers and pipeline technical directors.","title":"Insight: Programming Typical Workflows"},{"location":"insight/wiretap_sdk/insight-typical_workflows_overview/#1-what-can-you-automate","text":"The Wiretap SDK isn't just for reading data; it's for Taking Action . The typical workflows are divided into three main categories:","title":"1. What can you automate?"},{"location":"insight/wiretap_sdk/insight-typical_workflows_overview/#a-managing-projects","text":"Automatically create new projects, set their resolution and frame rate, and prepare the workspace for the artist.","title":"A. Managing Projects"},{"location":"insight/wiretap_sdk/insight-typical_workflows_overview/#b-managing-containers","text":"Organize your project by creating Libraries, Folders, and Reels. You can build a script that sets up a standardized folder structure for every new job.","title":"B. Managing Containers"},{"location":"insight/wiretap_sdk/insight-typical_workflows_overview/#c-managing-clips","text":"The most common task. Use the API to: - Soft-import media from a server. - Rename or delete old versions. - Build timelines automatically from an EDL.","title":"C. Managing Clips"},{"location":"insight/wiretap_sdk/insight-typical_workflows_overview/#2-choosing-your-server","text":"The workflow you choose depends on which \"Librarian\" you talk to: - Talk to IFFFS to manage Flame's internal database. - Talk to Gateway to browse and ingest files from your hard drives. - Talk to Backburner to handle the rendering of your work.","title":"2. Choosing your Server"},{"location":"insight/wiretap_sdk/insight-typical_workflows_overview/#3-key-takeaway-for-beginners","text":"Think of typical workflows as \"Tool Templates.\" Whether you want to build a \"Project Creator\" or a \"Media Browser,\" the SDK documentation provides the logical steps and sample code to get you started.","title":"3. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-understanding_wiretap/","text":"Insight: Understanding Wiretap This document explains the Wiretap framework in Autodesk Flame. It is the \"Communication Layer\" that allows different software and servers to talk to each other and share media. Target Audience: Novice programmers and technical artists interested in network storage and interoperability. 1. What is Wiretap? Wiretap is a high-performance system used to move media (video/audio) and metadata (info about clips) across a network. Think of it as a \"Universal Language\" for the Flame ecosystem. Whether you are using a Python script, a web browser, or another Flame workstation, Wiretap allows you to \"reach into\" a database and grab exactly what you need without manually copying files. 2. The Core Pillars Wiretap is built on three main sections: Wiretap Terminology: The basic words you need to know (Servers, Clients, Nodes). Server/Client Roles: How the different parts of the system interact. Self-Discovery: How Wiretap \"finds\" other machines on your network automatically. 3. Why is this useful? Without Wiretap, you would have to manually find clips on a hard drive, remember which folder they are in, and hope you don't break the database. With Wiretap: - You can write a script that says: \"Find me the 'Final Render' in the 'Summer Commercial' project.\" - Wiretap finds it instantly, no matter which server it is stored on. - You can stream that media directly into your script for processing. 4. Key Takeaway for Beginners Wiretap turns your studio from a collection of \"Hard Drives and Folders\" into a Unified Database . It is the technology that makes collaborative workflows possible in a professional post-production environment.","title":"Insight: Understanding Wiretap"},{"location":"insight/wiretap_sdk/insight-understanding_wiretap/#insight-understanding-wiretap","text":"This document explains the Wiretap framework in Autodesk Flame. It is the \"Communication Layer\" that allows different software and servers to talk to each other and share media. Target Audience: Novice programmers and technical artists interested in network storage and interoperability.","title":"Insight: Understanding Wiretap"},{"location":"insight/wiretap_sdk/insight-understanding_wiretap/#1-what-is-wiretap","text":"Wiretap is a high-performance system used to move media (video/audio) and metadata (info about clips) across a network. Think of it as a \"Universal Language\" for the Flame ecosystem. Whether you are using a Python script, a web browser, or another Flame workstation, Wiretap allows you to \"reach into\" a database and grab exactly what you need without manually copying files.","title":"1. What is Wiretap?"},{"location":"insight/wiretap_sdk/insight-understanding_wiretap/#2-the-core-pillars","text":"Wiretap is built on three main sections: Wiretap Terminology: The basic words you need to know (Servers, Clients, Nodes). Server/Client Roles: How the different parts of the system interact. Self-Discovery: How Wiretap \"finds\" other machines on your network automatically.","title":"2. The Core Pillars"},{"location":"insight/wiretap_sdk/insight-understanding_wiretap/#3-why-is-this-useful","text":"Without Wiretap, you would have to manually find clips on a hard drive, remember which folder they are in, and hope you don't break the database. With Wiretap: - You can write a script that says: \"Find me the 'Final Render' in the 'Summer Commercial' project.\" - Wiretap finds it instantly, no matter which server it is stored on. - You can stream that media directly into your script for processing.","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-understanding_wiretap/#4-key-takeaway-for-beginners","text":"Wiretap turns your studio from a collection of \"Hard Drives and Folders\" into a Unified Database . It is the technology that makes collaborative workflows possible in a professional post-production environment.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-using_command_line_tools/","text":"Insight: Using Command Line Tools This document explains how to use the pre-built programs included in the SDK to test your network and \"See\" inside Flame without writing any code. Target Audience: Novice developers and technical artists. 1. Where are the tools? Autodesk keeps the current version of the tools in a standard location on your computer: /opt/Autodesk/wiretap/tools/current/ 2. Three Essential Tools A. wiretap_ping The \"Hello, World\" of Wiretap. It checks if a machine is alive and speaking the Wiretap language. - Command: wiretap_ping -h <machine_name> B. wiretap_server_dump The \"Radar.\" it scans your entire network and shows you every Flame workstation, Gateway, and Backburner Manager. - Command: wiretap_server_dump C. wiretap_print_tree The \"X-Ray.\" It prints out the entire organizational structure of a workstation, showing every Project, Library, and Clip. - Command: wiretap_print_tree -h <machine_name> -d 2 (The -d 2 tells it to only go two levels deep). 3. How to get help Every tool has a manual built right in. Just type the command followed by --help : wiretap_ping --help 4. Why use these tools? Before you start writing a complex script to delete old projects, use wiretap_print_tree to make sure you can \"See\" those projects first. It\u2019s the best way to verify that your network and permissions are set up correctly. 5. Key Takeaway for Beginners The command-line tools are your \"Sanity Check.\" If you can't see a workstation with wiretap_server_dump , your script won't be able to see it either. Always use these tools to confirm your network is working before you spend time writing custom code.","title":"Insight: Using Command Line Tools"},{"location":"insight/wiretap_sdk/insight-using_command_line_tools/#insight-using-command-line-tools","text":"This document explains how to use the pre-built programs included in the SDK to test your network and \"See\" inside Flame without writing any code. Target Audience: Novice developers and technical artists.","title":"Insight: Using Command Line Tools"},{"location":"insight/wiretap_sdk/insight-using_command_line_tools/#1-where-are-the-tools","text":"Autodesk keeps the current version of the tools in a standard location on your computer: /opt/Autodesk/wiretap/tools/current/","title":"1. Where are the tools?"},{"location":"insight/wiretap_sdk/insight-using_command_line_tools/#2-three-essential-tools","text":"","title":"2. Three Essential Tools"},{"location":"insight/wiretap_sdk/insight-using_command_line_tools/#a-wiretap_ping","text":"The \"Hello, World\" of Wiretap. It checks if a machine is alive and speaking the Wiretap language. - Command: wiretap_ping -h <machine_name>","title":"A. wiretap_ping"},{"location":"insight/wiretap_sdk/insight-using_command_line_tools/#b-wiretap_server_dump","text":"The \"Radar.\" it scans your entire network and shows you every Flame workstation, Gateway, and Backburner Manager. - Command: wiretap_server_dump","title":"B. wiretap_server_dump"},{"location":"insight/wiretap_sdk/insight-using_command_line_tools/#c-wiretap_print_tree","text":"The \"X-Ray.\" It prints out the entire organizational structure of a workstation, showing every Project, Library, and Clip. - Command: wiretap_print_tree -h <machine_name> -d 2 (The -d 2 tells it to only go two levels deep).","title":"C. wiretap_print_tree"},{"location":"insight/wiretap_sdk/insight-using_command_line_tools/#3-how-to-get-help","text":"Every tool has a manual built right in. Just type the command followed by --help : wiretap_ping --help","title":"3. How to get help"},{"location":"insight/wiretap_sdk/insight-using_command_line_tools/#4-why-use-these-tools","text":"Before you start writing a complex script to delete old projects, use wiretap_print_tree to make sure you can \"See\" those projects first. It\u2019s the best way to verify that your network and permissions are set up correctly.","title":"4. Why use these tools?"},{"location":"insight/wiretap_sdk/insight-using_command_line_tools/#5-key-takeaway-for-beginners","text":"The command-line tools are your \"Sanity Check.\" If you can't see a workstation with wiretap_server_dump , your script won't be able to see it either. Always use these tools to confirm your network is working before you spend time writing custom code.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-using_sample_programs/","text":"Insight: Using Sample Programs This document explains how to use the \"Ready-Made\" examples inside the SDK to learn the Wiretap language faster. Target Audience: Novice programmers looking for code templates. 1. The SDK \"Cheat Sheet\" The SDK comes with a folder called samples/ . These are small, focused scripts written by Autodesk engineers. They are the best way to see the \"Best Practices\" for using the API. 2. Two Recommended First Samples A. listAllServers This sample does exactly what it says: it scans your network and prints a list of every workstation. - What you'll learn: How to initialize the API and how to use the \"Multicast\" discovery system. B. listChildren This sample lets you \"Drill Down\" into a project. You give it a starting point (like a Project name), and it lists everything inside. - What you'll learn: How to navigate the tree-like structure of a Flame workstation. 3. How to use them Don't just run them! Read them. - Open the .py or .C files in a text editor. - Look for the WireTapClientInit() function (The \"Start\" button) and the WireTapClientUninit() function (The \"Stop\" button). - You can literally \"Cut and Paste\" these blocks of code into your own project. 4. Key Takeaway for Beginners The sample programs are your \"Building Blocks.\" You don't need to invent everything from scratch. If you want to build a tool that renames clips, find the sample that lists clips, copy that code, and then add your renaming logic on top of it.","title":"Insight: Using Sample Programs"},{"location":"insight/wiretap_sdk/insight-using_sample_programs/#insight-using-sample-programs","text":"This document explains how to use the \"Ready-Made\" examples inside the SDK to learn the Wiretap language faster. Target Audience: Novice programmers looking for code templates.","title":"Insight: Using Sample Programs"},{"location":"insight/wiretap_sdk/insight-using_sample_programs/#1-the-sdk-cheat-sheet","text":"The SDK comes with a folder called samples/ . These are small, focused scripts written by Autodesk engineers. They are the best way to see the \"Best Practices\" for using the API.","title":"1. The SDK \"Cheat Sheet\""},{"location":"insight/wiretap_sdk/insight-using_sample_programs/#2-two-recommended-first-samples","text":"","title":"2. Two Recommended First Samples"},{"location":"insight/wiretap_sdk/insight-using_sample_programs/#a-listallservers","text":"This sample does exactly what it says: it scans your network and prints a list of every workstation. - What you'll learn: How to initialize the API and how to use the \"Multicast\" discovery system.","title":"A. listAllServers"},{"location":"insight/wiretap_sdk/insight-using_sample_programs/#b-listchildren","text":"This sample lets you \"Drill Down\" into a project. You give it a starting point (like a Project name), and it lists everything inside. - What you'll learn: How to navigate the tree-like structure of a Flame workstation.","title":"B. listChildren"},{"location":"insight/wiretap_sdk/insight-using_sample_programs/#3-how-to-use-them","text":"Don't just run them! Read them. - Open the .py or .C files in a text editor. - Look for the WireTapClientInit() function (The \"Start\" button) and the WireTapClientUninit() function (The \"Stop\" button). - You can literally \"Cut and Paste\" these blocks of code into your own project.","title":"3. How to use them"},{"location":"insight/wiretap_sdk/insight-using_sample_programs/#4-key-takeaway-for-beginners","text":"The sample programs are your \"Building Blocks.\" You don't need to invent everything from scratch. If you want to build a tool that renames clips, find the sample that lists clips, copy that code, and then add your renaming logic on top of it.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_audio_io/","text":"Insight: Reading Audio Media This document explains how Wiretap handles audio data and how it differs from video data. Target Audience: Novice programmers interested in audio processing and network efficiency. 1. Small Data, Big Network Audio data is tiny compared to video. - Video: 1 second of video can be 30MB or more. - Audio: 1 second of audio is only about 172KB. If you asked Wiretap for every single audio sample one-by-one, the network would get \"Clogged\" with thousands of tiny requests. 2. The \"Block\" Solution To keep things fast, Wiretap doesn't send audio sample-by-sample. Instead, it groups samples together into Blocks (called \"Frames\" in the API). When you ask for an \"Audio Frame,\" you are actually getting a chunk of sound\u2014usually enough to match exactly one frame of video. The size of these blocks is determined by the WireTapClipFormat . It tells your script: \"This block has 2,000 samples of 16-bit audio.\" 3. Why is this useful? This ensures that audio and video stay perfectly in sync. Because one \"Frame\" of audio matches one \"Frame\" of video, your script can process them together without having to do complex math to align the timing. 4. Key Takeaway for Beginners In Wiretap, Audio is treated like Video . You ask for a \"Frame\" of audio just like you would for a picture. The API handles the grouping of tiny samples into efficient blocks so your network stays fast and your sound stays in sync.","title":"Insight: Reading Audio Media"},{"location":"insight/wiretap_sdk/insight-wiretap_audio_io/#insight-reading-audio-media","text":"This document explains how Wiretap handles audio data and how it differs from video data. Target Audience: Novice programmers interested in audio processing and network efficiency.","title":"Insight: Reading Audio Media"},{"location":"insight/wiretap_sdk/insight-wiretap_audio_io/#1-small-data-big-network","text":"Audio data is tiny compared to video. - Video: 1 second of video can be 30MB or more. - Audio: 1 second of audio is only about 172KB. If you asked Wiretap for every single audio sample one-by-one, the network would get \"Clogged\" with thousands of tiny requests.","title":"1. Small Data, Big Network"},{"location":"insight/wiretap_sdk/insight-wiretap_audio_io/#2-the-block-solution","text":"To keep things fast, Wiretap doesn't send audio sample-by-sample. Instead, it groups samples together into Blocks (called \"Frames\" in the API). When you ask for an \"Audio Frame,\" you are actually getting a chunk of sound\u2014usually enough to match exactly one frame of video. The size of these blocks is determined by the WireTapClipFormat . It tells your script: \"This block has 2,000 samples of 16-bit audio.\"","title":"2. The \"Block\" Solution"},{"location":"insight/wiretap_sdk/insight-wiretap_audio_io/#3-why-is-this-useful","text":"This ensures that audio and video stay perfectly in sync. Because one \"Frame\" of audio matches one \"Frame\" of video, your script can process them together without having to do complex math to align the timing.","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-wiretap_audio_io/#4-key-takeaway-for-beginners","text":"In Wiretap, Audio is treated like Video . You ask for a \"Frame\" of audio just like you would for a picture. The API handles the grouping of tiny samples into efficient blocks so your network stays fast and your sound stays in sync.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_compatibility/","text":"Insight: Version Compatibility This document explains how different versions of Flame and the Wiretap API work together without breaking your studio's pipeline. Target Audience: Novice developers concerned about software updates. 1. Do I need to re-write my code? The best thing about the Wiretap API is that it is Backward-Compatible . - If you write a tool for Flame 2025, it will still work perfectly with Flame 2026. - You only need to update your script if you want to use a New Feature that was just added. 2. Server vs. Client Versions When your script (The Client) connects to a Flame workstation (The Server), they perform a \"Handshake\": Backburner: Always uses the newest version available on the machine. IFFFS / Gateway: They try to Match the version of your script. If your script says \"I am Version 2025,\" the server will try to act like a 2025 server to make sure your code understands the response. 3. Forcing a Version If you are working on a very old project, you can tell your script to \"Pretend\" to be an older version of Flame using this command: WireTapClientSetVersion(year, minor, patch) 4. Why is this useful? It allows you to build Long-Term Tools . You can write a single pipeline script that manages projects from five years ago and projects starting today, and Wiretap handles the translation between versions automatically. 5. Key Takeaway for Beginners Don't be afraid of Flame updates! Your Wiretap scripts are built on a very stable foundation. As long as you aren't using \"Experimental\" features, your code will continue to work year after year as the software evolves.","title":"Insight: Version Compatibility"},{"location":"insight/wiretap_sdk/insight-wiretap_compatibility/#insight-version-compatibility","text":"This document explains how different versions of Flame and the Wiretap API work together without breaking your studio's pipeline. Target Audience: Novice developers concerned about software updates.","title":"Insight: Version Compatibility"},{"location":"insight/wiretap_sdk/insight-wiretap_compatibility/#1-do-i-need-to-re-write-my-code","text":"The best thing about the Wiretap API is that it is Backward-Compatible . - If you write a tool for Flame 2025, it will still work perfectly with Flame 2026. - You only need to update your script if you want to use a New Feature that was just added.","title":"1. Do I need to re-write my code?"},{"location":"insight/wiretap_sdk/insight-wiretap_compatibility/#2-server-vs-client-versions","text":"When your script (The Client) connects to a Flame workstation (The Server), they perform a \"Handshake\": Backburner: Always uses the newest version available on the machine. IFFFS / Gateway: They try to Match the version of your script. If your script says \"I am Version 2025,\" the server will try to act like a 2025 server to make sure your code understands the response.","title":"2. Server vs. Client Versions"},{"location":"insight/wiretap_sdk/insight-wiretap_compatibility/#3-forcing-a-version","text":"If you are working on a very old project, you can tell your script to \"Pretend\" to be an older version of Flame using this command: WireTapClientSetVersion(year, minor, patch)","title":"3. Forcing a Version"},{"location":"insight/wiretap_sdk/insight-wiretap_compatibility/#4-why-is-this-useful","text":"It allows you to build Long-Term Tools . You can write a single pipeline script that manages projects from five years ago and projects starting today, and Wiretap handles the translation between versions automatically.","title":"4. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-wiretap_compatibility/#5-key-takeaway-for-beginners","text":"Don't be afraid of Flame updates! Your Wiretap scripts are built on a very stable foundation. As long as you aren't using \"Experimental\" features, your code will continue to work year after year as the software evolves.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_discovery/","text":"Insight: Wiretap Self-Discovery This document explains how Wiretap finds other machines on your network automatically, almost like a \"Bluetooth pairing\" for video servers. Target Audience: Novice technical artists interested in network configuration. 1. How does it find a machine? When you run a Wiretap command, you need to tell it which machine to talk to. You have three ways to do this: A. The \"Direct\" Way (IP Address) Format: 192.168.1.50:5555 Pros: The fastest and most reliable. Bypasses all searching. Cons: Not flexible (if the machine's IP changes, your script breaks). B. The \"Name\" Way (DNS) Format: FlameWorkstation01:5555 Pros: Easier for humans to read. Cons: Can be slow if your network's \"Name Server\" (DNS) is acting up. C. The \"Auto\" Way (Multicast Discovery) Format: IFFFS or Gateway or Backburner Pros: Extremely flexible. You don't need to know the IP or port. How it works: Your script shouts: \"Is there an IFFFS server here?\" and the first workstation to respond sends back its full details. 2. When Auto-Discovery Fails In complex setups (like cloud servers or different office floors), the \"shouting\" might not reach every machine. - The Fix: You can \"hardcode\" the network map in a file called services.cfg . This acts like a phone book that tells Wiretap exactly where everyone lives without having to shout for them. 3. Key Takeaway for Beginners Self-discovery is great for small offices, but for professional studio pipelines, using a specific IP Address or a Services Config file is much safer. It ensures your scripts always connect to the right machine instantly every time.","title":"Insight: Wiretap Self-Discovery"},{"location":"insight/wiretap_sdk/insight-wiretap_discovery/#insight-wiretap-self-discovery","text":"This document explains how Wiretap finds other machines on your network automatically, almost like a \"Bluetooth pairing\" for video servers. Target Audience: Novice technical artists interested in network configuration.","title":"Insight: Wiretap Self-Discovery"},{"location":"insight/wiretap_sdk/insight-wiretap_discovery/#1-how-does-it-find-a-machine","text":"When you run a Wiretap command, you need to tell it which machine to talk to. You have three ways to do this:","title":"1. How does it find a machine?"},{"location":"insight/wiretap_sdk/insight-wiretap_discovery/#a-the-direct-way-ip-address","text":"Format: 192.168.1.50:5555 Pros: The fastest and most reliable. Bypasses all searching. Cons: Not flexible (if the machine's IP changes, your script breaks).","title":"A. The \"Direct\" Way (IP Address)"},{"location":"insight/wiretap_sdk/insight-wiretap_discovery/#b-the-name-way-dns","text":"Format: FlameWorkstation01:5555 Pros: Easier for humans to read. Cons: Can be slow if your network's \"Name Server\" (DNS) is acting up.","title":"B. The \"Name\" Way (DNS)"},{"location":"insight/wiretap_sdk/insight-wiretap_discovery/#c-the-auto-way-multicast-discovery","text":"Format: IFFFS or Gateway or Backburner Pros: Extremely flexible. You don't need to know the IP or port. How it works: Your script shouts: \"Is there an IFFFS server here?\" and the first workstation to respond sends back its full details.","title":"C. The \"Auto\" Way (Multicast Discovery)"},{"location":"insight/wiretap_sdk/insight-wiretap_discovery/#2-when-auto-discovery-fails","text":"In complex setups (like cloud servers or different office floors), the \"shouting\" might not reach every machine. - The Fix: You can \"hardcode\" the network map in a file called services.cfg . This acts like a phone book that tells Wiretap exactly where everyone lives without having to shout for them.","title":"2. When Auto-Discovery Fails"},{"location":"insight/wiretap_sdk/insight-wiretap_discovery/#3-key-takeaway-for-beginners","text":"Self-discovery is great for small offices, but for professional studio pipelines, using a specific IP Address or a Services Config file is much safer. It ensures your scripts always connect to the right machine instantly every time.","title":"3. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_error_handling/","text":"Insight: Wiretap Error Handling & Threading This document explains how to handle failures and how to use multiple threads safely when writing Wiretap scripts. Target Audience: Novice programmers interested in robust code and performance. 1. Handling Errors (The lastError pattern) In Wiretap, functions don't usually \"Throw Errors\" that crash your script. Instead, they return a simple True (Success) or False (Failure). If a function returns False , you must immediately ask for the \"Librarian's Note\" to see what went wrong: - Command: handle.lastError() - Rule: Read the error message immediately . The next time you call any function, the old error message is erased! 2. Is it Thread-Safe? Thread-safety means \"Can two parts of my script talk to the same object at the same time?\" - The Answer: Mostly No . - The Rule: Each thread in your script should have its own \"Remote Control\" (Handle). You should never share a single WireTapNodeHandle between two threads, or they will get confused and crash. 3. Improving Performance If you want to move media faster, you might think \"I'll use 10 threads!\" - The Reality: This usually doesn't help. Because all threads are trying to squeeze through the same network \"Pipe,\" they just end up waiting for each other. - The Best Way: Process frames one after another (Sequentially). The Wiretap server is smart\u2014it \"Reads Ahead\" and prepares the next frame for you before you even ask for it. 4. Why did my script crash on exit? Wiretap uses background threads to keep the connection alive. - The Fix: You must always call WireTapClientUninit() before your script finishes. This tells Wiretap to \"Park the car and turn off the engine\" safely. 5. Key Takeaway for Beginners Wiretap is a \"Polite\" API. It won't crash your script if something goes wrong; it will just say \"False.\" It's your job as the programmer to check that value and read the lastError() message to explain the problem to the user.","title":"Insight: Wiretap Error Handling &amp; Threading"},{"location":"insight/wiretap_sdk/insight-wiretap_error_handling/#insight-wiretap-error-handling-threading","text":"This document explains how to handle failures and how to use multiple threads safely when writing Wiretap scripts. Target Audience: Novice programmers interested in robust code and performance.","title":"Insight: Wiretap Error Handling &amp; Threading"},{"location":"insight/wiretap_sdk/insight-wiretap_error_handling/#1-handling-errors-the-lasterror-pattern","text":"In Wiretap, functions don't usually \"Throw Errors\" that crash your script. Instead, they return a simple True (Success) or False (Failure). If a function returns False , you must immediately ask for the \"Librarian's Note\" to see what went wrong: - Command: handle.lastError() - Rule: Read the error message immediately . The next time you call any function, the old error message is erased!","title":"1. Handling Errors (The lastError pattern)"},{"location":"insight/wiretap_sdk/insight-wiretap_error_handling/#2-is-it-thread-safe","text":"Thread-safety means \"Can two parts of my script talk to the same object at the same time?\" - The Answer: Mostly No . - The Rule: Each thread in your script should have its own \"Remote Control\" (Handle). You should never share a single WireTapNodeHandle between two threads, or they will get confused and crash.","title":"2. Is it Thread-Safe?"},{"location":"insight/wiretap_sdk/insight-wiretap_error_handling/#3-improving-performance","text":"If you want to move media faster, you might think \"I'll use 10 threads!\" - The Reality: This usually doesn't help. Because all threads are trying to squeeze through the same network \"Pipe,\" they just end up waiting for each other. - The Best Way: Process frames one after another (Sequentially). The Wiretap server is smart\u2014it \"Reads Ahead\" and prepares the next frame for you before you even ask for it.","title":"3. Improving Performance"},{"location":"insight/wiretap_sdk/insight-wiretap_error_handling/#4-why-did-my-script-crash-on-exit","text":"Wiretap uses background threads to keep the connection alive. - The Fix: You must always call WireTapClientUninit() before your script finishes. This tells Wiretap to \"Park the car and turn off the engine\" safely.","title":"4. Why did my script crash on exit?"},{"location":"insight/wiretap_sdk/insight-wiretap_error_handling/#5-key-takeaway-for-beginners","text":"Wiretap is a \"Polite\" API. It won't crash your script if something goes wrong; it will just say \"False.\" It's your job as the programmer to check that value and read the lastError() message to explain the problem to the user.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_faq_troubleshooting/","text":"Insight: FAQs and Troubleshooting This document provides a summary of the most common questions and hurdles people face when starting with the Wiretap SDK. Target Audience: Novice developers looking for quick solutions to common problems. 1. Where do I start? If you are stuck, the first thing to check is the General API issues. This covers things like how Wiretap handles errors and how to use threads safely. 2. Common Troubleshooting Areas The documentation is split into several \"Problem Zones\": IFFFS Issues: Problems with Flame's internal database (like unlinked clips). Network Issues: Why can't I see all the servers on my network? (Check your router's \"Multicast\" settings!). Media Issues: Problems reading or writing specific video or audio formats. Mac Issues: Specific hurdles for macOS users, like library paths. Permissions: Why is the \"Root\" user blocked from accessing media over the network? 3. Key Pro-Tip: Multicast Ping If your script can't find any servers, try this command in your terminal: ping 224.0.0.1 - If every machine on your network responds, your network is healthy. - If no one responds, your router is blocking Wiretap's \"Auto-Discovery\" messages. 4. Key Takeaway for Beginners Troubleshooting is a process of Elimination . 1. Check the network first (Ping). 2. Check the server next (Is it running?). 3. Check your script last (Are you handling the lastError correctly?). Most problems are solved by simply following these three steps in order.","title":"Insight: FAQs and Troubleshooting"},{"location":"insight/wiretap_sdk/insight-wiretap_faq_troubleshooting/#insight-faqs-and-troubleshooting","text":"This document provides a summary of the most common questions and hurdles people face when starting with the Wiretap SDK. Target Audience: Novice developers looking for quick solutions to common problems.","title":"Insight: FAQs and Troubleshooting"},{"location":"insight/wiretap_sdk/insight-wiretap_faq_troubleshooting/#1-where-do-i-start","text":"If you are stuck, the first thing to check is the General API issues. This covers things like how Wiretap handles errors and how to use threads safely.","title":"1. Where do I start?"},{"location":"insight/wiretap_sdk/insight-wiretap_faq_troubleshooting/#2-common-troubleshooting-areas","text":"The documentation is split into several \"Problem Zones\": IFFFS Issues: Problems with Flame's internal database (like unlinked clips). Network Issues: Why can't I see all the servers on my network? (Check your router's \"Multicast\" settings!). Media Issues: Problems reading or writing specific video or audio formats. Mac Issues: Specific hurdles for macOS users, like library paths. Permissions: Why is the \"Root\" user blocked from accessing media over the network?","title":"2. Common Troubleshooting Areas"},{"location":"insight/wiretap_sdk/insight-wiretap_faq_troubleshooting/#3-key-pro-tip-multicast-ping","text":"If your script can't find any servers, try this command in your terminal: ping 224.0.0.1 - If every machine on your network responds, your network is healthy. - If no one responds, your router is blocking Wiretap's \"Auto-Discovery\" messages.","title":"3. Key Pro-Tip: Multicast Ping"},{"location":"insight/wiretap_sdk/insight-wiretap_faq_troubleshooting/#4-key-takeaway-for-beginners","text":"Troubleshooting is a process of Elimination . 1. Check the network first (Ping). 2. Check the server next (Is it running?). 3. Check your script last (Are you handling the lastError correctly?). Most problems are solved by simply following these three steps in order.","title":"4. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_media_formats/","text":"Insight: Media and Metadata Formats This document provides an overview of the different \"Languages\" Wiretap speaks when it moves images, sounds, and data across your network. Target Audience: Novice programmers interested in technical specifications and data types. 1. Moving Raw Media Wiretap is designed for high performance. When it sends video or audio to your script, it usually converts it into a \"Raw\" format that is easy for a computer to understand: Raw Video (RGB): Images are sent as a simple buffer of Red, Green, and Blue pixels. There are no complex headers or compression\u2014just pure color data. Raw Audio (DL): Sound is sent in blocks of samples (similar to a WAVE file but simplified for the network). 2. Moving Metadata (Info) Metadata is the \"Instructions\" for the media. Wiretap uses two main formats for this: XML (The Modern Way): Projects, Managers, and Servers use XML to store settings. It's easy for humans to read and for computers to search. EDL (The Editorial Way): Timelines use an augmented version of the CMX 3600 EDL format to store edit instructions and transitions. 3. Specialized Formats Clip Format: A specialized metadata stream that describes the technical DNA of a clip (Resolution, Bit Depth, etc.). Source Data: The original \"Receipt\" for an imported file, stored in MIO XML format. 4. Why is this useful? By understanding these formats, you can decide how to best \"Listen\" to the Wiretap network. - If you want to build a Dashboard , you listen to the XML streams. - If you want to build an Auto-Editor , you listen to the EDL streams. - If you want to build a Transcoder , you listen to the Raw RGB streams. 5. Key Takeaway for Beginners Wiretap is a Translator . It takes the complex, proprietary databases inside Flame and translates them into standard formats like XML , EDL , and Raw RGB so your own scripts can easily understand them.","title":"Insight: Media and Metadata Formats"},{"location":"insight/wiretap_sdk/insight-wiretap_media_formats/#insight-media-and-metadata-formats","text":"This document provides an overview of the different \"Languages\" Wiretap speaks when it moves images, sounds, and data across your network. Target Audience: Novice programmers interested in technical specifications and data types.","title":"Insight: Media and Metadata Formats"},{"location":"insight/wiretap_sdk/insight-wiretap_media_formats/#1-moving-raw-media","text":"Wiretap is designed for high performance. When it sends video or audio to your script, it usually converts it into a \"Raw\" format that is easy for a computer to understand: Raw Video (RGB): Images are sent as a simple buffer of Red, Green, and Blue pixels. There are no complex headers or compression\u2014just pure color data. Raw Audio (DL): Sound is sent in blocks of samples (similar to a WAVE file but simplified for the network).","title":"1. Moving Raw Media"},{"location":"insight/wiretap_sdk/insight-wiretap_media_formats/#2-moving-metadata-info","text":"Metadata is the \"Instructions\" for the media. Wiretap uses two main formats for this: XML (The Modern Way): Projects, Managers, and Servers use XML to store settings. It's easy for humans to read and for computers to search. EDL (The Editorial Way): Timelines use an augmented version of the CMX 3600 EDL format to store edit instructions and transitions.","title":"2. Moving Metadata (Info)"},{"location":"insight/wiretap_sdk/insight-wiretap_media_formats/#3-specialized-formats","text":"Clip Format: A specialized metadata stream that describes the technical DNA of a clip (Resolution, Bit Depth, etc.). Source Data: The original \"Receipt\" for an imported file, stored in MIO XML format.","title":"3. Specialized Formats"},{"location":"insight/wiretap_sdk/insight-wiretap_media_formats/#4-why-is-this-useful","text":"By understanding these formats, you can decide how to best \"Listen\" to the Wiretap network. - If you want to build a Dashboard , you listen to the XML streams. - If you want to build an Auto-Editor , you listen to the EDL streams. - If you want to build a Transcoder , you listen to the Raw RGB streams.","title":"4. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-wiretap_media_formats/#5-key-takeaway-for-beginners","text":"Wiretap is a Translator . It takes the complex, proprietary databases inside Flame and translates them into standard formats like XML , EDL , and Raw RGB so your own scripts can easily understand them.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_os_support/","text":"Insight: Supported OS and Platforms This document explains which computers can run the Wiretap SDK. Target Audience: Novice developers planning their studio infrastructure. 1. Professional Foundations Wiretap is designed for high-end film and TV workstations. Because of this, it is only built for the two most common professional operating systems: Linux (x86-64): The industry standard for large render farms and high-end workstations. macOS (Intel & Apple Silicon): The standard for creative editing and design. Wiretap supports both the older Intel chips and the new M1/M2/M3 (arm64) chips. 2. Why no Windows? Autodesk Flame's main core runs on Linux and macOS. Since the Wiretap SDK is used to \"Reach Inside\" Flame, it stays on the same platforms to ensure the best possible performance and security. 3. Key Takeaway for Beginners You can write your Wiretap tools on a Mac and they will work perfectly when talking to a Linux server. This \"Cross-Platform\" support allows you to build a studio where different types of computers can all work together on the same projects.","title":"Insight: Supported OS and Platforms"},{"location":"insight/wiretap_sdk/insight-wiretap_os_support/#insight-supported-os-and-platforms","text":"This document explains which computers can run the Wiretap SDK. Target Audience: Novice developers planning their studio infrastructure.","title":"Insight: Supported OS and Platforms"},{"location":"insight/wiretap_sdk/insight-wiretap_os_support/#1-professional-foundations","text":"Wiretap is designed for high-end film and TV workstations. Because of this, it is only built for the two most common professional operating systems: Linux (x86-64): The industry standard for large render farms and high-end workstations. macOS (Intel & Apple Silicon): The standard for creative editing and design. Wiretap supports both the older Intel chips and the new M1/M2/M3 (arm64) chips.","title":"1. Professional Foundations"},{"location":"insight/wiretap_sdk/insight-wiretap_os_support/#2-why-no-windows","text":"Autodesk Flame's main core runs on Linux and macOS. Since the Wiretap SDK is used to \"Reach Inside\" Flame, it stays on the same platforms to ensure the best possible performance and security.","title":"2. Why no Windows?"},{"location":"insight/wiretap_sdk/insight-wiretap_os_support/#3-key-takeaway-for-beginners","text":"You can write your Wiretap tools on a Mac and they will work perfectly when talking to a Linux server. This \"Cross-Platform\" support allows you to build a studio where different types of computers can all work together on the same projects.","title":"3. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_permissions/","text":"Insight: Users, Groups, and Permissions This document explains how Wiretap decides if your script is \"Allowed\" to touch a file or project. Target Audience: Novice system administrators and security-conscious programmers. 1. The ID Rule (POSIX) Wiretap works across a network of computers. To keep permissions simple, it assumes that every computer in the studio uses the same User IDs . - If your ID is 501 on your laptop, the server expects you to be ID 501 there too. - As long as these IDs match, the server will \"Honor\" your credentials and let you edit your projects. 2. Fallback: The \"Anonymous\" User If your script connects from a computer that the server doesn't recognize, it won't just block you. It will treat you as an Anonymous User . - IFFFS Server: Falls back to a user named IFFFS_user . - Gateway Server: Falls back to a user named wtguser . - Note: These anonymous users usually have very limited power (e.g., they can see files but not delete them). 3. The \"Root\" Restriction By default, the \"Superuser\" (Root) is Blocked from accessing Wiretap over the network. - Why? This is a safety feature to prevent someone from accidentally deleting every project in the studio with one command. 4. Why is this useful? This system allows you to build a secure pipeline where artists can only see and edit their own work, while managers can see everything\u2014just like in a normal computer file system. 5. Key Takeaway for Beginners Wiretap permissions are based on Identity . If your script can't access a project, it's usually because the server doesn't recognize your User ID. Always check the [Authentication] section of the server's config file if you are having permission issues.","title":"Insight: Users, Groups, and Permissions"},{"location":"insight/wiretap_sdk/insight-wiretap_permissions/#insight-users-groups-and-permissions","text":"This document explains how Wiretap decides if your script is \"Allowed\" to touch a file or project. Target Audience: Novice system administrators and security-conscious programmers.","title":"Insight: Users, Groups, and Permissions"},{"location":"insight/wiretap_sdk/insight-wiretap_permissions/#1-the-id-rule-posix","text":"Wiretap works across a network of computers. To keep permissions simple, it assumes that every computer in the studio uses the same User IDs . - If your ID is 501 on your laptop, the server expects you to be ID 501 there too. - As long as these IDs match, the server will \"Honor\" your credentials and let you edit your projects.","title":"1. The ID Rule (POSIX)"},{"location":"insight/wiretap_sdk/insight-wiretap_permissions/#2-fallback-the-anonymous-user","text":"If your script connects from a computer that the server doesn't recognize, it won't just block you. It will treat you as an Anonymous User . - IFFFS Server: Falls back to a user named IFFFS_user . - Gateway Server: Falls back to a user named wtguser . - Note: These anonymous users usually have very limited power (e.g., they can see files but not delete them).","title":"2. Fallback: The \"Anonymous\" User"},{"location":"insight/wiretap_sdk/insight-wiretap_permissions/#3-the-root-restriction","text":"By default, the \"Superuser\" (Root) is Blocked from accessing Wiretap over the network. - Why? This is a safety feature to prevent someone from accidentally deleting every project in the studio with one command.","title":"3. The \"Root\" Restriction"},{"location":"insight/wiretap_sdk/insight-wiretap_permissions/#4-why-is-this-useful","text":"This system allows you to build a secure pipeline where artists can only see and edit their own work, while managers can see everything\u2014just like in a normal computer file system.","title":"4. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-wiretap_permissions/#5-key-takeaway-for-beginners","text":"Wiretap permissions are based on Identity . If your script can't access a project, it's usually because the server doesn't recognize your User ID. Always check the [Authentication] section of the server's config file if you are having permission issues.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_roles/","text":"Insight: Roles of the Wiretap Server and Client This document explains how the \"Brain\" (Client) and the \"Library\" (Server) work together in the Wiretap system. Target Audience: Novice programmers interested in software architecture. 1. The Division of Labor Wiretap uses a \"Client-Server\" model. This means the work is split into two distinct roles to keep everything running fast. A. The Wiretap Server (The Librarian) The server's only job is to expose data . It sits on the machine where the media is stored and waits for questions. - It doesn't do heavy work like rendering or converting files. - It provides a \"Uniform View\" of the data so the client doesn't need to know if it's talking to a database or a hard drive. - Goal: Stay responsive and lightweight. B. The Wiretap Client (The Artist/Researcher) The client is the program you write (like a Python script). It does the heavy lifting . - If a file needs to be converted from one format to another, the client does it. - If a frame needs to be rendered, the client does it. - Goal: Process the data without slowing down the server. 2. Why this matters By making the Client do all the work, Autodesk ensures that the Flame Workstation (the server) never slows down just because a background script is asking for information. The artist stays happy, and the pipeline stays fast. 3. Key Takeaway for Beginners In Wiretap, the Server is the \"Source of Truth\" and the Client is the \"Engine of Action.\" When you write a script, remember that you are the Client\u2014you are responsible for downloading the data and doing something useful with it!","title":"Insight: Roles of the Wiretap Server and Client"},{"location":"insight/wiretap_sdk/insight-wiretap_roles/#insight-roles-of-the-wiretap-server-and-client","text":"This document explains how the \"Brain\" (Client) and the \"Library\" (Server) work together in the Wiretap system. Target Audience: Novice programmers interested in software architecture.","title":"Insight: Roles of the Wiretap Server and Client"},{"location":"insight/wiretap_sdk/insight-wiretap_roles/#1-the-division-of-labor","text":"Wiretap uses a \"Client-Server\" model. This means the work is split into two distinct roles to keep everything running fast.","title":"1. The Division of Labor"},{"location":"insight/wiretap_sdk/insight-wiretap_roles/#a-the-wiretap-server-the-librarian","text":"The server's only job is to expose data . It sits on the machine where the media is stored and waits for questions. - It doesn't do heavy work like rendering or converting files. - It provides a \"Uniform View\" of the data so the client doesn't need to know if it's talking to a database or a hard drive. - Goal: Stay responsive and lightweight.","title":"A. The Wiretap Server (The Librarian)"},{"location":"insight/wiretap_sdk/insight-wiretap_roles/#b-the-wiretap-client-the-artistresearcher","text":"The client is the program you write (like a Python script). It does the heavy lifting . - If a file needs to be converted from one format to another, the client does it. - If a frame needs to be rendered, the client does it. - Goal: Process the data without slowing down the server.","title":"B. The Wiretap Client (The Artist/Researcher)"},{"location":"insight/wiretap_sdk/insight-wiretap_roles/#2-why-this-matters","text":"By making the Client do all the work, Autodesk ensures that the Flame Workstation (the server) never slows down just because a background script is asking for information. The artist stays happy, and the pipeline stays fast.","title":"2. Why this matters"},{"location":"insight/wiretap_sdk/insight-wiretap_roles/#3-key-takeaway-for-beginners","text":"In Wiretap, the Server is the \"Source of Truth\" and the Client is the \"Engine of Action.\" When you write a script, remember that you are the Client\u2014you are responsible for downloading the data and doing something useful with it!","title":"3. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_components/","text":"Insight: Components of the SDK This document explains what you get inside the Wiretap SDK package and where to find the tools you need to start programming. Target Audience: Novice developers interested in software installation and file structure. 1. What's in the Box? The SDK is organized into five main folders: api/ : The \"Instruction Manual\" for the compiler. It contains the C++ header files ( .h ) that your code needs to \"include.\" doc/ : The technical reference guide (HTML). This is where you look up specific function names and parameters. lib/ : The \"Engines.\" These are the actual libraries ( .a or .so ) that do the work of connecting to the servers. samples/ : The \"Cheat Sheets.\" This folder contains example programs written by Autodesk engineers. tools/ : The \"Power Tools.\" These are pre-made command-line programs like wiretap_ping or wiretap_get_metadata that you can use for testing. 2. A Warning about Tools Autodesk includes the tools/ folder for testing and troubleshooting. - The Rule: Don't build your studio's mission-critical automation around these tools! - Why? Autodesk might change how the tools work in the future. If you want to build something permanent, you should write your own script using the Python or C++ API directly. 3. Key Takeaway for Beginners The SDK folder is your \"Laboratory.\" Start by looking at the samples/ to see how professionals write Wiretap code, and use the tools/ to double-check that your network is working before you start writing your own complex scripts.","title":"Insight: Components of the SDK"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_components/#insight-components-of-the-sdk","text":"This document explains what you get inside the Wiretap SDK package and where to find the tools you need to start programming. Target Audience: Novice developers interested in software installation and file structure.","title":"Insight: Components of the SDK"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_components/#1-whats-in-the-box","text":"The SDK is organized into five main folders: api/ : The \"Instruction Manual\" for the compiler. It contains the C++ header files ( .h ) that your code needs to \"include.\" doc/ : The technical reference guide (HTML). This is where you look up specific function names and parameters. lib/ : The \"Engines.\" These are the actual libraries ( .a or .so ) that do the work of connecting to the servers. samples/ : The \"Cheat Sheets.\" This folder contains example programs written by Autodesk engineers. tools/ : The \"Power Tools.\" These are pre-made command-line programs like wiretap_ping or wiretap_get_metadata that you can use for testing.","title":"1. What's in the Box?"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_components/#2-a-warning-about-tools","text":"Autodesk includes the tools/ folder for testing and troubleshooting. - The Rule: Don't build your studio's mission-critical automation around these tools! - Why? Autodesk might change how the tools work in the future. If you want to build something permanent, you should write your own script using the Python or C++ API directly.","title":"2. A Warning about Tools"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_components/#3-key-takeaway-for-beginners","text":"The SDK folder is your \"Laboratory.\" Start by looking at the samples/ to see how professionals write Wiretap code, and use the tools/ to double-check that your network is working before you start writing your own complex scripts.","title":"3. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_overview/","text":"Insight: Wiretap SDK Overview This document provides a birds-eye view of the Wiretap SDK . It is the master framework for automating Autodesk Flame. Target Audience: Novice programmers and studio technical directors. 1. What is the SDK for? The Wiretap SDK allows you to write your own standalone programs that can reach inside Flame's database from the outside. Normally, you have to open Flame to change a project or render a clip. With the SDK, you can do all of that from a simple script, even if Flame isn't running on your machine! 2. The Three Flavors of Servers The SDK allows you to talk to three specialized servers: IFFFS Server: Handles projects and clips. Use this to automatically create new jobs or organize footage into libraries. Gateway Server: Handles \"Ingest.\" Use this to stream raw video from hard drives (like R3D or ProRes files) directly into your pipeline. Backburner Server: Handles \"Rendering.\" Use this to submit and monitor background render jobs on the farm. 3. Platform Support Wiretap is Cross-Platform . You can write a script on a Linux machine that reaches across the network to modify a project on a macOS Flame workstation. 4. Why use the SDK? Workflow Automation: Eliminate repetitive tasks like creating folders and naming projects. Custom Monitoring: Build your own custom dashboards to see which projects are taking up the most disk space. Pipeline Integration: Bridge Flame with other studio software (like ShotGrid or a custom web portal). 5. Key Takeaway for Beginners The Wiretap SDK is the \"Master Key\" to the Autodesk Flame ecosystem. It gives you the power to manage your media and renders using code, transforming Flame from a creative tool into a fully automated production engine.","title":"Insight: Wiretap SDK Overview"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_overview/#insight-wiretap-sdk-overview","text":"This document provides a birds-eye view of the Wiretap SDK . It is the master framework for automating Autodesk Flame. Target Audience: Novice programmers and studio technical directors.","title":"Insight: Wiretap SDK Overview"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_overview/#1-what-is-the-sdk-for","text":"The Wiretap SDK allows you to write your own standalone programs that can reach inside Flame's database from the outside. Normally, you have to open Flame to change a project or render a clip. With the SDK, you can do all of that from a simple script, even if Flame isn't running on your machine!","title":"1. What is the SDK for?"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_overview/#2-the-three-flavors-of-servers","text":"The SDK allows you to talk to three specialized servers: IFFFS Server: Handles projects and clips. Use this to automatically create new jobs or organize footage into libraries. Gateway Server: Handles \"Ingest.\" Use this to stream raw video from hard drives (like R3D or ProRes files) directly into your pipeline. Backburner Server: Handles \"Rendering.\" Use this to submit and monitor background render jobs on the farm.","title":"2. The Three Flavors of Servers"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_overview/#3-platform-support","text":"Wiretap is Cross-Platform . You can write a script on a Linux machine that reaches across the network to modify a project on a macOS Flame workstation.","title":"3. Platform Support"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_overview/#4-why-use-the-sdk","text":"Workflow Automation: Eliminate repetitive tasks like creating folders and naming projects. Custom Monitoring: Build your own custom dashboards to see which projects are taking up the most disk space. Pipeline Integration: Bridge Flame with other studio software (like ShotGrid or a custom web portal).","title":"4. Why use the SDK?"},{"location":"insight/wiretap_sdk/insight-wiretap_sdk_overview/#5-key-takeaway-for-beginners","text":"The Wiretap SDK is the \"Master Key\" to the Autodesk Flame ecosystem. It gives you the power to manage your media and renders using code, transforming Flame from a creative tool into a fully automated production engine.","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_terminology/","text":"Insight: Wiretap Terminology This document explains the basic words and concepts you need to know to work with the Wiretap SDK . Target Audience: Novice programmers learning the \"Language\" of Flame networking. 1. Servers and Clients Wiretap Server: A program running on a machine that \"exposes\" a database to the network. It's like a librarian who knows where all the books are. IFFFS: Exposes Flame's clip library. Gateway: Exposes regular files on your hard drive. Backburner: Exposes render jobs and status. Wiretap Client: A program (like your Python script) that asks the server for information. It's like the person asking the librarian for a book. 2. Nodes and Node IDs Node: A single \"Item\" in the Wiretap tree. A project is a node, a library is a node, and a clip is a node. Node ID: A unique string of text that identifies exactly which node you are talking about (e.g., clip:123456 ). 3. Frames and Formats Frame: A single image or a small piece of audio. When you ask Wiretap for a frame, it gives you a \"Buffer\" (a chunk of raw data). Frame Format: The \"Translation Guide\" for the data. It tells the computer if the frame is an RGB image, a YUV image, or an AIFF audio clip. 4. Metadata Metadata is \"Data about Data.\" In Wiretap, it is usually a text file (XML or EDL) that describes a clip. It tells you things like the timecode, the name of the clip, and what effects are applied to it. 5. Key Takeaway for Beginners To use Wiretap, you just need to know the Node ID of what you want and the Server where it lives. Once you have those two things, you can ask for the Metadata (to see what it is) or the Frames (to see the actual video).","title":"Insight: Wiretap Terminology"},{"location":"insight/wiretap_sdk/insight-wiretap_terminology/#insight-wiretap-terminology","text":"This document explains the basic words and concepts you need to know to work with the Wiretap SDK . Target Audience: Novice programmers learning the \"Language\" of Flame networking.","title":"Insight: Wiretap Terminology"},{"location":"insight/wiretap_sdk/insight-wiretap_terminology/#1-servers-and-clients","text":"Wiretap Server: A program running on a machine that \"exposes\" a database to the network. It's like a librarian who knows where all the books are. IFFFS: Exposes Flame's clip library. Gateway: Exposes regular files on your hard drive. Backburner: Exposes render jobs and status. Wiretap Client: A program (like your Python script) that asks the server for information. It's like the person asking the librarian for a book.","title":"1. Servers and Clients"},{"location":"insight/wiretap_sdk/insight-wiretap_terminology/#2-nodes-and-node-ids","text":"Node: A single \"Item\" in the Wiretap tree. A project is a node, a library is a node, and a clip is a node. Node ID: A unique string of text that identifies exactly which node you are talking about (e.g., clip:123456 ).","title":"2. Nodes and Node IDs"},{"location":"insight/wiretap_sdk/insight-wiretap_terminology/#3-frames-and-formats","text":"Frame: A single image or a small piece of audio. When you ask Wiretap for a frame, it gives you a \"Buffer\" (a chunk of raw data). Frame Format: The \"Translation Guide\" for the data. It tells the computer if the frame is an RGB image, a YUV image, or an AIFF audio clip.","title":"3. Frames and Formats"},{"location":"insight/wiretap_sdk/insight-wiretap_terminology/#4-metadata","text":"Metadata is \"Data about Data.\" In Wiretap, it is usually a text file (XML or EDL) that describes a clip. It tells you things like the timecode, the name of the clip, and what effects are applied to it.","title":"4. Metadata"},{"location":"insight/wiretap_sdk/insight-wiretap_terminology/#5-key-takeaway-for-beginners","text":"To use Wiretap, you just need to know the Node ID of what you want and the Server where it lives. Once you have those two things, you can ask for the Metadata (to see what it is) or the Frames (to see the actual video).","title":"5. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-wiretap_video_io/","text":"Insight: Reading and Writing Video Media This document explains the two ways you can pull images (frames) out of Flame using the Wiretap API. Target Audience: Novice programmers interested in image processing and performance. 1. Two Ways to Get Frames When you want to look at a frame of video from a server, you have two choices: Option A: Read through the Server (The \"Easy\" Way) You ask the Wiretap Server to give you the frame. - How it works: The server reads the file from the hard drive, converts it into raw RGB pixels, and sends it to your script. - Pros: Very simple. Your script doesn't need to know if the file is a DPX, JPEG, or ProRes. The server does all the \"Translation\" for you. - Cons: It puts a heavy load on the server's CPU. Option B: Read from Storage (The \"Fast\" Way) You ask the server for the \"Address\" of the file, then your script reads the file directly from the hard drive. - How it works: Wiretap gives you a path like /Volumes/Media/shot.001.dpx . Your script opens that file. - Pros: Much faster! It doesn't use the server's CPU, and there's no extra \"Network Hop.\" - Cons: More complex. Your script must know how to \"Speak the Language\" of the file (e.g., you need a library to read DPX or EXR files). 2. Choosing the Right Handle WireTapNodeHandle : Use this if you have a Clip ID and an index (e.g., \"Give me Frame 10 of Clip A\"). This is the standard way. WireTapServerHandle : Use this only if you have a \"Frame ID\" but don't know which clip it belongs to. This is rare and mostly for advanced timeline tools. 3. Key Takeaway for Beginners Start with Option A (Reading through the server). It's the most \"Programmer-Friendly\" because you get raw pixels that are ready to use. Only switch to Option B if you are moving millions of frames and need to save time and server power.","title":"Insight: Reading and Writing Video Media"},{"location":"insight/wiretap_sdk/insight-wiretap_video_io/#insight-reading-and-writing-video-media","text":"This document explains the two ways you can pull images (frames) out of Flame using the Wiretap API. Target Audience: Novice programmers interested in image processing and performance.","title":"Insight: Reading and Writing Video Media"},{"location":"insight/wiretap_sdk/insight-wiretap_video_io/#1-two-ways-to-get-frames","text":"When you want to look at a frame of video from a server, you have two choices:","title":"1. Two Ways to Get Frames"},{"location":"insight/wiretap_sdk/insight-wiretap_video_io/#option-a-read-through-the-server-the-easy-way","text":"You ask the Wiretap Server to give you the frame. - How it works: The server reads the file from the hard drive, converts it into raw RGB pixels, and sends it to your script. - Pros: Very simple. Your script doesn't need to know if the file is a DPX, JPEG, or ProRes. The server does all the \"Translation\" for you. - Cons: It puts a heavy load on the server's CPU.","title":"Option A: Read through the Server (The \"Easy\" Way)"},{"location":"insight/wiretap_sdk/insight-wiretap_video_io/#option-b-read-from-storage-the-fast-way","text":"You ask the server for the \"Address\" of the file, then your script reads the file directly from the hard drive. - How it works: Wiretap gives you a path like /Volumes/Media/shot.001.dpx . Your script opens that file. - Pros: Much faster! It doesn't use the server's CPU, and there's no extra \"Network Hop.\" - Cons: More complex. Your script must know how to \"Speak the Language\" of the file (e.g., you need a library to read DPX or EXR files).","title":"Option B: Read from Storage (The \"Fast\" Way)"},{"location":"insight/wiretap_sdk/insight-wiretap_video_io/#2-choosing-the-right-handle","text":"WireTapNodeHandle : Use this if you have a Clip ID and an index (e.g., \"Give me Frame 10 of Clip A\"). This is the standard way. WireTapServerHandle : Use this only if you have a \"Frame ID\" but don't know which clip it belongs to. This is rare and mostly for advanced timeline tools.","title":"2. Choosing the Right Handle"},{"location":"insight/wiretap_sdk/insight-wiretap_video_io/#3-key-takeaway-for-beginners","text":"Start with Option A (Reading through the server). It's the most \"Programmer-Friendly\" because you get raw pixels that are ready to use. Only switch to Option B if you are moving millions of frames and need to save time and server power.","title":"3. Key Takeaway for Beginners"},{"location":"insight/wiretap_sdk/insight-workflow_samples/","text":"Insight: Workflow, Samples and Tools This document acts as a \"Master Map\" to help you find the right example code for common studio tasks. Target Audience: Novice developers looking for a \"Quick Start\" guide. 1. Finding the Right Sample If you have a task in mind, look at this list to see which file in the samples/ folder you should study first: \"List every machine in the building\" : Study listAllServers.py . \"Explore a project tree\" : Study listChildren.py . \"Rename or Copy a clip\" : Study duplicateNode.py . \"Send a job to the render farm\" : Study submitJob.C (or the Python equivalent). 2. Comparing with Command Line Tools If you aren't sure if your script is working correctly, you can compare its results with the professional tools Autodesk included in the SDK: Your Task The Python Sample The \"Official\" Tool Scanning Network listAllServers.py wiretap_server_dump Browsing Nodes listChildren.py wiretap_get_children Reading Metadata dir(wiretap) wiretap_get_metadata 3. Why is this useful? This map saves you from \"Re-inventing the wheel.\" - Step 1: Run the \"Official\" tool to see what the data should look like. - Step 2: Open the matching Python sample to see how the code was written. - Step 3: Copy that code and change it to fit your studio's needs. 4. Key Takeaway for Beginners The samples and tools are \"Interactive Documentation.\" Instead of just reading about how to do something, you can run the sample and see it happen in real-time. This is the fastest way to master the Wiretap SDK!","title":"Insight: Workflow, Samples and Tools"},{"location":"insight/wiretap_sdk/insight-workflow_samples/#insight-workflow-samples-and-tools","text":"This document acts as a \"Master Map\" to help you find the right example code for common studio tasks. Target Audience: Novice developers looking for a \"Quick Start\" guide.","title":"Insight: Workflow, Samples and Tools"},{"location":"insight/wiretap_sdk/insight-workflow_samples/#1-finding-the-right-sample","text":"If you have a task in mind, look at this list to see which file in the samples/ folder you should study first: \"List every machine in the building\" : Study listAllServers.py . \"Explore a project tree\" : Study listChildren.py . \"Rename or Copy a clip\" : Study duplicateNode.py . \"Send a job to the render farm\" : Study submitJob.C (or the Python equivalent).","title":"1. Finding the Right Sample"},{"location":"insight/wiretap_sdk/insight-workflow_samples/#2-comparing-with-command-line-tools","text":"If you aren't sure if your script is working correctly, you can compare its results with the professional tools Autodesk included in the SDK: Your Task The Python Sample The \"Official\" Tool Scanning Network listAllServers.py wiretap_server_dump Browsing Nodes listChildren.py wiretap_get_children Reading Metadata dir(wiretap) wiretap_get_metadata","title":"2. Comparing with Command Line Tools"},{"location":"insight/wiretap_sdk/insight-workflow_samples/#3-why-is-this-useful","text":"This map saves you from \"Re-inventing the wheel.\" - Step 1: Run the \"Official\" tool to see what the data should look like. - Step 2: Open the matching Python sample to see how the code was written. - Step 3: Copy that code and change it to fit your studio's needs.","title":"3. Why is this useful?"},{"location":"insight/wiretap_sdk/insight-workflow_samples/#4-key-takeaway-for-beginners","text":"The samples and tools are \"Interactive Documentation.\" Instead of just reading about how to do something, you can run the sample and see it happen in real-time. This is the fastest way to master the Wiretap SDK!","title":"4. Key Takeaway for Beginners"},{"location":"research/understanding-AI_acronyms/","text":"Understanding AI: A Guide to Modern Acronyms This guide is designed for developers who are new to the AI space. It breaks down the \"alphabet soup\" of AI into logical categories, using simple analogies and code examples. 1. Core Architectures (The Frameworks) MCP (Model Context Protocol) Analogy: \"USB for AI.\" What it is: A standard way for AI models to connect to your local tools and data without writing custom code for every single app. Novice Perspective: Imagine if every mouse needed a different plug for every computer. That was AI before MCP. MCP makes the \"plugs\" universal. Code Pattern: ```python # Using FastMCP to define a tool the AI can \"plug into\" mcp = FastMCP(\"MyToolServer\") @mcp.tool() def get_weather(city: str) -> str: return f\"The weather in {city} is sunny.\" ``` RAG (Retrieval-Augmented Generation) Analogy: \"The Open-Book Exam.\" What it is: Giving an AI a specific set of documents to look at before it answers a question. Novice Perspective: Standard AI (like ChatGPT) answers from memory. RAG lets the AI look at your specific files (like this codebase) to give accurate, non-hallucinated answers. Code Pattern: python # A simplified RAG retrieval call response = rag.retrieval_query( text=\"How do I use the Flame API?\", rag_resources=[\"projects/my-project/corpora/flame-docs\"] ) Agent Analogy: \"An Employee, not just a Consultant.\" What it is: An AI that doesn't just talk, but does things. It can use tools, run scripts, and correct its own mistakes. Novice Perspective: A chatbot tells you how to fix a bug; an Agent actually writes the fix, runs the test, and tries again if the test fails. 2. Model Types (The Brains) LLM (Large Language Model): The big engine (e.g., GPT-4, Gemini) trained on the whole internet. SLM (Small Language Model): A \"mini\" version designed to run on your phone or local laptop. Faster and cheaper, but less \"worldly.\" MoE (Mixture of Experts): A model made of several \"specialists.\" When you ask a math question, it only wakes up the \"math specialist\" part of the brain to save energy and time. VLM (Vision Language Model): An AI that can \"see.\" You can show it a screenshot of a bug, and it can explain what's wrong. 3. Reasoning Patterns (The Thinking) CoT (Chain of Thought): \"Show your work.\" Asking the AI to explain its logic step-by-step. This drastically improves accuracy for complex math or coding. ReAct (Reason + Act): The loop Agents use. Reason: \"I need to find the file.\" Act: Run ls command. Observe: \"I see the file.\" Repeat. 4. Modalities (The Senses) TTS (Text-to-Speech): AI turning text into a human-sounding voice. STT (Speech-to-Text): AI \"listening\" to you and typing it out (Transcription). OCR (Optical Character Recognition): Reading text from an image or a PDF. 5. Training & Adaptation (The Learning) RLHF (Reinforcement Learning from Human Feedback): Humans ranking AI answers to teach it \"manners\" and helpfulness. LoRA (Low-Rank Adaptation): \"The Quick-Study Method.\" A way to teach a model a very specific skill (like \"Write Autodesk Flame scripts\") without needing to retrain the whole giant model. 6. Deployment Concepts (The Safety) HITL (Human-in-the-Loop): A system where the AI does the work, but a human must click \"Approve\" before anything actually happens (common in this CLI!). Evals (Evaluations): Automated tests to see how \"smart\" the AI is at a specific task. If you change your code, you run Evals to make sure the AI didn't get dumber.","title":"Understanding AI: A Guide to Modern Acronyms"},{"location":"research/understanding-AI_acronyms/#understanding-ai-a-guide-to-modern-acronyms","text":"This guide is designed for developers who are new to the AI space. It breaks down the \"alphabet soup\" of AI into logical categories, using simple analogies and code examples.","title":"Understanding AI: A Guide to Modern Acronyms"},{"location":"research/understanding-AI_acronyms/#1-core-architectures-the-frameworks","text":"","title":"1. Core Architectures (The Frameworks)"},{"location":"research/understanding-AI_acronyms/#mcp-model-context-protocol","text":"Analogy: \"USB for AI.\" What it is: A standard way for AI models to connect to your local tools and data without writing custom code for every single app. Novice Perspective: Imagine if every mouse needed a different plug for every computer. That was AI before MCP. MCP makes the \"plugs\" universal. Code Pattern: ```python # Using FastMCP to define a tool the AI can \"plug into\" mcp = FastMCP(\"MyToolServer\") @mcp.tool() def get_weather(city: str) -> str: return f\"The weather in {city} is sunny.\" ```","title":"MCP (Model Context Protocol)"},{"location":"research/understanding-AI_acronyms/#rag-retrieval-augmented-generation","text":"Analogy: \"The Open-Book Exam.\" What it is: Giving an AI a specific set of documents to look at before it answers a question. Novice Perspective: Standard AI (like ChatGPT) answers from memory. RAG lets the AI look at your specific files (like this codebase) to give accurate, non-hallucinated answers. Code Pattern: python # A simplified RAG retrieval call response = rag.retrieval_query( text=\"How do I use the Flame API?\", rag_resources=[\"projects/my-project/corpora/flame-docs\"] )","title":"RAG (Retrieval-Augmented Generation)"},{"location":"research/understanding-AI_acronyms/#agent","text":"Analogy: \"An Employee, not just a Consultant.\" What it is: An AI that doesn't just talk, but does things. It can use tools, run scripts, and correct its own mistakes. Novice Perspective: A chatbot tells you how to fix a bug; an Agent actually writes the fix, runs the test, and tries again if the test fails.","title":"Agent"},{"location":"research/understanding-AI_acronyms/#2-model-types-the-brains","text":"LLM (Large Language Model): The big engine (e.g., GPT-4, Gemini) trained on the whole internet. SLM (Small Language Model): A \"mini\" version designed to run on your phone or local laptop. Faster and cheaper, but less \"worldly.\" MoE (Mixture of Experts): A model made of several \"specialists.\" When you ask a math question, it only wakes up the \"math specialist\" part of the brain to save energy and time. VLM (Vision Language Model): An AI that can \"see.\" You can show it a screenshot of a bug, and it can explain what's wrong.","title":"2. Model Types (The Brains)"},{"location":"research/understanding-AI_acronyms/#3-reasoning-patterns-the-thinking","text":"CoT (Chain of Thought): \"Show your work.\" Asking the AI to explain its logic step-by-step. This drastically improves accuracy for complex math or coding. ReAct (Reason + Act): The loop Agents use. Reason: \"I need to find the file.\" Act: Run ls command. Observe: \"I see the file.\" Repeat.","title":"3. Reasoning Patterns (The Thinking)"},{"location":"research/understanding-AI_acronyms/#4-modalities-the-senses","text":"TTS (Text-to-Speech): AI turning text into a human-sounding voice. STT (Speech-to-Text): AI \"listening\" to you and typing it out (Transcription). OCR (Optical Character Recognition): Reading text from an image or a PDF.","title":"4. Modalities (The Senses)"},{"location":"research/understanding-AI_acronyms/#5-training-adaptation-the-learning","text":"RLHF (Reinforcement Learning from Human Feedback): Humans ranking AI answers to teach it \"manners\" and helpfulness. LoRA (Low-Rank Adaptation): \"The Quick-Study Method.\" A way to teach a model a very specific skill (like \"Write Autodesk Flame scripts\") without needing to retrain the whole giant model.","title":"5. Training &amp; Adaptation (The Learning)"},{"location":"research/understanding-AI_acronyms/#6-deployment-concepts-the-safety","text":"HITL (Human-in-the-Loop): A system where the AI does the work, but a human must click \"Approve\" before anything actually happens (common in this CLI!). Evals (Evaluations): Automated tests to see how \"smart\" the AI is at a specific task. If you change your code, you run Evals to make sure the AI didn't get dumber.","title":"6. Deployment Concepts (The Safety)"},{"location":"research/understanding-AI_core_architectures/","text":"Understanding AI Core Architectures In the world of AI, \"Architecture\" refers to how different systems are connected to solve complex problems. For a programmer, this is the high-level design pattern of an AI application. 1. MCP (Model Context Protocol) The Universal Connector The Problem: Every time a developer wanted an AI (like Claude or Gemini) to use a tool (like Google Search or a Local Database), they had to write unique, fragile code for that specific combination. The Solution: MCP is a standardized \"handshake.\" If you build an MCP server for your data, any MCP-compliant AI can immediately understand how to read and use it. Analogy: The USB Port. Before USB, printers, keyboards, and mice all had different, weird plugs. USB standardized the connection so everything \"just works.\" Simple Code (Conceptual): python # Defining an MCP tool that the AI can call @mcp.tool() def search_local_logs(query: str): \"\"\"Searches through project logs for a specific error.\"\"\" # The AI will decide when to call this based on the user's request return run_grep_command(query) 2. RAG (Retrieval-Augmented Generation) The Open-Book Exam What it is: Instead of relying on the AI's training (which might be old), we \"hand\" the AI specific documents relevant to the user's question right before it answers. Analogy: A Librarian. If you ask a librarian a question, they don't just guess from memory; they go to the shelf, find the right book, read the relevant page, and then summarize the answer for you. Why use it? It prevents \"hallucinations\" (making things up) and allows the AI to talk about private data it was never trained on. Simple Code (Conceptual): ```python # 1. Get the user's question question = \"How do I setup the Flame Listener?\" 2. 'Retrieve' relevant snippets from our docs context = search_my_docs_folder(question) 3. 'Augment' the prompt final_prompt = f\"Using these notes: {context}, answer this: {question}\" 4. 'Generate' the answer ai_response = model.generate(final_prompt) ``` 3. Agents The Autonomous Employee What it is: An AI system that can break a big goal into small steps, execute those steps using tools, and fix its own mistakes. Analogy: A Junior Developer. If you tell a chatbot \"Fix this bug,\" it might explain how. If you tell an Agent \"Fix this bug,\" it will: Read the code. Identify the error. Write a fix. Run the test. If the test fails, try a different fix. The ReAct Loop: Agents follow a pattern called Reason + Act . Reason: \"I see the test failed because of a SyntaxError.\" Act: \"I will edit line 42 to add the missing colon.\" Observe: \"The test now passes.\"","title":"Understanding AI Core Architectures"},{"location":"research/understanding-AI_core_architectures/#understanding-ai-core-architectures","text":"In the world of AI, \"Architecture\" refers to how different systems are connected to solve complex problems. For a programmer, this is the high-level design pattern of an AI application.","title":"Understanding AI Core Architectures"},{"location":"research/understanding-AI_core_architectures/#1-mcp-model-context-protocol","text":"The Universal Connector The Problem: Every time a developer wanted an AI (like Claude or Gemini) to use a tool (like Google Search or a Local Database), they had to write unique, fragile code for that specific combination. The Solution: MCP is a standardized \"handshake.\" If you build an MCP server for your data, any MCP-compliant AI can immediately understand how to read and use it. Analogy: The USB Port. Before USB, printers, keyboards, and mice all had different, weird plugs. USB standardized the connection so everything \"just works.\" Simple Code (Conceptual): python # Defining an MCP tool that the AI can call @mcp.tool() def search_local_logs(query: str): \"\"\"Searches through project logs for a specific error.\"\"\" # The AI will decide when to call this based on the user's request return run_grep_command(query)","title":"1. MCP (Model Context Protocol)"},{"location":"research/understanding-AI_core_architectures/#2-rag-retrieval-augmented-generation","text":"The Open-Book Exam What it is: Instead of relying on the AI's training (which might be old), we \"hand\" the AI specific documents relevant to the user's question right before it answers. Analogy: A Librarian. If you ask a librarian a question, they don't just guess from memory; they go to the shelf, find the right book, read the relevant page, and then summarize the answer for you. Why use it? It prevents \"hallucinations\" (making things up) and allows the AI to talk about private data it was never trained on. Simple Code (Conceptual): ```python # 1. Get the user's question question = \"How do I setup the Flame Listener?\"","title":"2. RAG (Retrieval-Augmented Generation)"},{"location":"research/understanding-AI_core_architectures/#2-retrieve-relevant-snippets-from-our-docs","text":"context = search_my_docs_folder(question)","title":"2. 'Retrieve' relevant snippets from our docs"},{"location":"research/understanding-AI_core_architectures/#3-augment-the-prompt","text":"final_prompt = f\"Using these notes: {context}, answer this: {question}\"","title":"3. 'Augment' the prompt"},{"location":"research/understanding-AI_core_architectures/#4-generate-the-answer","text":"ai_response = model.generate(final_prompt) ```","title":"4. 'Generate' the answer"},{"location":"research/understanding-AI_core_architectures/#3-agents","text":"The Autonomous Employee What it is: An AI system that can break a big goal into small steps, execute those steps using tools, and fix its own mistakes. Analogy: A Junior Developer. If you tell a chatbot \"Fix this bug,\" it might explain how. If you tell an Agent \"Fix this bug,\" it will: Read the code. Identify the error. Write a fix. Run the test. If the test fails, try a different fix. The ReAct Loop: Agents follow a pattern called Reason + Act . Reason: \"I see the test failed because of a SyntaxError.\" Act: \"I will edit line 42 to add the missing colon.\" Observe: \"The test now passes.\"","title":"3. Agents"},{"location":"research/understanding-AI_deployment_concepts/","text":"Understanding AI Deployment Concepts Once an AI is built and trained, how do we actually \"use\" it in the real world? These concepts cover the bridge between the AI model and the user. 1. Inference The AI in Action What it is: The process of the AI actually running and generating an answer. When you ask a question and wait for the response, you are waiting for \"Inference.\" Analogy: The Performance. Training is like the months of rehearsal; Inference is the actual night of the play when the actors are on stage performing. 2. HITL (Human-in-the-Loop) The Safety Switch What it is: A workflow where the AI does most of the work, but a human must review or approve the result before it's finalized. Why it matters: In high-stakes environments (like editing a multi-million dollar commercial in Flame), we don't want the AI making permanent changes without a human saying \"Yes, that looks right.\" 3. Evals (Evaluations) The AI Report Card What it is: A set of automated tests used to measure how good an AI is at a specific task. Example: If we update our Flame helper, we run an \"Eval\" that asks the AI 100 questions about the Flame API. If it gets 95 right, we know it's ready. If it only gets 60 right, we know we broke something. 4. Tokens & Context Window Memory Limits Tokens: Think of these as \"syllables\" for AI. A model doesn't see words; it sees tokens. Context Window: The \"short-term memory\" of the AI. It's the maximum number of tokens the AI can \"keep in its head\" at one time. If your conversation or file is too long, the AI will start to \"forget\" the beginning. 5. Guardrails The Safety Rails What it is: Software that sits around the AI to make sure it doesn't say anything dangerous, leaked secrets, or hallucinate. Analogy: A Bouncer. The AI might want to answer a question it shouldn't, but the Guardrail blocks the response before the user ever sees it.","title":"Understanding AI Deployment Concepts"},{"location":"research/understanding-AI_deployment_concepts/#understanding-ai-deployment-concepts","text":"Once an AI is built and trained, how do we actually \"use\" it in the real world? These concepts cover the bridge between the AI model and the user.","title":"Understanding AI Deployment Concepts"},{"location":"research/understanding-AI_deployment_concepts/#1-inference","text":"The AI in Action What it is: The process of the AI actually running and generating an answer. When you ask a question and wait for the response, you are waiting for \"Inference.\" Analogy: The Performance. Training is like the months of rehearsal; Inference is the actual night of the play when the actors are on stage performing.","title":"1. Inference"},{"location":"research/understanding-AI_deployment_concepts/#2-hitl-human-in-the-loop","text":"The Safety Switch What it is: A workflow where the AI does most of the work, but a human must review or approve the result before it's finalized. Why it matters: In high-stakes environments (like editing a multi-million dollar commercial in Flame), we don't want the AI making permanent changes without a human saying \"Yes, that looks right.\"","title":"2. HITL (Human-in-the-Loop)"},{"location":"research/understanding-AI_deployment_concepts/#3-evals-evaluations","text":"The AI Report Card What it is: A set of automated tests used to measure how good an AI is at a specific task. Example: If we update our Flame helper, we run an \"Eval\" that asks the AI 100 questions about the Flame API. If it gets 95 right, we know it's ready. If it only gets 60 right, we know we broke something.","title":"3. Evals (Evaluations)"},{"location":"research/understanding-AI_deployment_concepts/#4-tokens-context-window","text":"Memory Limits Tokens: Think of these as \"syllables\" for AI. A model doesn't see words; it sees tokens. Context Window: The \"short-term memory\" of the AI. It's the maximum number of tokens the AI can \"keep in its head\" at one time. If your conversation or file is too long, the AI will start to \"forget\" the beginning.","title":"4. Tokens &amp; Context Window"},{"location":"research/understanding-AI_deployment_concepts/#5-guardrails","text":"The Safety Rails What it is: Software that sits around the AI to make sure it doesn't say anything dangerous, leaked secrets, or hallucinate. Analogy: A Bouncer. The AI might want to answer a question it shouldn't, but the Guardrail blocks the response before the user ever sees it.","title":"5. Guardrails"},{"location":"research/understanding-AI_modalities/","text":"Understanding AI Modalities \"Modality\" refers to the type of data the AI can understand or create. Early AI was mostly \"Single-Modal\" (just text). Modern AI is \"Multi-Modal.\" 1. Text (The Foundation) The most common modality. AI \"sees\" text as Tokens (chunks of characters) rather than whole words. 2. Vision (Image & Video) Image Understanding: Identifying objects, reading text in photos (OCR), or describing the \"vibe\" of a picture. Video Understanding: Seeing how things change over time. This is critical for tools interacting with the Autodesk Flame UI. 3. Audio (Sound & Speech) STT (Speech-to-Text): Also known as Transcription. Turning a spoken meeting into a text summary. TTS (Text-to-Speech): Turning a script into a natural-sounding voice. Audio-to-Audio: Some new models can \"listen\" to a voice and respond with a voice without turning it into text in the middle, preserving the emotion and tone. 4. Multimodal Interplay The Real Power The most advanced AIs can \"connect\" these senses. * Example: You can show an AI a video of a software crash and say out loud, \"Why did that happen?\" The AI processes the video (Vision) and your voice (Audio) together to give you a text answer. 5. OCR (Optical Character Recognition) Reading the Unreadable What it is: The specific skill of looking at an image (like a scan of a receipt or a screenshot of a menu) and pulling out the text characters. In this Repo: We might use OCR to \"read\" values from the Flame UI that aren't available through the standard API.","title":"Understanding AI Modalities"},{"location":"research/understanding-AI_modalities/#understanding-ai-modalities","text":"\"Modality\" refers to the type of data the AI can understand or create. Early AI was mostly \"Single-Modal\" (just text). Modern AI is \"Multi-Modal.\"","title":"Understanding AI Modalities"},{"location":"research/understanding-AI_modalities/#1-text-the-foundation","text":"The most common modality. AI \"sees\" text as Tokens (chunks of characters) rather than whole words.","title":"1. Text (The Foundation)"},{"location":"research/understanding-AI_modalities/#2-vision-image-video","text":"Image Understanding: Identifying objects, reading text in photos (OCR), or describing the \"vibe\" of a picture. Video Understanding: Seeing how things change over time. This is critical for tools interacting with the Autodesk Flame UI.","title":"2. Vision (Image &amp; Video)"},{"location":"research/understanding-AI_modalities/#3-audio-sound-speech","text":"STT (Speech-to-Text): Also known as Transcription. Turning a spoken meeting into a text summary. TTS (Text-to-Speech): Turning a script into a natural-sounding voice. Audio-to-Audio: Some new models can \"listen\" to a voice and respond with a voice without turning it into text in the middle, preserving the emotion and tone.","title":"3. Audio (Sound &amp; Speech)"},{"location":"research/understanding-AI_modalities/#4-multimodal-interplay","text":"The Real Power The most advanced AIs can \"connect\" these senses. * Example: You can show an AI a video of a software crash and say out loud, \"Why did that happen?\" The AI processes the video (Vision) and your voice (Audio) together to give you a text answer.","title":"4. Multimodal Interplay"},{"location":"research/understanding-AI_modalities/#5-ocr-optical-character-recognition","text":"Reading the Unreadable What it is: The specific skill of looking at an image (like a scan of a receipt or a screenshot of a menu) and pulling out the text characters. In this Repo: We might use OCR to \"read\" values from the Flame UI that aren't available through the standard API.","title":"5. OCR (Optical Character Recognition)"},{"location":"research/understanding-AI_model_types/","text":"Understanding AI Model Types Not all AI models are created equal. Depending on the task\u2014whether it's writing code, summarizing a book, or identifying a cat in a photo\u2014you might use a different \"flavor\" of model. 1. LLM (Large Language Model) The Heavyweight Champion What it is: The giant models (like GPT-4, Claude 3.5, Gemini Pro) trained on nearly the entire public internet. Best for: Deep reasoning, complex coding, and creative writing. Analogy: The University Professor. They know a lot about almost everything, but they are \"heavy\" (expensive and slower to run). 2. SLM (Small Language Model) The Local Specialist What it is: Models designed to be small enough to run on your laptop, phone, or even inside a single app (like Llama-3-8B or Phi-3). Best for: Simple tasks, privacy-focused apps, and running without an internet connection. Analogy: The Pocket Dictionary. It doesn't know everything, but it's fast, portable, and gets the basic job done. 3. MoE (Mixture of Experts) The Team of Specialists What it is: A model that is actually made of many smaller \"experts.\" When you ask a question, the model only \"wakes up\" the 2 or 3 experts that are relevant to your topic. Why it matters: It gives you the intelligence of a giant model with the speed and efficiency of a smaller one. Analogy: A Hospital. You don't need the whole hospital to treat a broken arm; you just need the X-ray tech and the Orthopedist. MoE routing ensures only the right \"doctors\" are called. 4. VLM (Vision Language Model) The AI with Eyes What it is: A model that can process both text and images (or video) at the same time. Best for: Describing screenshots, explaining UI layouts, or \"watching\" a video to find a specific moment. Simple Code (Conceptual): python # Sending an image to a VLM response = model.generate( prompt=\"Look at this Flame UI screenshot. Is the Batch button active?\", image=\"screenshot_01.png\" )","title":"Understanding AI Model Types"},{"location":"research/understanding-AI_model_types/#understanding-ai-model-types","text":"Not all AI models are created equal. Depending on the task\u2014whether it's writing code, summarizing a book, or identifying a cat in a photo\u2014you might use a different \"flavor\" of model.","title":"Understanding AI Model Types"},{"location":"research/understanding-AI_model_types/#1-llm-large-language-model","text":"The Heavyweight Champion What it is: The giant models (like GPT-4, Claude 3.5, Gemini Pro) trained on nearly the entire public internet. Best for: Deep reasoning, complex coding, and creative writing. Analogy: The University Professor. They know a lot about almost everything, but they are \"heavy\" (expensive and slower to run).","title":"1. LLM (Large Language Model)"},{"location":"research/understanding-AI_model_types/#2-slm-small-language-model","text":"The Local Specialist What it is: Models designed to be small enough to run on your laptop, phone, or even inside a single app (like Llama-3-8B or Phi-3). Best for: Simple tasks, privacy-focused apps, and running without an internet connection. Analogy: The Pocket Dictionary. It doesn't know everything, but it's fast, portable, and gets the basic job done.","title":"2. SLM (Small Language Model)"},{"location":"research/understanding-AI_model_types/#3-moe-mixture-of-experts","text":"The Team of Specialists What it is: A model that is actually made of many smaller \"experts.\" When you ask a question, the model only \"wakes up\" the 2 or 3 experts that are relevant to your topic. Why it matters: It gives you the intelligence of a giant model with the speed and efficiency of a smaller one. Analogy: A Hospital. You don't need the whole hospital to treat a broken arm; you just need the X-ray tech and the Orthopedist. MoE routing ensures only the right \"doctors\" are called.","title":"3. MoE (Mixture of Experts)"},{"location":"research/understanding-AI_model_types/#4-vlm-vision-language-model","text":"The AI with Eyes What it is: A model that can process both text and images (or video) at the same time. Best for: Describing screenshots, explaining UI layouts, or \"watching\" a video to find a specific moment. Simple Code (Conceptual): python # Sending an image to a VLM response = model.generate( prompt=\"Look at this Flame UI screenshot. Is the Batch button active?\", image=\"screenshot_01.png\" )","title":"4. VLM (Vision Language Model)"},{"location":"research/understanding-AI_reasoning_patterns/","text":"Understanding AI Reasoning Patterns How an AI \"thinks\" depends on the instructions we give it. Just like a human, an AI is more accurate when it takes its time and follows a logical process. 1. CoT (Chain of Thought) \"Show Your Work\" What it is: Forcing the AI to write out its step-by-step logic before giving the final answer. Why it matters: LLMs are \"prediction engines.\" If they jump straight to the answer, they often guess wrong. If they walk through the logic, they catch their own errors. Analogy: A Math Student. A student who writes down every step of an equation is much less likely to make a mistake than one who tries to do it all in their head. 2. ReAct (Reason + Act) The Agent's Heartbeat What it is: A loop where the AI Reasons about its situation, takes an Action (using a tool), and then Observes the result before deciding what to do next. Simple Logic: Thought: I need to know the current Flame project name. Action: Run print_project_name.py . Observation: The script output \"Commercial_Project_v2\". Final Thought: The project is \"Commercial_Project_v2\". 3. Zero-Shot vs. Few-Shot Learning on the Fly Zero-Shot: Asking the AI to do something without giving it any examples. Example: \"Translate 'Hello' to French.\" Few-Shot: Giving the AI 2 or 3 examples of how you want the task done before asking it to perform. Analogy: Training a New Intern. You don't just say \"Do the filing.\" You show them two folders you've already filed so they understand your specific system. Simple Prompt: text Input: \"The movie was great!\" -> Sentiment: Positive Input: \"I hated the food.\" -> Sentiment: Negative Input: \"The service was okay.\" -> Sentiment: 4. Multi-Hop Reasoning Connecting the Dots What it is: Solving a problem that requires finding Answer A, then using Answer A to find Answer B. Example: \"Who is the CEO of the company that made the first movie John Doe starred in?\" Hop 1: Find John Doe's first movie. Hop 2: Find the company that made it. Hop 3: Find that company's CEO.","title":"Understanding AI Reasoning Patterns"},{"location":"research/understanding-AI_reasoning_patterns/#understanding-ai-reasoning-patterns","text":"How an AI \"thinks\" depends on the instructions we give it. Just like a human, an AI is more accurate when it takes its time and follows a logical process.","title":"Understanding AI Reasoning Patterns"},{"location":"research/understanding-AI_reasoning_patterns/#1-cot-chain-of-thought","text":"\"Show Your Work\" What it is: Forcing the AI to write out its step-by-step logic before giving the final answer. Why it matters: LLMs are \"prediction engines.\" If they jump straight to the answer, they often guess wrong. If they walk through the logic, they catch their own errors. Analogy: A Math Student. A student who writes down every step of an equation is much less likely to make a mistake than one who tries to do it all in their head.","title":"1. CoT (Chain of Thought)"},{"location":"research/understanding-AI_reasoning_patterns/#2-react-reason-act","text":"The Agent's Heartbeat What it is: A loop where the AI Reasons about its situation, takes an Action (using a tool), and then Observes the result before deciding what to do next. Simple Logic: Thought: I need to know the current Flame project name. Action: Run print_project_name.py . Observation: The script output \"Commercial_Project_v2\". Final Thought: The project is \"Commercial_Project_v2\".","title":"2. ReAct (Reason + Act)"},{"location":"research/understanding-AI_reasoning_patterns/#3-zero-shot-vs-few-shot","text":"Learning on the Fly Zero-Shot: Asking the AI to do something without giving it any examples. Example: \"Translate 'Hello' to French.\" Few-Shot: Giving the AI 2 or 3 examples of how you want the task done before asking it to perform. Analogy: Training a New Intern. You don't just say \"Do the filing.\" You show them two folders you've already filed so they understand your specific system. Simple Prompt: text Input: \"The movie was great!\" -> Sentiment: Positive Input: \"I hated the food.\" -> Sentiment: Negative Input: \"The service was okay.\" -> Sentiment:","title":"3. Zero-Shot vs. Few-Shot"},{"location":"research/understanding-AI_reasoning_patterns/#4-multi-hop-reasoning","text":"Connecting the Dots What it is: Solving a problem that requires finding Answer A, then using Answer A to find Answer B. Example: \"Who is the CEO of the company that made the first movie John Doe starred in?\" Hop 1: Find John Doe's first movie. Hop 2: Find the company that made it. Hop 3: Find that company's CEO.","title":"4. Multi-Hop Reasoning"},{"location":"research/understanding-AI_training_and_adaptation/","text":"Understanding AI Training & Adaptation How do we take a \"raw\" AI model and make it useful for a specific job, like writing Autodesk Flame Python scripts? 1. Pre-training General Education What it is: The initial phase where a model reads the entire internet to learn how language, logic, and basic facts work. Analogy: Grade School. Everyone learns the same basics: how to read, write, and do math. 2. Fine-Tuning Specialized Training What it is: Taking a pre-trained model and giving it a \"deep dive\" into a specific topic (like medical records or Python code). Analogy: Medical School. You take someone who already knows how to read and write and teach them specifically how to be a doctor. 3. RLHF (Reinforcement Learning from Human Feedback) Polishing the Behavior What it is: Humans sit down with the AI and rank its answers. \"This answer was helpful and safe; that answer was rude and confusing.\" Why it matters: This is what makes AI feel \"human\" and easy to talk to, rather than just a robotic text-completer. 4. LoRA (Low-Rank Adaptation) The \"Quick-Study\" Cheat Code What it is: Instead of retraining the whole massive model (which costs millions of dollars), we only train a tiny \"adapter\" layer that sits on top. Why it matters: It allows small teams to make highly specialized models (like an \"Autodesk Flame Expert\") very cheaply. Analogy: A Specialized Lens. You don't build a new camera to take a macro photo; you just put a macro lens on the camera you already have. 5. Quantization Shrinking the Brain What it is: Reducing the precision of the model's numbers so it takes up less memory. The Trade-off: The model becomes slightly less \"smart\" but becomes much faster and can run on cheaper hardware (like your local laptop).","title":"Understanding AI Training &amp; Adaptation"},{"location":"research/understanding-AI_training_and_adaptation/#understanding-ai-training-adaptation","text":"How do we take a \"raw\" AI model and make it useful for a specific job, like writing Autodesk Flame Python scripts?","title":"Understanding AI Training &amp; Adaptation"},{"location":"research/understanding-AI_training_and_adaptation/#1-pre-training","text":"General Education What it is: The initial phase where a model reads the entire internet to learn how language, logic, and basic facts work. Analogy: Grade School. Everyone learns the same basics: how to read, write, and do math.","title":"1. Pre-training"},{"location":"research/understanding-AI_training_and_adaptation/#2-fine-tuning","text":"Specialized Training What it is: Taking a pre-trained model and giving it a \"deep dive\" into a specific topic (like medical records or Python code). Analogy: Medical School. You take someone who already knows how to read and write and teach them specifically how to be a doctor.","title":"2. Fine-Tuning"},{"location":"research/understanding-AI_training_and_adaptation/#3-rlhf-reinforcement-learning-from-human-feedback","text":"Polishing the Behavior What it is: Humans sit down with the AI and rank its answers. \"This answer was helpful and safe; that answer was rude and confusing.\" Why it matters: This is what makes AI feel \"human\" and easy to talk to, rather than just a robotic text-completer.","title":"3. RLHF (Reinforcement Learning from Human Feedback)"},{"location":"research/understanding-AI_training_and_adaptation/#4-lora-low-rank-adaptation","text":"The \"Quick-Study\" Cheat Code What it is: Instead of retraining the whole massive model (which costs millions of dollars), we only train a tiny \"adapter\" layer that sits on top. Why it matters: It allows small teams to make highly specialized models (like an \"Autodesk Flame Expert\") very cheaply. Analogy: A Specialized Lens. You don't build a new camera to take a macro photo; you just put a macro lens on the camera you already have.","title":"4. LoRA (Low-Rank Adaptation)"},{"location":"research/understanding-AI_training_and_adaptation/#5-quantization","text":"Shrinking the Brain What it is: Reducing the precision of the model's numbers so it takes up less memory. The Trade-off: The model becomes slightly less \"smart\" but becomes much faster and can run on cheaper hardware (like your local laptop).","title":"5. Quantization"},{"location":"tasks/flame-mcp-bridge-tasks/","text":"Tasks: Flame-MCP Bridge Implementation This document tracks the technical steps required to implement the Model Context Protocol (MCP) bridge for Autodesk Flame. Phase 1: Environment & Scaffolding [ ] Create flame-mcp/ directory structure. [ ] Initialize requirements.txt for the MCP server (e.g., fastmcp , requests , pydantic ). [ ] Set up a basic server.py using fastmcp . [ ] Create a README in flame-mcp/ explaining how to start the server. Phase 2: Core Communication Layer [ ] Implement the Relay client: a module to handle network communication with the existing flame-listener.py (port 5555). [ ] Standardize the error handling for relay failures (e.g., Flame is not running, Listener is down). [ ] Implement a \"Ping\" tool to verify the end-to-end connection: AI -> MCP -> Listener -> Flame . Phase 3: Core AI Tools [ ] Tool: execute_python [ ] Basic execution of strings. [ ] Return stdout and stderr to the AI. [ ] Tool: get_flame_context [ ] Return JSON containing: Current Project, User, Workspace, and Version. [ ] Tool: list_desktop_clips [ ] Query Flame for all clips on the current Desktop. [ ] Tool: inspect_symbol [ ] Use Python's dir() and help() inside Flame to give the AI real-time documentation for any Flame object. Phase 4: Integration & Security [ ] Test the bridge with an MCP-compliant client (e.g., Claude Desktop or Cursor). [ ] Implement basic logging of all AI-generated commands for auditability. [ ] (Optional) Add a \"Read-Only\" mode toggle to prevent accidental modifications during inspection. Phase 5: Documentation & Examples [ ] Write a \"Getting Started\" guide for users to connect their LLM to the Flame MCP. [ ] Create a folder flame-mcp/prompts/ with system prompt templates that help the AI understand how to use the Flame tools effectively. [ ] Record a demo of an AI autonomously interacting with the Flame Desktop.","title":"Tasks: Flame-MCP Bridge Implementation"},{"location":"tasks/flame-mcp-bridge-tasks/#tasks-flame-mcp-bridge-implementation","text":"This document tracks the technical steps required to implement the Model Context Protocol (MCP) bridge for Autodesk Flame.","title":"Tasks: Flame-MCP Bridge Implementation"},{"location":"tasks/flame-mcp-bridge-tasks/#phase-1-environment-scaffolding","text":"[ ] Create flame-mcp/ directory structure. [ ] Initialize requirements.txt for the MCP server (e.g., fastmcp , requests , pydantic ). [ ] Set up a basic server.py using fastmcp . [ ] Create a README in flame-mcp/ explaining how to start the server.","title":"Phase 1: Environment &amp; Scaffolding"},{"location":"tasks/flame-mcp-bridge-tasks/#phase-2-core-communication-layer","text":"[ ] Implement the Relay client: a module to handle network communication with the existing flame-listener.py (port 5555). [ ] Standardize the error handling for relay failures (e.g., Flame is not running, Listener is down). [ ] Implement a \"Ping\" tool to verify the end-to-end connection: AI -> MCP -> Listener -> Flame .","title":"Phase 2: Core Communication Layer"},{"location":"tasks/flame-mcp-bridge-tasks/#phase-3-core-ai-tools","text":"[ ] Tool: execute_python [ ] Basic execution of strings. [ ] Return stdout and stderr to the AI. [ ] Tool: get_flame_context [ ] Return JSON containing: Current Project, User, Workspace, and Version. [ ] Tool: list_desktop_clips [ ] Query Flame for all clips on the current Desktop. [ ] Tool: inspect_symbol [ ] Use Python's dir() and help() inside Flame to give the AI real-time documentation for any Flame object.","title":"Phase 3: Core AI Tools"},{"location":"tasks/flame-mcp-bridge-tasks/#phase-4-integration-security","text":"[ ] Test the bridge with an MCP-compliant client (e.g., Claude Desktop or Cursor). [ ] Implement basic logging of all AI-generated commands for auditability. [ ] (Optional) Add a \"Read-Only\" mode toggle to prevent accidental modifications during inspection.","title":"Phase 4: Integration &amp; Security"},{"location":"tasks/flame-mcp-bridge-tasks/#phase-5-documentation-examples","text":"[ ] Write a \"Getting Started\" guide for users to connect their LLM to the Flame MCP. [ ] Create a folder flame-mcp/prompts/ with system prompt templates that help the AI understand how to use the Flame tools effectively. [ ] Record a demo of an AI autonomously interacting with the Flame Desktop.","title":"Phase 5: Documentation &amp; Examples"}]}