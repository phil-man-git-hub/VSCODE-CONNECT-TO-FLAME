{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"TODO/","text":"TODO \u2014 short term (high priority) Install debugpy into Flame and verify attach Add scripts/install_debugpy.py that can locate Flame's Python or accept a path and run pip install debugpy . Deploy debugpy and restart Flame, then run Flame: Start debug server and attach from VS Code to confirm. Document UI freeze caveats and recommend non-blocking workflows for debugging. Harden listener Add timeouts and cancellation for long-running scripts. Add better error responses and logging. Tests & CI Add automated tests for ping , execute , and token auth (mock + optional real-Flame tests guarded by env var). Add GitHub Actions workflow to run unit tests and linting. UX & polish Add extension snippets and ship .pyi stubs in extension/stubs/ . Add file-sync/auto-reload helper (optional feature). Prepare extension packaging and Marketplace publish flow. TODO \u2014 lower priority / future Add a debug mode for the listener that captures stack traces and execution metrics. Explore a safer main-thread execution API or request Flame upstream add a command port API.","title":"TODO \u2014 short term (high priority)"},{"location":"TODO/#todo-short-term-high-priority","text":"Install debugpy into Flame and verify attach Add scripts/install_debugpy.py that can locate Flame's Python or accept a path and run pip install debugpy . Deploy debugpy and restart Flame, then run Flame: Start debug server and attach from VS Code to confirm. Document UI freeze caveats and recommend non-blocking workflows for debugging. Harden listener Add timeouts and cancellation for long-running scripts. Add better error responses and logging. Tests & CI Add automated tests for ping , execute , and token auth (mock + optional real-Flame tests guarded by env var). Add GitHub Actions workflow to run unit tests and linting. UX & polish Add extension snippets and ship .pyi stubs in extension/stubs/ . Add file-sync/auto-reload helper (optional feature). Prepare extension packaging and Marketplace publish flow.","title":"TODO \u2014 short term (high priority)"},{"location":"TODO/#todo-lower-priority-future","text":"Add a debug mode for the listener that captures stack traces and execution metrics. Explore a safer main-thread execution API or request Flame upstream add a command port API.","title":"TODO \u2014 lower priority / future"},{"location":"architecture/","text":"Architecture This project uses a small three\u2011component architecture: Flame listener (inside Flame) \u2014 executes Python code on the Flame main thread and returns stdout/stderr/exceptions. VS Code extension \u2014 sends code to the listener, shows output, manages connection and stubs. Stub generator \u2014 generates .pyi files so VS Code can provide autocomplete and type information. Threading and execution model All calls to the Flame API must be run on Flame's main/UI thread. The listener should receive code and schedule its execution using flame.execute_on_main_thread() (or equivalent) to avoid UI races. Security and lifecycle Bind to localhost or use Unix domain sockets. Default to local-only access. Use a token-based handshake or restrict to OS-level local sockets for access control. Start the listener via Flame's Python startup mechanism so it is available whenever Flame runs. Testing Provide a mock_flame_server.py for local development and CI testing to allow extension development without an actual Flame instance.","title":"Architecture"},{"location":"architecture/#architecture","text":"This project uses a small three\u2011component architecture: Flame listener (inside Flame) \u2014 executes Python code on the Flame main thread and returns stdout/stderr/exceptions. VS Code extension \u2014 sends code to the listener, shows output, manages connection and stubs. Stub generator \u2014 generates .pyi files so VS Code can provide autocomplete and type information. Threading and execution model All calls to the Flame API must be run on Flame's main/UI thread. The listener should receive code and schedule its execution using flame.execute_on_main_thread() (or equivalent) to avoid UI races. Security and lifecycle Bind to localhost or use Unix domain sockets. Default to local-only access. Use a token-based handshake or restrict to OS-level local sockets for access control. Start the listener via Flame's Python startup mechanism so it is available whenever Flame runs. Testing Provide a mock_flame_server.py for local development and CI testing to allow extension development without an actual Flame instance.","title":"Architecture"},{"location":"deploy/","text":"Deploying the listener into a Flame project This document describes how to deploy the repository's listener and helpers into a Flame project so they run when Flame starts. Configure flame.project.json at the repo root with an appropriate scriptsDir pointing to your project's setups/python/ directory. Example: { \"projectId\": \"888_flame_code\", \"flameProjectPath\": \"/Volumes/Samsung-T3-1TB/Autodesk/flame/projects/888_flame_code_2027_romeo\", \"scriptsDir\": \"/Volumes/Samsung-T3-1TB/Autodesk/flame/projects/888_flame_code_2027_romeo/setups/python/\" } (Optional) Create a .flame.secrets.json in the repo root containing your listener token: { \"token\": \"your-flame-token\" } This file is ignored by git by default. For CI and automation, prefer environment variable FLAME_TOKEN . Run the deploy helper: python scripts/deploy_to_flame_project.py --copy This copies flame_listener.py , generate_stubs.py , and startup_flame_listener.py into your project's setups/python/ directory and (optionally) copies .flame.secrets.json . Launch Flame for the project: /opt/Autodesk/flame_2027.pr235/bin/startApplication -J \"888_flame_code_2027_romeo\" -W \"romeo\" Watch Flame's stdout for the listener startup message (the startup hook prints Flame listener startup hook started in background thread ). The listener will check the token on incoming requests and reject requests with invalid tokens. Run the extension's Flame: Connect command in VS Code (it will set the token automatically if FLAME_TOKEN or .flame.secrets.json is present in your workspace). Then use Flame: Run in Flame to send code. Notes The listener must be started by Flame's Python startup process \u2014 the startup_flame_listener.py hook will start the listener in a background thread. If you prefer to manually install files, copy the three files above into your project's setups/python/ directory and ensure the .flame.secrets.json token is present. Debugging / Next steps \ud83d\udd27 The deployed listener currently attempts to start debugpy on demand, but debugpy is not installed inside Flame by default. To enable debugging, install debugpy into Flame's Python environment (or stage debugpy into the project's setups/python/ ) and then use Flame: Start debug server from the extension to start the attachable debug server. Warning: Breakpoints and long-running pauses can freeze Flame's UI because Flame runs an embedded single-threaded Python interpreter. Test non-blocking/debug patterns first and document caveats. See docs/TODO.md for the installation and verification tasks.","title":"Deploying the listener into a Flame project"},{"location":"deploy/#deploying-the-listener-into-a-flame-project","text":"This document describes how to deploy the repository's listener and helpers into a Flame project so they run when Flame starts. Configure flame.project.json at the repo root with an appropriate scriptsDir pointing to your project's setups/python/ directory. Example: { \"projectId\": \"888_flame_code\", \"flameProjectPath\": \"/Volumes/Samsung-T3-1TB/Autodesk/flame/projects/888_flame_code_2027_romeo\", \"scriptsDir\": \"/Volumes/Samsung-T3-1TB/Autodesk/flame/projects/888_flame_code_2027_romeo/setups/python/\" } (Optional) Create a .flame.secrets.json in the repo root containing your listener token: { \"token\": \"your-flame-token\" } This file is ignored by git by default. For CI and automation, prefer environment variable FLAME_TOKEN . Run the deploy helper: python scripts/deploy_to_flame_project.py --copy This copies flame_listener.py , generate_stubs.py , and startup_flame_listener.py into your project's setups/python/ directory and (optionally) copies .flame.secrets.json . Launch Flame for the project: /opt/Autodesk/flame_2027.pr235/bin/startApplication -J \"888_flame_code_2027_romeo\" -W \"romeo\" Watch Flame's stdout for the listener startup message (the startup hook prints Flame listener startup hook started in background thread ). The listener will check the token on incoming requests and reject requests with invalid tokens. Run the extension's Flame: Connect command in VS Code (it will set the token automatically if FLAME_TOKEN or .flame.secrets.json is present in your workspace). Then use Flame: Run in Flame to send code. Notes The listener must be started by Flame's Python startup process \u2014 the startup_flame_listener.py hook will start the listener in a background thread. If you prefer to manually install files, copy the three files above into your project's setups/python/ directory and ensure the .flame.secrets.json token is present.","title":"Deploying the listener into a Flame project"},{"location":"deploy/#debugging-next-steps","text":"The deployed listener currently attempts to start debugpy on demand, but debugpy is not installed inside Flame by default. To enable debugging, install debugpy into Flame's Python environment (or stage debugpy into the project's setups/python/ ) and then use Flame: Start debug server from the extension to start the attachable debug server. Warning: Breakpoints and long-running pauses can freeze Flame's UI because Flame runs an embedded single-threaded Python interpreter. Test non-blocking/debug patterns first and document caveats. See docs/TODO.md for the installation and verification tasks.","title":"Debugging / Next steps \ud83d\udd27"},{"location":"extension_dev/","text":"Extension development \u2014 quick start Follow these steps to run and debug the Flame VS Code extension locally. Run in Extension Development Host (fast) Open this repository in VS Code. Open the extension/ folder in the Explorer. Press F5 (Run \u2192 Start Debugging) to launch the Extension Development Host. In the host window, open the Command Palette and run: Flame: Connect to connect to a listener (or use the mock server in tests/ ), Flame: Start debug server to request Flame start a debug server, Flame: Run in Flame to send the current file/selection to Flame. Development virtual environment We recommend using a system Python virtual environment for running tests and development tools so your environment is stable across Flame preview upgrades. Quick setup: # Create a system venv in repo root using system python3 python3 -m venv .venv # Activate source .venv/bin/activate # Install dev deps python -m pip install --upgrade pip setuptools wheel python -m pip install -r requirements.txt Or run the helper script: scripts/setup_dev_env.sh [python3] VS Code: select the interpreter from the Command Palette or rely on the workspace setting python.defaultInterpreterPath which points to ${workspaceFolder}/.venv/bin/python . If you want me to create the .venv now I can (I'll use system python3 unless you prefer otherwise). Flame package dependencies & notes The repository includes a set of runtime packages commonly used with Flame which we install into the dev venv for testing: PySide6 , OpenImageIO , OpenTimelineIO , OpenColorIO . Import names can differ from the pip package names (for example, opentimelineio is the import for OpenTimelineIO). In our smoke test OpenColorIO was not importable under OpenColorIO or opencolorio but is available as the PyOpenColorIO package (import as PyOpenColorIO ). The PyPI package name is opencolorio and docs are at https://opencolorio.readthedocs.io/en/latest/quick_start/installation.html. Prefer Flame-provided libraries when available. These packages include native/binary wheels that are tied to the Python ABI and macOS platform. If you upgrade Python (or change OS/architecture) you may need to reinstall or rebuild wheels. Verify imports in your dev venv with the included helper: source .venv/bin/activate python scripts/smoke_imports.py Environment variables - FLAME_LISTENER_LOG \u2014 path to append structured listener logs (defaults to /tmp/flame_listener.log ). - FLAME_LISTENER_RECV_TIMEOUT \u2014 socket recv timeout in seconds for each client connection (defaults to 5.0 ). Collecting debug info - Use scripts/collect_flame_debug_logs.py to collect a small bundle (ps, lsof, listener ping, a short breakpoint test, and head/tail of listener log) into /tmp for easier triage. To verify behavior inside a running Flame instance, use Flame: Run in Flame to execute a short script that prints import/version info, or run a small end-to-end test against the real Flame runtime. Example script: examples/inspect_flame_env.py prints the detected import names and versions for the common Flame runtime packages. Run it locally in your dev venv ( python examples/inspect_flame_env.py ) or send it to Flame with Flame: Run in Flame . Automated smoke test: tests/test_imports.py will attempt the same imports and will skip if packages are not available in the environment (so CI can opt-in by installing the binary deps). - When Flame's Python ABI or installation changes, recreate your venv ( rm -rf .venv && python3 -m venv .venv && scripts/setup_dev_env.sh ) before running dependent tests. Build & package Install deps: npm ci (run in extension/ or use the provided task Install extension deps ). Build: npm run compile (task: Build extension ). Package: npx vsce package (task: Package extension ) to produce a .vsix . Test the debug flow locally with the mock server Run the mock server once: python tests/mock_flame_server.py (it accepts one request and exits). Use tests/test_start_debug.py to verify the start_debug_server command is handled by the mock server. Useful files .vscode/launch.json \u2014 run the extension or attach to Flame (port 5678) examples/debug_test.py \u2014 example script that starts debugpy and waits for an attach tests/mock_flame_server.py \u2014 small single-request mock of Flame listener If you want, I can run the build and package steps now and run the test for start_debug_server .","title":"Extension development \u2014 quick start"},{"location":"extension_dev/#extension-development-quick-start","text":"Follow these steps to run and debug the Flame VS Code extension locally.","title":"Extension development \u2014 quick start"},{"location":"extension_dev/#run-in-extension-development-host-fast","text":"Open this repository in VS Code. Open the extension/ folder in the Explorer. Press F5 (Run \u2192 Start Debugging) to launch the Extension Development Host. In the host window, open the Command Palette and run: Flame: Connect to connect to a listener (or use the mock server in tests/ ), Flame: Start debug server to request Flame start a debug server, Flame: Run in Flame to send the current file/selection to Flame.","title":"Run in Extension Development Host (fast)"},{"location":"extension_dev/#development-virtual-environment","text":"We recommend using a system Python virtual environment for running tests and development tools so your environment is stable across Flame preview upgrades. Quick setup: # Create a system venv in repo root using system python3 python3 -m venv .venv # Activate source .venv/bin/activate # Install dev deps python -m pip install --upgrade pip setuptools wheel python -m pip install -r requirements.txt Or run the helper script: scripts/setup_dev_env.sh [python3] VS Code: select the interpreter from the Command Palette or rely on the workspace setting python.defaultInterpreterPath which points to ${workspaceFolder}/.venv/bin/python . If you want me to create the .venv now I can (I'll use system python3 unless you prefer otherwise).","title":"Development virtual environment"},{"location":"extension_dev/#flame-package-dependencies-notes","text":"The repository includes a set of runtime packages commonly used with Flame which we install into the dev venv for testing: PySide6 , OpenImageIO , OpenTimelineIO , OpenColorIO . Import names can differ from the pip package names (for example, opentimelineio is the import for OpenTimelineIO). In our smoke test OpenColorIO was not importable under OpenColorIO or opencolorio but is available as the PyOpenColorIO package (import as PyOpenColorIO ). The PyPI package name is opencolorio and docs are at https://opencolorio.readthedocs.io/en/latest/quick_start/installation.html. Prefer Flame-provided libraries when available. These packages include native/binary wheels that are tied to the Python ABI and macOS platform. If you upgrade Python (or change OS/architecture) you may need to reinstall or rebuild wheels. Verify imports in your dev venv with the included helper: source .venv/bin/activate python scripts/smoke_imports.py Environment variables - FLAME_LISTENER_LOG \u2014 path to append structured listener logs (defaults to /tmp/flame_listener.log ). - FLAME_LISTENER_RECV_TIMEOUT \u2014 socket recv timeout in seconds for each client connection (defaults to 5.0 ). Collecting debug info - Use scripts/collect_flame_debug_logs.py to collect a small bundle (ps, lsof, listener ping, a short breakpoint test, and head/tail of listener log) into /tmp for easier triage. To verify behavior inside a running Flame instance, use Flame: Run in Flame to execute a short script that prints import/version info, or run a small end-to-end test against the real Flame runtime. Example script: examples/inspect_flame_env.py prints the detected import names and versions for the common Flame runtime packages. Run it locally in your dev venv ( python examples/inspect_flame_env.py ) or send it to Flame with Flame: Run in Flame . Automated smoke test: tests/test_imports.py will attempt the same imports and will skip if packages are not available in the environment (so CI can opt-in by installing the binary deps). - When Flame's Python ABI or installation changes, recreate your venv ( rm -rf .venv && python3 -m venv .venv && scripts/setup_dev_env.sh ) before running dependent tests.","title":"Flame package dependencies &amp; notes"},{"location":"extension_dev/#build-package","text":"Install deps: npm ci (run in extension/ or use the provided task Install extension deps ). Build: npm run compile (task: Build extension ). Package: npx vsce package (task: Package extension ) to produce a .vsix .","title":"Build &amp; package"},{"location":"extension_dev/#test-the-debug-flow-locally-with-the-mock-server","text":"Run the mock server once: python tests/mock_flame_server.py (it accepts one request and exits). Use tests/test_start_debug.py to verify the start_debug_server command is handled by the mock server.","title":"Test the debug flow locally with the mock server"},{"location":"extension_dev/#useful-files","text":".vscode/launch.json \u2014 run the extension or attach to Flame (port 5678) examples/debug_test.py \u2014 example script that starts debugpy and waits for an attach tests/mock_flame_server.py \u2014 small single-request mock of Flame listener If you want, I can run the build and package steps now and run the test for start_debug_server .","title":"Useful files"},{"location":"goal/","text":"To expose Autodesk Flame\u2019s Python API inside VS Code in the same spirit as Blender/Maya/Nuke remote\u2011execution bridges, you need three components working together. Flame doesn\u2019t ship with a command port or socket server, so you\u2019d be building the missing piece yourself \u2014 but it\u2019s absolutely doable. Below is the clean, architecture\u2011level breakdown of what\u2019s required. \ud83e\udde9 1. A host\u2011side listener running inside Flame Flame must run a small Python process that: Listens on a TCP socket, Unix socket, or named pipe Receives Python code sent from VS Code Executes it inside Flame\u2019s embedded Python interpreter Returns stdout/stderr or structured JSON back to VS Code This is the same pattern used by: - Maya\u2019s commandPort - Nuke\u2019s TCP Python bridge - Houdini\u2019s hrpyc - Blender\u2019s remote Python server What this listener must handle Authentication (simple token or local\u2011only binding) Execution sandboxing (Flame API calls must run on the main thread) Error capture and return Optional: auto\u2011reload of modules for iterative development How you\u2019d run it Flame allows Python hooks and background tasks. You\u2019d typically launch the listener via: A Flame Python startup hook A custom Action or Batch script A background thread inside Flame\u2019s Python environment \ud83e\udde9 2. A VS Code extension that talks to the listener This is the \u201cAdobe Script Runner\u201d equivalent. The extension would: Provide a command: Run in Flame Send the current file or selected text to the Flame listener Display results in a VS Code output panel Optionally provide: Autocomplete stubs for the Flame API Snippets for PyClip, PySequence, PySegment, etc. A \u201cconnect/disconnect\u201d status indicator Implementation stack Node.js extension using net.Socket or WebSocket Configuration for host/port Commands bound to keyboard shortcuts \ud83e\udde9 3. Flame Python API stubs for IntelliSense VS Code can\u2019t introspect Flame\u2019s Python environment directly, so you\u2019d generate stub files: flame.pyi PyClip.pyi PySequence.pyi PySegment.pyi PyTime.pyi etc. These stubs would provide: Autocomplete Type hints Docstrings Method signatures You can generate them by: - Scraping the Autodesk docs - Using dir() inside Flame and exporting attributes - Manually writing .pyi files This is exactly how Blender, Houdini, and Nuke provide IntelliSense in VS Code. \ud83e\udde9 4. Optional: Debugger integration This is harder because Flame embeds Python, but still possible. You\u2019d need: A debug adapter that attaches to Flame\u2019s Python interpreter A small shim inside Flame that loads debugpy or similar This is how Blender and Maya debugging works in VS Code. \ud83e\udde9 5. Optional: File sync / Add\u2011on packaging If you want a full developer experience: Auto\u2011sync scripts into Flame\u2019s python/ directory Auto\u2011reload modules when files change One\u2011click packaging for Flame Python hooks \ud83e\udde0 Summary: What Flame is missing today Flame does not provide: A command port A remote Python execution API A debugger hook So the requirement is to build a small remote\u2011execution bridge , exactly like the community did for Nuke, Houdini, and Blender. Once that exists, VS Code integration becomes straightforward. If you want, I can sketch the architecture for a minimal working prototype , including: The Flame\u2011side Python listener The VS Code extension structure The communication protocol The .pyi stub generator Just say the word and I\u2019ll map it out.","title":"Goal"},{"location":"goal/#1-a-hostside-listener-running-inside-flame","text":"Flame must run a small Python process that: Listens on a TCP socket, Unix socket, or named pipe Receives Python code sent from VS Code Executes it inside Flame\u2019s embedded Python interpreter Returns stdout/stderr or structured JSON back to VS Code This is the same pattern used by: - Maya\u2019s commandPort - Nuke\u2019s TCP Python bridge - Houdini\u2019s hrpyc - Blender\u2019s remote Python server","title":"\ud83e\udde9 1. A host\u2011side listener running inside Flame"},{"location":"goal/#what-this-listener-must-handle","text":"Authentication (simple token or local\u2011only binding) Execution sandboxing (Flame API calls must run on the main thread) Error capture and return Optional: auto\u2011reload of modules for iterative development","title":"What this listener must handle"},{"location":"goal/#how-youd-run-it","text":"Flame allows Python hooks and background tasks. You\u2019d typically launch the listener via: A Flame Python startup hook A custom Action or Batch script A background thread inside Flame\u2019s Python environment","title":"How you\u2019d run it"},{"location":"goal/#2-a-vs-code-extension-that-talks-to-the-listener","text":"This is the \u201cAdobe Script Runner\u201d equivalent. The extension would: Provide a command: Run in Flame Send the current file or selected text to the Flame listener Display results in a VS Code output panel Optionally provide: Autocomplete stubs for the Flame API Snippets for PyClip, PySequence, PySegment, etc. A \u201cconnect/disconnect\u201d status indicator","title":"\ud83e\udde9 2. A VS Code extension that talks to the listener"},{"location":"goal/#implementation-stack","text":"Node.js extension using net.Socket or WebSocket Configuration for host/port Commands bound to keyboard shortcuts","title":"Implementation stack"},{"location":"goal/#3-flame-python-api-stubs-for-intellisense","text":"VS Code can\u2019t introspect Flame\u2019s Python environment directly, so you\u2019d generate stub files: flame.pyi PyClip.pyi PySequence.pyi PySegment.pyi PyTime.pyi etc. These stubs would provide: Autocomplete Type hints Docstrings Method signatures You can generate them by: - Scraping the Autodesk docs - Using dir() inside Flame and exporting attributes - Manually writing .pyi files This is exactly how Blender, Houdini, and Nuke provide IntelliSense in VS Code.","title":"\ud83e\udde9 3. Flame Python API stubs for IntelliSense"},{"location":"goal/#4-optional-debugger-integration","text":"This is harder because Flame embeds Python, but still possible. You\u2019d need: A debug adapter that attaches to Flame\u2019s Python interpreter A small shim inside Flame that loads debugpy or similar This is how Blender and Maya debugging works in VS Code.","title":"\ud83e\udde9 4. Optional: Debugger integration"},{"location":"goal/#5-optional-file-sync-addon-packaging","text":"If you want a full developer experience: Auto\u2011sync scripts into Flame\u2019s python/ directory Auto\u2011reload modules when files change One\u2011click packaging for Flame Python hooks","title":"\ud83e\udde9 5. Optional: File sync / Add\u2011on packaging"},{"location":"goal/#summary-what-flame-is-missing-today","text":"Flame does not provide: A command port A remote Python execution API A debugger hook So the requirement is to build a small remote\u2011execution bridge , exactly like the community did for Nuke, Houdini, and Blender. Once that exists, VS Code integration becomes straightforward. If you want, I can sketch the architecture for a minimal working prototype , including: The Flame\u2011side Python listener The VS Code extension structure The communication protocol The .pyi stub generator Just say the word and I\u2019ll map it out.","title":"\ud83e\udde0 Summary: What Flame is missing today"},{"location":"mvp/","text":"MVP Acceptance Criteria The Minimal Viable Product should provide a usable development loop for writing and testing Flame Python scripts. Acceptance criteria: Run in Flame executes code in a running Flame instance (or the mock_flame_server.py during local dev). Output (stdout/stderr) and exceptions are displayed in VS Code's Output panel. Connection must be secure by default (localhost or Unix socket) and support token auth. .pyi stubs are available to provide basic autocomplete for common Flame types. Automated tests cover the extension client's serialization and a mock server interaction.","title":"MVP Acceptance Criteria"},{"location":"mvp/#mvp-acceptance-criteria","text":"The Minimal Viable Product should provide a usable development loop for writing and testing Flame Python scripts. Acceptance criteria: Run in Flame executes code in a running Flame instance (or the mock_flame_server.py during local dev). Output (stdout/stderr) and exceptions are displayed in VS Code's Output panel. Connection must be secure by default (localhost or Unix socket) and support token auth. .pyi stubs are available to provide basic autocomplete for common Flame types. Automated tests cover the extension client's serialization and a mock server interaction.","title":"MVP Acceptance Criteria"},{"location":"protocol/","text":"Communication Protocol Transport TCP socket (localhost) \u2014 easiest for cross-platform dev. Optional: Unix domain socket for local-only secure communication. Message format Client \u2192 Listener (JSON): { \"command\": \"execute\", \"id\": \"uuid-or-counter\", \"token\": \"optional-auth-token\", \"code\": \"print('hello from VS Code')\" } Listener \u2192 Client (JSON response): { \"id\": \"same-id\", \"stdout\": \"Hello\\n\", \"stderr\": \"\", \"exception\": null } Commands execute \u2014 run the provided code; return stdout/stderr and any exception details. ping \u2014 health check. open_file (optional) \u2014 request Flame to open or load a file. Notes All responses must include the request id to allow in-flight matching and timeouts. Keep messages compact; only serialize structured data in JSON. Use base64 for binary payloads if needed.","title":"Communication Protocol"},{"location":"protocol/#communication-protocol","text":"Transport TCP socket (localhost) \u2014 easiest for cross-platform dev. Optional: Unix domain socket for local-only secure communication. Message format Client \u2192 Listener (JSON): { \"command\": \"execute\", \"id\": \"uuid-or-counter\", \"token\": \"optional-auth-token\", \"code\": \"print('hello from VS Code')\" } Listener \u2192 Client (JSON response): { \"id\": \"same-id\", \"stdout\": \"Hello\\n\", \"stderr\": \"\", \"exception\": null } Commands execute \u2014 run the provided code; return stdout/stderr and any exception details. ping \u2014 health check. open_file (optional) \u2014 request Flame to open or load a file. Notes All responses must include the request id to allow in-flight matching and timeouts. Keep messages compact; only serialize structured data in JSON. Use base64 for binary payloads if needed.","title":"Communication Protocol"},{"location":"roadmap/","text":"Here\u2019s a full, end\u2011to\u2011end architecture for exposing Autodesk Flame\u2019s Python API inside VS Code \u2014 the closest possible equivalent to Adobe Script Runner, Maya\u2019s commandPort, Nuke\u2019s TCP bridge, or Houdini\u2019s hrpyc. This is a practical blueprint , not a hand\u2011wave. If you wanted to build this, this is exactly what you\u2019d implement. 1. Flame\u2011Side Component: The Python Listener This is the missing piece Flame doesn\u2019t provide natively. You embed a small Python server inside Flame\u2019s Python interpreter that: Opens a local TCP socket (e.g., localhost:5555 ) Accepts incoming Python code Executes it inside Flame\u2019s environment Returns stdout, stderr, and exceptions Ensures Flame API calls run on the main thread Core responsibilities Execution loop Receive \u2192 Execute \u2192 Return result Thread safety Flame API calls must run on the UI thread; you wrap execution in flame.execute_on_main_thread() . Security Bind to localhost only, require a token, or use a Unix domain socket. Lifecycle Start automatically via a Flame Python hook. Where it lives Flame loads Python from: /opt/Autodesk/flame_2025/python/ ~/.config/Autodesk/Flame/python/ You\u2019d install the listener as a Flame startup hook: python/startup/flame_listener.py 2. Communication Protocol Keep it simple and robust. Transport TCP socket (easiest) Optional: WebSocket (if you want browser\u2011based tools later) Optional: Unix domain socket (secure, local\u2011only) Message format Use JSON for structured communication: { \"command\": \"execute\", \"code\": \"import flame\\nprint(flame.project.current_project.name)\" } Response format { \"stdout\": \"MyProject\\n\", \"stderr\": \"\", \"exception\": null } 3. VS Code Extension This is the user\u2011facing part \u2014 the equivalent of Adobe Script Runner. Capabilities Run in Flame command Sends selected text or entire file to the Flame listener. Output panel Displays stdout, stderr, exceptions. Connection manager Connect/disconnect, show status, auto\u2011reconnect. Keyboard shortcuts e.g., Ctrl+Shift+F to execute in Flame. Snippets Quickly insert common Flame API patterns. Optional: Debugger integration If you embed debugpy inside Flame. Extension structure flame-vscode/ package.json extension.js src/ client.js commands/ runInFlame.js connect.js disconnect.js syntaxes/ snippets/ stubs/ User workflow Open a .py file. Press \u201cRun in Flame\u201d. Code executes inside Flame instantly. Output appears in VS Code. 4. Flame API IntelliSense (Stub Files) VS Code cannot introspect Flame\u2019s embedded Python, so you generate .pyi stub files. Stub generation approach Inside Flame: import flame dir(flame) You then generate: stubs/flame.pyi stubs/PyClip.pyi stubs/PySequence.pyi stubs/PySegment.pyi ... These provide: Autocomplete Type hints Docstrings Method signatures Integration The VS Code extension ships with these stubs and configures: \"python.analysis.extraPaths\": [ \"./stubs\" ] 5. Optional: Debugger Integration This is advanced but possible. Approach Bundle debugpy with the Flame listener. Start a debug server inside Flame. VS Code attaches to it. Limitations Flame\u2019s Python interpreter is embedded and single\u2011threaded. Breakpoints inside Flame API calls may freeze the UI. Still, it\u2019s doable for non\u2011UI\u2011blocking code. 6. Optional: File Sync & Auto\u2011Reload To mimic Blender/Maya add\u2011on workflows: Features Auto\u2011sync your VS Code project into Flame\u2019s Python directory. Auto\u2011reload modules when files change. One\u2011click packaging for Flame Python hooks. Implementation Use VS Code\u2019s file watcher API to push changes to Flame via: SFTP rsync Local mount Or the socket protocol itself 7. Optional: Batch/Action Node Helpers You can extend the extension to: Create Batch nodes from VS Code Modify Action setups Inspect clip metadata Trigger renders Query project structure This is where the Flame API becomes extremely powerful. 8. Putting It All Together Here\u2019s the full architecture in one view: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 VS Code \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Flame VS Code Extension\u2502 \u2502 \u2502 \u2502 - Run in Flame \u2502 \u2502 \u2502 \u2502 - Output Panel \u2502 \u2502 \u2502 \u2502 - Autocomplete (stubs)\u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 TCP / JSON \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Autodesk Flame \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Python Listener \u2502 \u2502 \u2502 \u2502 - Socket server \u2502 \u2502 \u2502 \u2502 - Execute code \u2502 \u2502 \u2502 \u2502 - Return results \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 Flame Python API \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 If you want, I can now produce: A minimal working prototype of the Flame listener The VS Code extension skeleton The communication protocol spec The stub generator script A roadmap for turning this into a production\u2011ready tool Just tell me which piece you want to see next.","title":"Roadmap"},{"location":"roadmap/#1-flameside-component-the-python-listener","text":"This is the missing piece Flame doesn\u2019t provide natively. You embed a small Python server inside Flame\u2019s Python interpreter that: Opens a local TCP socket (e.g., localhost:5555 ) Accepts incoming Python code Executes it inside Flame\u2019s environment Returns stdout, stderr, and exceptions Ensures Flame API calls run on the main thread","title":"1. Flame\u2011Side Component: The Python Listener"},{"location":"roadmap/#core-responsibilities","text":"Execution loop Receive \u2192 Execute \u2192 Return result Thread safety Flame API calls must run on the UI thread; you wrap execution in flame.execute_on_main_thread() . Security Bind to localhost only, require a token, or use a Unix domain socket. Lifecycle Start automatically via a Flame Python hook.","title":"Core responsibilities"},{"location":"roadmap/#where-it-lives","text":"Flame loads Python from: /opt/Autodesk/flame_2025/python/ ~/.config/Autodesk/Flame/python/ You\u2019d install the listener as a Flame startup hook: python/startup/flame_listener.py","title":"Where it lives"},{"location":"roadmap/#2-communication-protocol","text":"Keep it simple and robust.","title":"2. Communication Protocol"},{"location":"roadmap/#transport","text":"TCP socket (easiest) Optional: WebSocket (if you want browser\u2011based tools later) Optional: Unix domain socket (secure, local\u2011only)","title":"Transport"},{"location":"roadmap/#message-format","text":"Use JSON for structured communication: { \"command\": \"execute\", \"code\": \"import flame\\nprint(flame.project.current_project.name)\" }","title":"Message format"},{"location":"roadmap/#response-format","text":"{ \"stdout\": \"MyProject\\n\", \"stderr\": \"\", \"exception\": null }","title":"Response format"},{"location":"roadmap/#3-vs-code-extension","text":"This is the user\u2011facing part \u2014 the equivalent of Adobe Script Runner.","title":"3. VS Code Extension"},{"location":"roadmap/#capabilities","text":"Run in Flame command Sends selected text or entire file to the Flame listener. Output panel Displays stdout, stderr, exceptions. Connection manager Connect/disconnect, show status, auto\u2011reconnect. Keyboard shortcuts e.g., Ctrl+Shift+F to execute in Flame. Snippets Quickly insert common Flame API patterns. Optional: Debugger integration If you embed debugpy inside Flame.","title":"Capabilities"},{"location":"roadmap/#extension-structure","text":"flame-vscode/ package.json extension.js src/ client.js commands/ runInFlame.js connect.js disconnect.js syntaxes/ snippets/ stubs/","title":"Extension structure"},{"location":"roadmap/#user-workflow","text":"Open a .py file. Press \u201cRun in Flame\u201d. Code executes inside Flame instantly. Output appears in VS Code.","title":"User workflow"},{"location":"roadmap/#4-flame-api-intellisense-stub-files","text":"VS Code cannot introspect Flame\u2019s embedded Python, so you generate .pyi stub files.","title":"4. Flame API IntelliSense (Stub Files)"},{"location":"roadmap/#stub-generation-approach","text":"Inside Flame: import flame dir(flame) You then generate: stubs/flame.pyi stubs/PyClip.pyi stubs/PySequence.pyi stubs/PySegment.pyi ... These provide: Autocomplete Type hints Docstrings Method signatures","title":"Stub generation approach"},{"location":"roadmap/#integration","text":"The VS Code extension ships with these stubs and configures: \"python.analysis.extraPaths\": [ \"./stubs\" ]","title":"Integration"},{"location":"roadmap/#5-optional-debugger-integration","text":"This is advanced but possible.","title":"5. Optional: Debugger Integration"},{"location":"roadmap/#approach","text":"Bundle debugpy with the Flame listener. Start a debug server inside Flame. VS Code attaches to it.","title":"Approach"},{"location":"roadmap/#limitations","text":"Flame\u2019s Python interpreter is embedded and single\u2011threaded. Breakpoints inside Flame API calls may freeze the UI. Still, it\u2019s doable for non\u2011UI\u2011blocking code.","title":"Limitations"},{"location":"roadmap/#6-optional-file-sync-autoreload","text":"To mimic Blender/Maya add\u2011on workflows:","title":"6. Optional: File Sync &amp; Auto\u2011Reload"},{"location":"roadmap/#features","text":"Auto\u2011sync your VS Code project into Flame\u2019s Python directory. Auto\u2011reload modules when files change. One\u2011click packaging for Flame Python hooks.","title":"Features"},{"location":"roadmap/#implementation","text":"Use VS Code\u2019s file watcher API to push changes to Flame via: SFTP rsync Local mount Or the socket protocol itself","title":"Implementation"},{"location":"roadmap/#7-optional-batchaction-node-helpers","text":"You can extend the extension to: Create Batch nodes from VS Code Modify Action setups Inspect clip metadata Trigger renders Query project structure This is where the Flame API becomes extremely powerful.","title":"7. Optional: Batch/Action Node Helpers"},{"location":"roadmap/#8-putting-it-all-together","text":"Here\u2019s the full architecture in one view: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 VS Code \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Flame VS Code Extension\u2502 \u2502 \u2502 \u2502 - Run in Flame \u2502 \u2502 \u2502 \u2502 - Output Panel \u2502 \u2502 \u2502 \u2502 - Autocomplete (stubs)\u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 TCP / JSON \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Autodesk Flame \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 Python Listener \u2502 \u2502 \u2502 \u2502 - Socket server \u2502 \u2502 \u2502 \u2502 - Execute code \u2502 \u2502 \u2502 \u2502 - Return results \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 Flame Python API \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"8. Putting It All Together"},{"location":"roadmap/#if-you-want-i-can-now-produce","text":"A minimal working prototype of the Flame listener The VS Code extension skeleton The communication protocol spec The stub generator script A roadmap for turning this into a production\u2011ready tool Just tell me which piece you want to see next.","title":"If you want, I can now produce:"},{"location":"stubs/","text":"Stub files for IntelliSense VS Code cannot inspect Flame's embedded Python interpreter at design time, so the extension ships .pyi stub files to provide types and docstrings. Generation strategy: Inside Flame: run a script that imports flame and uses dir() and inspect to enumerate modules, classes, and callable signatures. Emit .pyi files for the main flame interface and common classes like PyClip , PySequence , PySegment . Ship stubs in extension/stubs/ and add to python.analysis.extraPaths when using the extension in development. flame-listener/generate_stubs.py contains a starting point to generate .pyi files from a running Flame instance.","title":"Stub files for IntelliSense"},{"location":"stubs/#stub-files-for-intellisense","text":"VS Code cannot inspect Flame's embedded Python interpreter at design time, so the extension ships .pyi stub files to provide types and docstrings. Generation strategy: Inside Flame: run a script that imports flame and uses dir() and inspect to enumerate modules, classes, and callable signatures. Emit .pyi files for the main flame interface and common classes like PyClip , PySequence , PySegment . Ship stubs in extension/stubs/ and add to python.analysis.extraPaths when using the extension in development. flame-listener/generate_stubs.py contains a starting point to generate .pyi files from a running Flame instance.","title":"Stub files for IntelliSense"},{"location":"vision/","text":"Vision To expose Autodesk Flame\u2019s Python API inside VS Code in the same spirit as Blender/Maya/Nuke remote\u2011execution bridges, you need three components working together. Flame doesn\u2019t ship with a command port or socket server, so you\u2019d be building the missing piece yourself \u2014 but it\u2019s absolutely doable. This repository provides a pragmatic path to a developer\u2011friendly workflow: a Flame\u2011side listener, a VS Code extension, and type stubs that provide IntelliSense. Key components A Flame startup hook that runs a small TCP/Unix socket listener inside Flame\u2019s Python environment. A VS Code extension that sends Python code to Flame for execution and surfaces stdout/stderr/exceptions. Generated .pyi stub files to enable autocomplete and type checking in VS Code. See docs/protocol.md for message formats and docs/architecture.md for component responsibilities. Per-project configuration When you work with a specific Flame project, create a flame.project.json file at the repository root (see flame.project.example.json ) to store per-project metadata and paths (for example, flameProjectPath and scriptsDir ). For sensitive values such as tokens, use environment variables (for example FLAME_TOKEN ) or a workspace-local .flame.secrets.json file that is ignored by git. The extension will read these values from the workspace root or from flame.project workspace settings and use them to populate default host/port and sync targets.","title":"Vision"},{"location":"vision/#vision","text":"To expose Autodesk Flame\u2019s Python API inside VS Code in the same spirit as Blender/Maya/Nuke remote\u2011execution bridges, you need three components working together. Flame doesn\u2019t ship with a command port or socket server, so you\u2019d be building the missing piece yourself \u2014 but it\u2019s absolutely doable. This repository provides a pragmatic path to a developer\u2011friendly workflow: a Flame\u2011side listener, a VS Code extension, and type stubs that provide IntelliSense.","title":"Vision"},{"location":"vision/#key-components","text":"A Flame startup hook that runs a small TCP/Unix socket listener inside Flame\u2019s Python environment. A VS Code extension that sends Python code to Flame for execution and surfaces stdout/stderr/exceptions. Generated .pyi stub files to enable autocomplete and type checking in VS Code. See docs/protocol.md for message formats and docs/architecture.md for component responsibilities.","title":"Key components"},{"location":"vision/#per-project-configuration","text":"When you work with a specific Flame project, create a flame.project.json file at the repository root (see flame.project.example.json ) to store per-project metadata and paths (for example, flameProjectPath and scriptsDir ). For sensitive values such as tokens, use environment variables (for example FLAME_TOKEN ) or a workspace-local .flame.secrets.json file that is ignored by git. The extension will read these values from the workspace root or from flame.project workspace settings and use them to populate default host/port and sync targets.","title":"Per-project configuration"},{"location":"api/TODO/","text":"API Documentation TODO This TODO tracks the work items for building a comprehensive Flame Python API knowledge base. [x] API-0001 (partial): Create the overall plan and infrastructure for per-symbol docs (scripts + basic output) [x] API-0002: Add symbol cross-links from flame.md and index.json (initial links present) [x] API-0003 (partial): Add class methods capture (collector captures methods) [x] API-0004 (partial): Implement safe probing ( --probe-safe implemented, opt-in) [x] API-0005 (partial): Improve stubs/*.pyi with signatures (done for many symbols) [x] API-0006: Add stub parsing tests (planned) [x] API-0007: Add example hooks (startup/menu/asset-sync) and smoke tests \u2705 [x] API-0008: Add snippets for Project/Timeline/Clip and smoke tests \u2705 [x] API-0009: Add mkdocs + CI publishing (CI workflow added; deploy on push) \u2705 [x] API-0010: Generate per-symbol Markdown pages: docs/api/classes/<Class>.md , docs/api/functions/<fn>.md , docs/api/constants/<c>.md (completed; initial pages generated) Note: Per-symbol pages were generated from a live Flame process using the collector. Next: add mkdocs nav entries and expand content (method details, examples, cross-links). - [ ] API-0011: Add instance attribute probes via allowlist and document safety - [ ] API-0012: Improve stub return-type population from probe results - [ ] API-0013: Add mkdocs nav entries for symbol directories and symbol index pages - [ ] API-0014: Add CI job to optionally run --probe-safe and store results as artifacts - [ ] API-0015: Add a probe dashboard and flagged warnings page Notes: - Items marked \"partial\" mean scaffold/implementation exists but further work is needed. - I will now implement API-0010 (per-symbol pages) and mark progress as this completes.","title":"API Documentation TODO"},{"location":"api/TODO/#api-documentation-todo","text":"This TODO tracks the work items for building a comprehensive Flame Python API knowledge base. [x] API-0001 (partial): Create the overall plan and infrastructure for per-symbol docs (scripts + basic output) [x] API-0002: Add symbol cross-links from flame.md and index.json (initial links present) [x] API-0003 (partial): Add class methods capture (collector captures methods) [x] API-0004 (partial): Implement safe probing ( --probe-safe implemented, opt-in) [x] API-0005 (partial): Improve stubs/*.pyi with signatures (done for many symbols) [x] API-0006: Add stub parsing tests (planned) [x] API-0007: Add example hooks (startup/menu/asset-sync) and smoke tests \u2705 [x] API-0008: Add snippets for Project/Timeline/Clip and smoke tests \u2705 [x] API-0009: Add mkdocs + CI publishing (CI workflow added; deploy on push) \u2705 [x] API-0010: Generate per-symbol Markdown pages: docs/api/classes/<Class>.md , docs/api/functions/<fn>.md , docs/api/constants/<c>.md (completed; initial pages generated) Note: Per-symbol pages were generated from a live Flame process using the collector. Next: add mkdocs nav entries and expand content (method details, examples, cross-links). - [ ] API-0011: Add instance attribute probes via allowlist and document safety - [ ] API-0012: Improve stub return-type population from probe results - [ ] API-0013: Add mkdocs nav entries for symbol directories and symbol index pages - [ ] API-0014: Add CI job to optionally run --probe-safe and store results as artifacts - [ ] API-0015: Add a probe dashboard and flagged warnings page Notes: - Items marked \"partial\" mean scaffold/implementation exists but further work is needed. - I will now implement API-0010 (per-symbol pages) and mark progress as this completes.","title":"API Documentation TODO"},{"location":"api/flame/","text":"Module: flame Classes class PyActionFamilyNode Class derived from PyNode. Represents an Action Family node object. Methods node_types(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list nodes(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list cursor_position(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> tuple all_tabs(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list left_tabs(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list right_tabs(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list create_node(...) (builtin) \u2014 create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : organize(...) (builtin) \u2014 organize( (PyActionFamilyNode)arg1) -> bool : get_node(...) (builtin) \u2014 get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : connect_nodes(...) (builtin) \u2014 connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : disconnect_nodes(...) (builtin) \u2014 disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : media_layers(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list clear_schematic(...) (builtin) \u2014 clear_schematic( (PyActionFamilyNode)arg1) -> bool : encompass_nodes(...) (builtin) \u2014 encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : class PyActionNode Class derived from PyActionFamilyNode. Represents an Action node object. Methods media_nodes(...) (property) \u2014 None( (flame.PyActionNode)arg1) -> list add_media(...) (builtin) \u2014 add_media( (PyActionFamilyNode)arg1) -> object : import_fbx(...) (builtin) \u2014 import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : export_fbx(...) (builtin) \u2014 export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : read_fbx(...) (builtin) \u2014 read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : import_abc(...) (builtin) \u2014 import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : read_abc(...) (builtin) \u2014 read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : import_psd(...) (builtin) \u2014 import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : enable_output(...) (builtin) \u2014 enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : disable_output(...) (builtin) \u2014 disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : output_types(...) (property) \u2014 None( (flame.PyActionNode)arg1) -> list class PyArchiveEntry Class derived from PyFlameObject. Base class for any object displayed in the Media Panel. Methods get_wiretap_storage_id(...) (builtin) \u2014 get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : get_wiretap_node_id(...) (builtin) \u2014 get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : commit(...) (builtin) \u2014 commit( (PyArchiveEntry)arg1) -> None : clear_colour(...) (builtin) \u2014 clear_colour( (PyArchiveEntry)arg1) -> None : class PyAttribute Methods values(...) (property) \u2014 None( (flame.PyAttribute)arg1) -> object set_value(...) (builtin) \u2014 set_value( (PyAttribute)arg1, (object)arg2) -> bool : get_value(...) (builtin) \u2014 get_value( (PyAttribute)arg1) -> object : class PyAudioTrack Object representing an Audio Track. Methods channels(...) (property) \u2014 None( (flame.PyAudioTrack)arg1) -> list stereo(...) (property) \u2014 None( (flame.PyAudioTrack)arg1) -> bool copy_to_media_panel(...) (builtin) \u2014 copy_to_media_panel( (PyAudioTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : class PyBatch Class derived from PyFlameObject. This class represents a Batch Group. Methods nodes(...) (property) \u2014 None( (flame.PyBatch)arg1) -> list node_types(...) (property) \u2014 None( (flame.PyBatch)arg1) -> list reels(...) (property) \u2014 None( (flame.PyBatch)arg1) -> list shelf_reels(...) (property) \u2014 None( (flame.PyBatch)arg1) -> list batch_iterations(...) (property) \u2014 None( (flame.PyBatch)arg1) -> list current_iteration(...) (property) \u2014 None( (flame.PyBatch)arg1) -> object contexts(...) (property) \u2014 None( (flame.PyBatch)arg1) -> dict cursor_position(...) (property) \u2014 None( (flame.PyBatch)arg1) -> tuple opened(...) (property) \u2014 None( (flame.PyBatch)arg1) -> bool current_iteration_number(...) (property) \u2014 None( (flame.PyBatch)arg1) -> int get_node(...) (builtin) \u2014 get_node( (PyBatch)arg1, (str)node_name) -> object : create_node(...) (builtin) \u2014 create_node( (PyBatch)arg1, (str)node_type [, (str)file_path='']) -> object : connect_nodes(...) (builtin) \u2014 connect_nodes( (PyBatch)arg1, (PyNode)output_node, (str)output_socket_name='Default', (PyNode)input_node [, (str)input_socket_name='Default']) -> bool : disconnect_node(...) (builtin) \u2014 disconnect_node( (PyBatch)arg1, (PyNode)node [, (str)input_socket_name='']) -> bool : mimic_link(...) (builtin) \u2014 mimic_link( (PyBatch)arg1, (PyNode)leader_node, (PyNode)follower_node) -> bool : clear_context(...) (builtin) \u2014 clear_context( (PyBatch)arg1, (int)index) -> bool : clear_all_contexts(...) (builtin) \u2014 clear_all_contexts( (PyBatch)arg1) -> bool : organize(...) (builtin) \u2014 organize( (PyBatch)arg1) -> bool : frame_selected(...) (builtin) \u2014 frame_selected( (PyBatch)arg1) -> bool : frame_all(...) (builtin) \u2014 frame_all( (PyBatch)arg1) -> bool : import_clip(...) (builtin) \u2014 import_clip( (PyBatch)arg1, (str)file_path, (str)reel_name) -> object : import_clips(...) (builtin) \u2014 import_clips( (PyBatch)arg1, (object)file_paths, (str)reel_name) -> object : save_setup(...) (builtin) \u2014 save_setup( (PyBatch)arg1, (str)setup_path) -> bool : append_setup(...) (builtin) \u2014 append_setup( (PyBatch)arg1, (str)setup_path [, (bool)confirm=True]) -> bool : set_viewport_layout(...) (builtin) \u2014 set_viewport_layout( (PyBatch)arg1, (object)num_views) -> bool : create_batch_group(...) (builtin) \u2014 create_batch_group( (PyBatch)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : encompass_nodes(...) (builtin) \u2014 encompass_nodes( (PyBatch)arg1, (list)nodes) -> object : select_nodes(...) (builtin) \u2014 select_nodes( (PyBatch)arg1, (object)nodes) -> bool : open(...) (builtin) \u2014 open( (PyBatch)arg1) -> bool : close(...) (builtin) \u2014 close( (PyBatch)arg1) -> bool : clear(...) (builtin) \u2014 clear( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : save(...) (builtin) \u2014 save( (PyBatch)arg1) -> object : append_to_setup(...) (builtin) \u2014 append_to_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : append_to_batch(...) (builtin) \u2014 append_to_batch( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : open_as_batch_group(...) (builtin) \u2014 open_as_batch_group( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : replace_setup(...) (builtin) \u2014 replace_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration [, (bool)confirm=True]) -> bool : create_reel(...) (builtin) \u2014 create_reel( (PyBatch)arg1, (str)name) -> object : create_shelf_reel(...) (builtin) \u2014 create_shelf_reel( (PyBatch)arg1, (str)name) -> object : clear_colour(...) (builtin) \u2014 clear_colour( (PyBatch)arg1) -> None : go_to(...) (builtin) \u2014 go_to( (PyBatch)arg1) -> bool : load_setup(...) (builtin) \u2014 load_setup( (PyBatch)arg1, (str)setup_path) -> bool : clear_setup(...) (builtin) \u2014 clear_setup( (PyBatch)arg1) -> bool : iterate(...) (builtin) \u2014 iterate( (PyBatch)arg1 [, (int)index=-1]) -> object : save_current_iteration(...) (builtin) \u2014 save_current_iteration( (PyBatch)arg1) -> object : render(...) (builtin) \u2014 render( (PyBatch)arg1 [, (str)render_option='Foreground' [, (bool)generate_proxies=False [, (bool)include_history=False]]]) -> bool : class PyBatchIteration Class derived from PyArchiveEntry. This class represents a Batch Iteration. Methods iteration_number(...) (property) \u2014 None( (flame.PyBatchIteration)arg1) -> int open_as_batch_group(...) (builtin) \u2014 open_as_batch_group( (PyBatchIteration)arg1 [, (bool)confirm=True]) -> bool : class PyBrowser This class represents the file browser. Methods show(...) (builtin) \u2014 show( (PyBrowser)arg1, (str)default_path [, (object)extension='' [, (bool)select_directory=False [, (bool)multi_selection=False [, (object)include_resolution=False [, (str)title='Load']]]]]) -> None : selection(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object sequence_mode(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> bool width(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object height(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object scaling_presets_value(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object bit_depth(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object frame_ratio(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object scan_mode(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> str colour_space(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> str resize_mode(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> str resize_filter(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> str resolution(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> str class PyClip CLass derived from PyArchiveEntry. This class represents a Clip. Methods frame_rate(...) (property) \u2014 None( (flame.PyClip)arg1) -> object duration(...) (property) \u2014 None( (flame.PyClip)arg1) -> object versions(...) (property) \u2014 None( (flame.PyClip)arg1) -> list audio_tracks(...) (property) \u2014 None( (flame.PyClip)arg1) -> list markers(...) (property) \u2014 None( (flame.PyClip)arg1) -> list subtitles(...) (property) \u2014 None( (flame.PyClip)arg1) -> list width(...) (property) \u2014 None( (flame.PyClip)arg1) -> int height(...) (property) \u2014 None( (flame.PyClip)arg1) -> int bit_depth(...) (property) \u2014 None( (flame.PyClip)arg1) -> int ratio(...) (property) \u2014 None( (flame.PyClip)arg1) -> float scan_mode(...) (property) \u2014 None( (flame.PyClip)arg1) -> str colour_primaries(...) (property) \u2014 None( (flame.PyClip)arg1) -> int transfer_characteristics(...) (property) \u2014 None( (flame.PyClip)arg1) -> int matrix_coefficients(...) (property) \u2014 None( (flame.PyClip)arg1) -> int proxy_resolution(...) (property) \u2014 None( (flame.PyClip)arg1) -> object has_deliverables(...) (property) \u2014 None( (flame.PyClip)arg1) -> bool has_history(...) (property) \u2014 None( (flame.PyClip)arg1) -> bool unlinked(...) (property) \u2014 None( (flame.PyClip)arg1) -> str creation_date(...) (property) \u2014 None( (flame.PyClip)arg1) -> str archive_date(...) (property) \u2014 None( (flame.PyClip)arg1) -> str archive_error(...) (property) \u2014 None( (flame.PyClip)arg1) -> str essence_uid(...) (property) \u2014 None( (flame.PyClip)arg1) -> str source_uid(...) (property) \u2014 None( (flame.PyClip)arg1) -> str original_source_uid(...) (property) \u2014 None( (flame.PyClip)arg1) -> str sample_rate(...) (property) \u2014 None( (flame.PyClip)arg1) -> str cached(...) (property) \u2014 None( (flame.PyClip)arg1) -> str start_frame(...) (property) \u2014 None( (flame.PyClip)arg1) -> int open_as_sequence(...) (builtin) \u2014 open_as_sequence( (PyClip)arg1) -> object : open_container(...) (builtin) \u2014 open_container( (PyClip)arg1) -> bool : close_container(...) (builtin) \u2014 close_container( (PyClip)arg1) -> None : reformat(...) (builtin) \u2014 reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None : create_marker(...) (builtin) \u2014 create_marker( (PyClip)arg1, (object)location) -> object : change_dominance(...) (builtin) \u2014 change_dominance( (PyClip)arg1, (str)scan_mode) -> None : cache_media(...) (builtin) \u2014 cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : flush_cache_media(...) (builtin) \u2014 flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : clear_cache_media(...) (builtin) \u2014 clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : render(...) (builtin) \u2014 render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool : flush_renders(...) (builtin) \u2014 flush_renders( (PyClip)arg1) -> None : clear_renders(...) (builtin) \u2014 clear_renders( (PyClip)arg1) -> None : is_rendered(...) (builtin) \u2014 is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool : save(...) (builtin) \u2014 save( (PyClip)arg1) -> bool : cut(...) (builtin) \u2014 cut( (PyClip)arg1, (PyTime)cut_time) -> None : get_colour_space(...) (builtin) \u2014 get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str : change_start_frame(...) (builtin) \u2014 change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : get_metadata(...) (builtin) \u2014 get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : class PyClipNode Class derived from PyNode. This class represents a Clip node. Methods clip(...) (property) \u2014 None( (flame.PyClipNode)arg1) -> object version_uids(...) (property) \u2014 None( (flame.PyClipNode)arg1) -> list version_uid(...) (property) \u2014 None( (flame.PyClipNode)arg1) -> object set_version_uid(...) (builtin) \u2014 set_version_uid( (PyClipNode)arg1, (str)version_uid) -> bool : set_metadata_value(...) (builtin) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : set_metadata_discarded(...) (builtin) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_key(...) (builtin) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : class PyClrMgmtNode Object representing a Colour Mgmt node. Methods set_context_variable(...) (builtin) \u2014 set_context_variable( (PyClrMgmtNode)arg1, (str)name, (str)value) -> None : get_context_variables(...) (builtin) \u2014 get_context_variables( (PyClrMgmtNode)arg1) -> dict : reset_context_variables(...) (builtin) \u2014 reset_context_variables( (PyClrMgmtNode)arg1) -> None : import_transform(...) (builtin) \u2014 import_transform( (PyClrMgmtNode)arg1, (str)file_path) -> None : class PyCoCameraAnalysis Class derived from PyCoNode. This class represents the camera analysis node in the Action schematic. Methods resetAnalysis(...) (builtin) \u2014 resetAnalysis( (PyCoCameraAnalysis)arg1) -> bool : analyseRange(...) (builtin) \u2014 analyseRange( (PyCoCameraAnalysis)arg1, (object)arg2, (object)start) -> bool : class PyCoCompass Class derived from PyCoNode. This class represents the compass node in the Action schematic. Methods nodes(...) (property) \u2014 None( (flame.PyCoCompass)arg1) -> list class PyCoNode Class derived from PyFlameObject. This class represents an Action node in the Action schematic. Methods assign_media(...) (builtin) \u2014 assign_media( (PyCoNode)arg1, (object)media_name) -> bool : cache_range(...) (builtin) \u2014 cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : add_reference(...) (builtin) \u2014 add_reference( (PyCoNode)arg1, (object)frame) -> bool : parents(...) (builtin) \u2014 parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : children(...) (builtin) \u2014 children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : type(...) (property) \u2014 None( (flame.PyCoNode)arg1) -> str class PyColourMgtTimelineFX Object representing a Colour Mgmt Timeline FX. Methods set_context_variable(...) (builtin) \u2014 set_context_variable( (PyColourMgtTimelineFX)arg1, (str)name, (str)value) -> None : get_context_variables(...) (builtin) \u2014 get_context_variables( (PyColourMgtTimelineFX)arg1) -> dict : import_transform(...) (builtin) \u2014 import_transform( (PyColourMgtTimelineFX)arg1, (str)file_path) -> None : reset_context_variables(...) (builtin) \u2014 reset_context_variables( (PyColourMgtTimelineFX)arg1) -> None : class PyCompassNode Class derived from PyNode. This class represents a Compass node. Methods nodes(...) (property) \u2014 None( (flame.PyCompassNode)arg1) -> list class PyDesktop Class derived from PyArchiveEntry. This class represents a Desktop. Methods children(...) (property) \u2014 None( (flame.PyDesktop)arg1) -> list batch_groups(...) (property) \u2014 None( (flame.PyDesktop)arg1) -> list reel_groups(...) (property) \u2014 None( (flame.PyDesktop)arg1) -> list create_reel_group(...) (builtin) \u2014 create_reel_group( (PyDesktop)arg1, (str)name) -> object : save(...) (builtin) \u2014 save( (PyDesktop)arg1) -> bool : create_batch_group(...) (builtin) \u2014 create_batch_group( (PyDesktop)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : clear(...) (builtin) \u2014 clear( (PyDesktop)arg1) -> bool : class PyExporter Object holding export settings. Methods use_top_video_track(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool export_between_marks(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool foreground(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool include_subtitles(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool export_subtitles_as_files(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool export_all_subtitles(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_unlinked(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_unrendered(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_pending_render(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_no_media(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_mixed_colour_space(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_reimport_unsupported(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool keep_timeline_fx_renders(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool get_presets_base_dir(...) (staticmethod) \u2014 get_presets_base_dir( (PyExporter.PresetVisibility)preset_visibility) -> str : get_presets_dir(...) (staticmethod) \u2014 get_presets_dir( (PyExporter.PresetVisibility)preset_visibility, (PyExporter.PresetType)preset_type) -> str : export(...) (builtin) \u2014 export( (PyExporter)arg1, (object)sources, (str)preset_path, (str)output_directory [, (PyExporter.BackgroundJobSettings)background_job_settings=None [, (object)hooks=None [, (object)hooks_user_data=None]]]) -> None : BackgroundJobSettings(...) (callable) \u2014 Object holding background export job settings. These settings refer to the Backburner job, server and manager. PresetType(...) (callable) \u2014 int([x]) -> integer Image_Sequence(...) (attribute) \u2014 Audio(...) (attribute) \u2014 Movie(...) (attribute) \u2014 Sequence_Publish(...) (attribute) \u2014 Distribution_Package(...) (attribute) \u2014 PresetVisibility(...) (callable) \u2014 int([x]) -> integer User(...) (attribute) \u2014 Project(...) (attribute) \u2014 Shared(...) (attribute) \u2014 Autodesk(...) (attribute) \u2014 Flow_Production_Tracking(...) (attribute) \u2014 Shotgun(...) (attribute) \u2014 class PyFlameObject The basic type of all accessible Flame objects from the python API. Methods attributes(...) (property) \u2014 None( (flame.PyFlameObject)arg1) -> list parent(...) (property) \u2014 None( (flame.PyFlameObject)arg1) -> object class PyFolder Class derived from PyArchiveEntry. This class represents a Folder. Methods children(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list folders(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list batch_iterations(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list desktops(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list reel_groups(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list reels(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list sequences(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list clips(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list batch_groups(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list clear(...) (builtin) \u2014 clear( (PyFolder)arg1 [, (bool)confirm=True]) -> bool : create_reel_group(...) (builtin) \u2014 create_reel_group( (PyFolder)arg1, (str)name) -> object : create_reel(...) (builtin) \u2014 create_reel( (PyFolder)arg1, (str)name) -> object : create_folder(...) (builtin) \u2014 create_folder( (PyFolder)arg1, (str)name) -> object : create_sequence(...) (builtin) \u2014 create_sequence( (PyFolder)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : class PyGMaskTracerNode Class derived from PyActionFamilyNode. Represents a GMask Tracer node object. Methods import_fbx(...) (builtin) \u2014 import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : export_fbx(...) (builtin) \u2014 export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : read_fbx(...) (builtin) \u2014 read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : import_abc(...) (builtin) \u2014 import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : read_abc(...) (builtin) \u2014 read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : import_psd(...) (builtin) \u2014 import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : enable_output(...) (builtin) \u2014 enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : disable_output(...) (builtin) \u2014 disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : output_types(...) (property) \u2014 None( (flame.PyGMaskTracerNode)arg1) -> list class PyHDRNode Object representing a HDR node. Methods analysis_status(...) (property) \u2014 None( (flame.PyHDRNode)arg1) -> object analyze(...) (builtin) \u2014 analyze( (PyHDRNode)arg1 [, (str)analyze_mode='Current Shot']) -> None : keep_analysis(...) (builtin) \u2014 keep_analysis( (PyHDRNode)arg1) -> None : reset_analysis(...) (builtin) \u2014 reset_analysis( (PyHDRNode)arg1) -> None : interpolate_trims(...) (builtin) \u2014 interpolate_trims( (PyHDRNode)arg1) -> None : reset_trims(...) (builtin) \u2014 reset_trims( (PyHDRNode)arg1) -> None : export_DolbyVision_xml(...) (builtin) \u2014 export_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)comment='']) -> None : import_DolbyVision_xml(...) (builtin) \u2014 import_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : mastering_display_ids(...) (property) \u2014 None( (flame.PyHDRNode)arg1) -> list target_display_ids(...) (property) \u2014 None( (flame.PyHDRNode)arg1) -> list mastering_display_info(...) (property) \u2014 None( (flame.PyHDRNode)arg1) -> object target_display_info(...) (property) \u2014 None( (flame.PyHDRNode)arg1) -> object has_trim(...) (builtin) \u2014 has_trim( (PyHDRNode)arg1, (int)target_display_id) -> bool : l2_from_l8(...) (builtin) \u2014 l2_from_l8( (PyHDRNode)arg1) -> object : class PyHDRTimelineFX Object representing a HDR Timeline FX. Methods analysis_status(...) (property) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object analyze(...) (builtin) \u2014 analyze( (PyHDRTimelineFX)arg1 [, (str)analyze_mode='Current Shot']) -> None : keep_analysis(...) (builtin) \u2014 keep_analysis( (PyHDRTimelineFX)arg1) -> None : reset_analysis(...) (builtin) \u2014 reset_analysis( (PyHDRTimelineFX)arg1) -> None : interpolate_trims(...) (builtin) \u2014 interpolate_trims( (PyHDRTimelineFX)arg1, (str)arg2) -> None : reset_trims(...) (builtin) \u2014 reset_trims( (PyHDRTimelineFX)arg1) -> None : export_DolbyVision_xml(...) (builtin) \u2014 export_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (bool)shot_only=False [, (str)comment='']]) -> None : import_DolbyVision_xml(...) (builtin) \u2014 import_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : mastering_display_ids(...) (property) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> list target_display_ids(...) (property) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> list mastering_display_info(...) (property) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object target_display_info(...) (property) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object has_trim(...) (builtin) \u2014 has_trim( (PyHDRTimelineFX)arg1, (int)target_display_id) -> bool : l2_from_l8(...) (builtin) \u2014 l2_from_l8( (PyHDRTimelineFX)arg1) -> object : class PyImageNode Class derived from PyActionFamilyNode. Represents an Image node object. Methods media_nodes(...) (property) \u2014 None( (flame.PyImageNode)arg1) -> list add_media(...) (builtin) \u2014 add_media( (PyActionFamilyNode)arg1) -> object : class PyLensDistortionNode Object representing a Lens Distortion node. Methods import_lens_distortion(...) (builtin) \u2014 import_lens_distortion( (PyLensDistortionNode)arg1, (str)filename) -> None : calculate(...) (builtin) \u2014 calculate( (PyLensDistortionNode)arg1) -> None : class PyLibrary Class derived from PyArchiveEntry. This class represents a Library. Methods children(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list folders(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list batch_iterations(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list desktops(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list reel_groups(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list reels(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list sequences(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list clips(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list batch_groups(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list opened(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> bool open(...) (builtin) \u2014 open( (PyLibrary)arg1) -> bool : close(...) (builtin) \u2014 close( (PyLibrary)arg1) -> bool : clear(...) (builtin) \u2014 clear( (PyLibrary)arg1 [, (bool)confirm=True]) -> bool : acquire_exclusive_access(...) (builtin) \u2014 acquire_exclusive_access( (PyLibrary)arg1) -> bool : release_exclusive_access(...) (builtin) \u2014 release_exclusive_access( (PyLibrary)arg1) -> bool : create_reel_group(...) (builtin) \u2014 create_reel_group( (PyLibrary)arg1, (str)name) -> object : create_reel(...) (builtin) \u2014 create_reel( (PyLibrary)arg1, (str)name) -> object : create_folder(...) (builtin) \u2014 create_folder( (PyLibrary)arg1, (str)name) -> object : create_sequence(...) (builtin) \u2014 create_sequence( (PyLibrary)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : class PyMarker Object representing a Marker. Methods has_annotations(...) (property) \u2014 None( (flame.PyMarker)arg1) -> bool clear_annotations(...) (builtin) \u2014 clear_annotations( (PyMarker)arg1) -> None : sync_connected_segments(...) (builtin) \u2014 sync_connected_segments( (PyMarker)arg1) -> None : class PyMediaHub This class represents the MediaHub. Methods files(...) (property) \u2014 None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubFilesTab archives(...) (property) \u2014 None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubTab class PyMediaHubFilesEntry Object representing a clip in the MediaHub Files tabs Methods path(...) (property) \u2014 None( (flame.PyMediaHubFilesEntry)arg1) -> str class PyMediaHubFilesFolder Object representing a folder in the MediaHub Files tabs Methods path(...) (property) \u2014 None( (flame.PyMediaHubFilesFolder)arg1) -> str class PyMediaHubFilesTab This class represents the MediaHub Files tab. Methods options(...) (property) \u2014 None( (flame.PyMediaHubFilesTab)arg1) -> flame.PyMediaHubFilesTabOptions class PyMediaHubFilesTabOptions This class represents the MediaHub Files tab options. Methods multi_channel_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str sequence_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool cache_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool proxies_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool cache_and_proxies_all_versions(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool resize_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str resize_filter(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str resolution(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str width(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object height(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object scaling_presets_value(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object frame_ratio(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object bit_depth(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object scan_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str pixel_ratio(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object colour_mgmt_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_view(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str tagged_colour_space(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_display(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_working_space(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_invert(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool import_transform(...) (builtin) \u2014 import_transform( (PyMediaHubFilesTabOptions)arg1, (str)file_path) -> None : set_tagged_colour_space(...) (builtin) \u2014 set_tagged_colour_space( (PyMediaHubFilesTabOptions)arg1, (str)colour_space) -> None : class PyMediaHubProjectsEntry Object representing a clip in the MediaHub Projects tabs Methods uid(...) (property) \u2014 None( (flame.PyMediaHubProjectsEntry)arg1) -> str path(...) (property) \u2014 None( (flame.PyMediaHubProjectsEntry)arg1) -> str class PyMediaHubProjectsFolder Object representing a folder in the MediaHub Projects tabs Methods uid(...) (property) \u2014 None( (flame.PyMediaHubProjectsFolder)arg1) -> str path(...) (property) \u2014 None( (flame.PyMediaHubProjectsFolder)arg1) -> str class PyMediaHubTab This class represents a MediaHub tab. Methods get_path(...) (builtin) \u2014 get_path( (PyMediaHubTab)arg1) -> str : set_path(...) (builtin) \u2014 set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool : class PyMediaPanel This class represents the media panel. Methods selected_entries(...) (property) \u2014 None( (flame.PyMediaPanel)arg1) -> object visible(...) (property) \u2014 None( (flame.PyMediaPanel)arg1) -> bool full_height(...) (property) \u2014 None( (flame.PyMediaPanel)arg1) -> bool full_width(...) (property) \u2014 None( (flame.PyMediaPanel)arg1) -> bool dual(...) (property) \u2014 None( (flame.PyMediaPanel)arg1) -> bool move(...) (builtin) \u2014 move( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : copy(...) (builtin) \u2014 copy( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : class PyMessages Module handling message bar in application UI. Methods show_in_console(...) (builtin) \u2014 show_in_console( (PyMessages)arg1, (str)message [, (str)type='info' [, (int)duration=-1]]) -> None : clear_console(...) (builtin) \u2014 clear_console( (PyMessages)arg1) -> None : show_in_dialog(...) (builtin) \u2014 show_in_dialog( (PyMessages)arg1, (str)title, (str)message, (str)type, (list)buttons [, (str)cancel_button='']) -> str : class PyMetadataNode Class derived from PyNode. This class represents a Metadata node. Methods set_metadata_value(...) (builtin) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : set_metadata_discarded(...) (builtin) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_key(...) (builtin) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : load_node_setup(...) (builtin) \u2014 load_node_setup( (PyMetadataNode)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)replaced_keys=True [, (bool)update_tokens=True]]]]]) -> bool : class PyMetadataTimelineFX Object representing a Metadata Timeline FX. Methods get_metadata(...) (builtin) \u2014 get_metadata( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (int)frame=1]]) -> object : set_metadata_value(...) (builtin) \u2014 set_metadata_value( (PyMetadataTimelineFX)arg1, (str)key [, (object)value=None]) -> None : set_metadata_discarded(...) (builtin) \u2014 set_metadata_discarded( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (bool)discarded=True]]) -> None : set_metadata_key(...) (builtin) \u2014 set_metadata_key( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (object)name=None]]) -> None : load_setup(...) (builtin) \u2014 load_setup( (PyMetadataTimelineFX)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)update_tokens=True]]]]) -> bool : class PyMetadataValue This class holds the metadata of a specific data type. Methods get_value(...) (builtin) \u2014 get_value( (PyMetadataValue)arg1) -> object : set_value(...) (builtin) \u2014 set_value( (PyMetadataValue)arg1, (object)value) -> None : type(...) (property) \u2014 None( (flame.PyMetadataValue)arg1) -> str class PyMorphNode Object representing a Morph node. Methods set_mix_to_range(...) (builtin) \u2014 set_mix_to_range( (PyMorphNode)arg1) -> None : class PyNode Object representing a Node. Methods sockets(...) (property) \u2014 None( (flame.PyNode)arg1) -> dict input_sockets(...) (property) \u2014 None( (flame.PyNode)arg1) -> list output_sockets(...) (property) \u2014 None( (flame.PyNode)arg1) -> list load_node_setup(...) (builtin) \u2014 load_node_setup( (PyNode)arg1, (str)file_name) -> bool : save_node_setup(...) (builtin) \u2014 save_node_setup( (PyNode)arg1, (str)file_name) -> bool : delete(...) (builtin) \u2014 delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : duplicate(...) (builtin) \u2014 duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : set_context(...) (builtin) \u2014 set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : clear_schematic_colour(...) (builtin) \u2014 clear_schematic_colour( (PyNode)arg1) -> None : get_metadata(...) (builtin) \u2014 get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : cache_range(...) (builtin) \u2014 cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : output_channel_as_metadata_key(...) (builtin) \u2014 output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : class PyOFXNode Object representing a OpenFX node. Methods change_plugin(...) (builtin) \u2014 change_plugin( (PyOFXNode)arg1, (str)plugin_name) -> bool : class PyPaintNode Object representing a Paint node. Methods add_source(...) (builtin) \u2014 add_source( (PyPaintNode)arg1) -> object : class PyProject Object representing a Project. Methods name(...) (property) \u2014 None( (flame.PyProject)arg1) -> str nickname(...) (property) \u2014 None( (flame.PyProject)arg1) -> str description(...) (property) \u2014 None( (flame.PyProject)arg1) -> str project_name(...) (property) \u2014 None( (flame.PyProject)arg1) -> str workspaces_count(...) (property) \u2014 None( (flame.PyProject)arg1) -> int current_workspace(...) (property) \u2014 None( (flame.PyProject)arg1) -> object shared_libraries(...) (property) \u2014 None( (flame.PyProject)arg1) -> list project_folder(...) (property) \u2014 None( (flame.PyProject)arg1) -> str setups_folder(...) (property) \u2014 None( (flame.PyProject)arg1) -> str media_folder(...) (property) \u2014 None( (flame.PyProject)arg1) -> str create_shared_library(...) (builtin) \u2014 create_shared_library( (PyProject)arg1, (str)name) -> object : refresh_shared_libraries(...) (builtin) \u2014 refresh_shared_libraries( (PyProject)arg1) -> bool : reload_ocio_config(...) (builtin) \u2014 reload_ocio_config( (PyProject)arg1 [, (bool)reset_colour_policy=False]) -> bool : export_ocio_config(...) (builtin) \u2014 export_ocio_config( (PyProject)arg1, (str)config_name [, (str)destination_folder='' [, (bool)overwrite_existing=False [, (bool)export_as_locked=False [, (bool)generate_ocioz=False]]]]) -> bool : set_context_variable(...) (builtin) \u2014 set_context_variable( (PyProject)arg1, (str)name, (str)value) -> None : get_context_variables(...) (builtin) \u2014 get_context_variables( (PyProject)arg1) -> dict : reset_context_variables(...) (builtin) \u2014 reset_context_variables( (PyProject)arg1) -> None : class PyProjectSelector Object representing the Project manager. Methods current_project(...) (property) \u2014 None( (flame.PyProjectSelector)arg1) -> object class PyReadFileNode Class derived from PyNode. This class represents a ReadFile node. class PyReel Object representing a Reel. Methods children(...) (property) \u2014 None( (flame.PyReel)arg1) -> list sequences(...) (property) \u2014 None( (flame.PyReel)arg1) -> list clips(...) (property) \u2014 None( (flame.PyReel)arg1) -> list type(...) (property) \u2014 None( (flame.PyReel)arg1) -> object clear(...) (builtin) \u2014 clear( (PyReel)arg1 [, (bool)confirm=True]) -> bool : create_sequence(...) (builtin) \u2014 create_sequence( (PyReel)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : save(...) (builtin) \u2014 save( (PyReel)arg1) -> bool : class PyReelGroup Object representing a Reel Group. Methods children(...) (property) \u2014 None( (flame.PyReelGroup)arg1) -> list reels(...) (property) \u2014 None( (flame.PyReelGroup)arg1) -> list clear(...) (builtin) \u2014 clear( (PyReelGroup)arg1 [, (bool)confirm=True]) -> bool : create_reel(...) (builtin) \u2014 create_reel( (PyReelGroup)arg1, (str)name [, (bool)sequence=False]) -> object : save(...) (builtin) \u2014 save( (PyReelGroup)arg1) -> bool : class PyRenderNode Class derived from PyNode. This class represents a Render node. Methods channels(...) (property) \u2014 None( (flame.PyRenderNode)arg1) -> list set_channel_name(...) (builtin) \u2014 set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None : set_metadata_value(...) (builtin) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None : set_metadata_discarded(...) (builtin) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_key(...) (builtin) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : class PyResolution Object representing a resolution Methods resolution(...) (property) \u2014 None( (flame.PyResolution)arg1) -> str width(...) (property) \u2014 None( (flame.PyResolution)arg1) -> int height(...) (property) \u2014 None( (flame.PyResolution)arg1) -> int frame_ratio(...) (property) \u2014 None( (flame.PyResolution)arg1) -> float scan_mode(...) (property) \u2014 None( (flame.PyResolution)arg1) -> str bit_depth(...) (property) \u2014 None( (flame.PyResolution)arg1) -> int class PySearch This class represents the search. Methods use_weight(...) (property) \u2014 None( (flame.PySearch)arg1) -> bool set_tool_favorite(...) (builtin) \u2014 set_tool_favorite( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : set_tool_hidden(...) (builtin) \u2014 set_tool_hidden( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : set_tool_weight(...) (builtin) \u2014 set_tool_weight( (PySearch)arg1, (str)arg2, (str)name, (int)type) -> None : search_results(...) (builtin) \u2014 search_results( (PySearch)arg1 [, (str)search_str='*' [, (str)tab='Tools']]) -> list : activate_search_result(...) (builtin) \u2014 activate_search_result( (PySearch)arg1, (str)name, (str)type [, (str)tab='Tools']) -> None : class PySegment Object representing a Segment. Methods source_name(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_in(...) (property) \u2014 None( (flame.PySegment)arg1) -> object source_out(...) (property) \u2014 None( (flame.PySegment)arg1) -> object source_duration(...) (property) \u2014 None( (flame.PySegment)arg1) -> object source_width(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_height(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_bit_depth(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_ratio(...) (property) \u2014 None( (flame.PySegment)arg1) -> float source_scan_mode(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_frame_rate(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_cached(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_has_history(...) (property) \u2014 None( (flame.PySegment)arg1) -> bool source_unlinked(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_sample_rate(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_audio_track(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_essence_uid(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_uid(...) (property) \u2014 None( (flame.PySegment)arg1) -> str original_source_uid(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_colour_primaries(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_transfer_characteristics(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_matrix_coefficients(...) (property) \u2014 None( (flame.PySegment)arg1) -> int tape_name(...) (property) \u2014 None( (flame.PySegment)arg1) -> str record_in(...) (property) \u2014 None( (flame.PySegment)arg1) -> object record_out(...) (property) \u2014 None( (flame.PySegment)arg1) -> object record_duration(...) (property) \u2014 None( (flame.PySegment)arg1) -> object start_frame(...) (property) \u2014 None( (flame.PySegment)arg1) -> int file_path(...) (property) \u2014 None( (flame.PySegment)arg1) -> str markers(...) (property) \u2014 None( (flame.PySegment)arg1) -> list effect_types(...) (property) \u2014 None( (flame.PySegment)arg1) -> list effects(...) (property) \u2014 None( (flame.PySegment)arg1) -> list groups(...) (property) \u2014 None( (flame.PySegment)arg1) -> list type(...) (property) \u2014 None( (flame.PySegment)arg1) -> str head(...) (property) \u2014 None( (flame.PySegment)arg1) -> object tail(...) (property) \u2014 None( (flame.PySegment)arg1) -> object rgb_channel(...) (property) \u2014 None( (flame.PySegment)arg1) -> str matte_channel(...) (property) \u2014 None( (flame.PySegment)arg1) -> str rgb_channels(...) (property) \u2014 None( (flame.PySegment)arg1) -> list matte_channels(...) (property) \u2014 None( (flame.PySegment)arg1) -> list version_uid(...) (property) \u2014 None( (flame.PySegment)arg1) -> str version_uids(...) (property) \u2014 None( (flame.PySegment)arg1) -> list matte_mode(...) (property) \u2014 None( (flame.PySegment)arg1) -> str container_clip(...) (property) \u2014 None( (flame.PySegment)arg1) -> object create_effect(...) (builtin) \u2014 create_effect( (PySegment)arg1, (str)effect_type [, (str)after_effect_type='']) -> object : create_marker(...) (builtin) \u2014 create_marker( (PySegment)arg1, (object)location) -> object : create_connection(...) (builtin) \u2014 create_connection( (PySegment)arg1) -> None : remove_connection(...) (builtin) \u2014 remove_connection( (PySegment)arg1) -> None : sync_connected_segments(...) (builtin) \u2014 sync_connected_segments( (PySegment)arg1) -> None : connected_segments(...) (builtin) \u2014 connected_segments( (PySegment)arg1 [, (str)scoping='all reels']) -> object : duplicate_source(...) (builtin) \u2014 duplicate_source( (PySegment)arg1) -> None : shared_source_segments(...) (builtin) \u2014 shared_source_segments( (PySegment)arg1) -> object : copy_to_media_panel(...) (builtin) \u2014 copy_to_media_panel( (PySegment)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : trim_head(...) (builtin) \u2014 trim_head( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : trim_tail(...) (builtin) \u2014 trim_tail( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : slip(...) (builtin) \u2014 slip( (PySegment)arg1, (int)offset [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]) -> bool : slide_keyframes(...) (builtin) \u2014 slide_keyframes( (PySegment)arg1, (int)offset [, (bool)sync=False]) -> bool : set_gap_colour(...) (builtin) \u2014 set_gap_colour( (PySegment)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : set_gap_bars(...) (builtin) \u2014 set_gap_bars( (PySegment)arg1 [, (str)type='smpte' [, (bool)full_luminance=False [, (float)softness=0.0]]]) -> object : smart_replace(...) (builtin) \u2014 smart_replace( (PySegment)arg1, (PyClip)source_clip) -> None : smart_replace_media(...) (builtin) \u2014 smart_replace_media( (PySegment)arg1, (PyClip)source_clip) -> None : match(...) (builtin) \u2014 match( (PySegment)arg1, (PyArchiveEntry)destination [, (bool)preserve_handle=False [, (bool)use_sequence_info=True [, (bool)include_nested_content=False [, (bool)include_timeline_fx=False]]]]) -> object : clear_colour(...) (builtin) \u2014 clear_colour( (PySegment)arg1) -> None : set_rgb_channel(...) (builtin) \u2014 set_rgb_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences']]]) -> bool : set_matte_channel(...) (builtin) \u2014 set_matte_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences' [, (str)matte_mode='Custom Matte']]]]) -> bool : set_version_uid(...) (builtin) \u2014 set_version_uid( (PySegment)arg1, (str)version_uid [, (str)scope='Follow Source Sharing']) -> bool : get_colour_space(...) (builtin) \u2014 get_colour_space( (PySegment)arg1 [, (PyTime)time=None]) -> str : create_unlinked_segment(...) (builtin) \u2014 create_unlinked_segment( (PySegment)arg1 [, (str)source_name='' [, (str)tape_name='' [, (object)start_time=0 [, (object)source_duration=0 [, (object)head=0 [, (str)file_path='' [, (int)source_audio_track=1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='Same As Sequence' [, (str)frame_rate='Same As Sequence' [, (object)timewarp_speed=None]]]]]]]]]]]]]]) -> None : change_start_frame(...) (builtin) \u2014 change_start_frame( (PySegment)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : get_metadata(...) (builtin) \u2014 get_metadata( (PySegment)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : class PySequence Object representing a Sequence. Methods open(...) (builtin) \u2014 open( (PySequence)arg1) -> bool : create_container(...) (builtin) \u2014 create_container( (PySequence)arg1) -> object : create_version(...) (builtin) \u2014 create_version( (PySequence)arg1 [, (bool)stereo=False]) -> object : create_audio(...) (builtin) \u2014 create_audio( (PySequence)arg1 [, (bool)stereo=False]) -> object : create_subtitle(...) (builtin) \u2014 create_subtitle( (PySequence)arg1) -> object : import_subtitles_file(...) (builtin) \u2014 import_subtitles_file( (PySequence)arg1, (str)file_name [, (object)file_type=None [, (bool)align_first_event_to_clip_start=False [, (object)convert_from_frame_rate=None]]]) -> object : create_group(...) (builtin) \u2014 create_group( (PySequence)arg1, (str)name) -> object : insert(...) (builtin) \u2014 insert( (PySequence)arg1, (PyClip)source_clip [, (PyTime)insert_time=None [, (PyTrack)destination_track=None]]) -> bool : overwrite(...) (builtin) \u2014 overwrite( (PySequence)arg1, (PyClip)source_clip [, (PyTime)overwrite_time=None [, (PyTrack)destination_track=None]]) -> bool : copy_selection_to_media_panel(...) (builtin) \u2014 copy_selection_to_media_panel( (PySequence)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : extract_selection_to_media_panel(...) (builtin) \u2014 extract_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : lift_selection_to_media_panel(...) (builtin) \u2014 lift_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : groups(...) (property) \u2014 None( (flame.PySequence)arg1) -> list class PySequenceGroup Object representing a Group in a Sequence. Methods segments(...) (property) \u2014 None( (flame.PySequenceGroup)arg1) -> list add(...) (builtin) \u2014 add( (PySequenceGroup)arg1, (object)segments) -> None : remove(...) (builtin) \u2014 remove( (PySequenceGroup)arg1, (object)segments) -> None : class PySubtitleTrack Object representing a Subtitle Track. Methods export_as_srt_file(...) (builtin) \u2014 export_as_srt_file( (PySubtitleTrack)arg1, (str)file_name [, (bool)character_based_attributes=True [, (bool)export_colours=False [, (str)exclude_colour='' [, (bool)use_original_colours=False [, (bool)use_original_alignment=False [, (bool)export_alignments=False [, (str)alignment_type='an' [, (str)exclude_alignment='' [, (str)start_timecode='Same as Clip']]]]]]]]]) -> None : class PyTime Object representing a time unit Methods frame(...) (property) \u2014 None( (flame.PyTime)arg1) -> int relative_frame(...) (property) \u2014 None( (flame.PyTime)arg1) -> int timecode(...) (property) \u2014 None( (flame.PyTime)arg1) -> str frame_rate(...) (property) \u2014 None( (flame.PyTime)arg1) -> object class PyTimeline This class represents the Timeline. Methods clip(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> object current_segment(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> object current_marker(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> object current_effect(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> object current_transition(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> object type(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> str class PyTimelineFX Object representing a Timeline FX. Methods type(...) (property) \u2014 None( (flame.PyTimelineFX)arg1) -> object has_maps_cache_media(...) (property) \u2014 None( (flame.PyTimelineFX)arg1) -> bool load_setup(...) (builtin) \u2014 load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : save_setup(...) (builtin) \u2014 save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : flush_maps_cache_media(...) (builtin) \u2014 flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : clear_maps_cache_media(...) (builtin) \u2014 clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : sync_connected_segments(...) (builtin) \u2014 sync_connected_segments( (PyTimelineFX)arg1) -> None : slide_keyframes(...) (builtin) \u2014 slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : output_channel_as_metadata_key(...) (builtin) \u2014 output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : class PyTimewarpNode Object representing a Timewarp node. Methods get_speed(...) (builtin) \u2014 get_speed( (PyTimewarpNode)arg1, (float)frame) -> float : set_speed(...) (builtin) \u2014 set_speed( (PyTimewarpNode)arg1, (float)frame, (float)new_speed) -> None : set_timing(...) (builtin) \u2014 set_timing( (PyTimewarpNode)arg1, (float)frame, (float)new_timing) -> None : get_timing(...) (builtin) \u2014 get_timing( (PyTimewarpNode)arg1, (float)frame) -> float : get_duration_timing(...) (builtin) \u2014 get_duration_timing( (PyTimewarpNode)arg1, (float)frame) -> float : get_speed_timing(...) (builtin) \u2014 get_speed_timing( (PyTimewarpNode)arg1, (float)frame) -> float : class PyTimewarpTimelineFX Object representing a Timewarp node. Methods get_speed(...) (builtin) \u2014 get_speed( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : set_speed(...) (builtin) \u2014 set_speed( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_speed) -> None : set_timing(...) (builtin) \u2014 set_timing( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_timing) -> None : get_timing(...) (builtin) \u2014 get_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_duration_timing(...) (builtin) \u2014 get_duration_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_speed_timing(...) (builtin) \u2014 get_speed_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : class PyTrack Object representing a Track. Methods segments(...) (property) \u2014 None( (flame.PyTrack)arg1) -> list transitions(...) (property) \u2014 None( (flame.PyTrack)arg1) -> list copy_to_media_panel(...) (builtin) \u2014 copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : cut(...) (builtin) \u2014 cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None : insert_transition(...) (builtin) \u2014 insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object : class PyTransition Object representing a Transition. Methods type(...) (property) \u2014 None( (flame.PyTransition)arg1) -> str record_time(...) (property) \u2014 None( (flame.PyTransition)arg1) -> object in_offset(...) (property) \u2014 None( (flame.PyTransition)arg1) -> int set_transition(...) (builtin) \u2014 set_transition( (PyTransition)arg1, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0]]]) -> object : slide(...) (builtin) \u2014 slide( (PyTransition)arg1, (int)offset [, (bool)sync=False]) -> bool : set_dissolve_to_from_colour(...) (builtin) \u2014 set_dissolve_to_from_colour( (PyTransition)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : set_fade_to_from_silence(...) (builtin) \u2014 set_fade_to_from_silence( (PyTransition)arg1) -> None : class PyTypeFX Object representing a Type Timeline FX. Methods layers(...) (property) \u2014 None( (flame.PyTypeFX)arg1) -> list add_layer(...) (builtin) \u2014 add_layer( (PyTypeFX)arg1 [, (str)layer_type='Centre']) -> object : append_type_setup(...) (builtin) \u2014 append_type_setup( (PyTypeFX)arg1, (str)file_name) -> bool : class PyTypeLayer Object representing a Type Layer. Methods type(...) (property) \u2014 None( (flame.PyTypeLayer)arg1) -> object class PyTypeNode Object representing a Type node. Methods layers(...) (property) \u2014 None( (flame.PyTypeNode)arg1) -> list add_layer(...) (builtin) \u2014 add_layer( (PyTypeNode)arg1 [, (str)layer_type='Centre']) -> object : append_type_setup(...) (builtin) \u2014 append_type_setup( (PyTypeNode)arg1, (str)file_name) -> bool : class PyUser Object representing a User. Methods name(...) (property) \u2014 None( (flame.PyUser)arg1) -> str nickname(...) (property) \u2014 None( (flame.PyUser)arg1) -> str shortcuts_profile(...) (property) \u2014 None( (flame.PyUser)arg1) -> str class PyUsers Object representing the User manager. Methods current_user(...) (property) \u2014 None( (flame.PyUsers)arg1) -> object class PyVersion Object representing a Version. Methods tracks(...) (property) \u2014 None( (flame.PyVersion)arg1) -> list stereo(...) (property) \u2014 None( (flame.PyVersion)arg1) -> bool copy_to_media_panel(...) (builtin) \u2014 copy_to_media_panel( (PyVersion)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : create_track(...) (builtin) \u2014 create_track( (PyVersion)arg1 [, (int)track_index=-1 [, (bool)hdr=False]]) -> object : import_DolbyVision_xml(...) (builtin) \u2014 import_DolbyVision_xml( (PyVersion)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)track_index=-1]]) -> object : class PyWorkspace Object representing a Workspace. Methods desktop(...) (property) \u2014 None( (flame.PyWorkspace)arg1) -> object libraries(...) (property) \u2014 None( (flame.PyWorkspace)arg1) -> list create_library(...) (builtin) \u2014 create_library( (PyWorkspace)arg1, (str)name) -> object : replace_desktop(...) (builtin) \u2014 replace_desktop( (PyWorkspace)arg1, (PyDesktop)desktop) -> bool : set_desktop_reels(...) (builtin) \u2014 set_desktop_reels( (PyWorkspace)arg1 [, (object)group=None]) -> bool : set_freeform(...) (builtin) \u2014 set_freeform( (PyWorkspace)arg1 [, (object)reel=None]) -> bool : class PyWriteFileNode Class derived from PyRenderNode. This class represents a WriteFile node. Methods get_resolved_media_path(...) (builtin) \u2014 get_resolved_media_path( (PyWriteFileNode)arg1 [, (bool)show_extension=True [, (bool)translate_path=True [, (object)frame=None]]]) -> object : Functions clear_graphics_memory \u2014 clear_graphics_memory(...) \u2014 clear_graphics_memory() -> None : clear_unreferenced_cache \u2014 clear_unreferenced_cache(...) \u2014 clear_unreferenced_cache([ (bool)all_projects=False]) -> None : delete \u2014 delete(...) \u2014 delete( (PyFlameObject)object [, (bool)confirm=True]) -> bool : duplicate \u2014 duplicate(...) \u2014 duplicate( (PyFlameObject)object [, (bool)keep_node_connections=False]) -> object : duplicate_many \u2014 duplicate_many(...) \u2014 duplicate_many( (list)object_list [, (bool)keep_node_connections=False]) -> list : execute_command \u2014 execute_command(...) \u2014 execute_command( (str)command [, (bool)blocking=True [, (bool)shell=False [, (bool)capture_stdout=False [, (bool)capture_stderr=False]]]]) -> tuple : execute_shortcut \u2014 execute_shortcut(...) \u2014 execute_shortcut( (str)description [, (bool)update_list=True]) -> bool : exit \u2014 exit(...) \u2014 exit() -> None : find_by_name \u2014 find_by_name(...) \u2014 find_by_name( (str)name [, (object)parent=None]) -> list : find_by_uid \u2014 find_by_uid(...) \u2014 find_by_uid( (str)uid) -> object : find_by_wiretap_node_id \u2014 find_by_wiretap_node_id(...) \u2014 find_by_wiretap_node_id( (str)node_id) -> object : flush_graphics_memory \u2014 flush_graphics_memory(...) \u2014 flush_graphics_memory() -> None : get_current_tab \u2014 get_current_tab(...) \u2014 get_current_tab() -> str : get_home_directory \u2014 get_home_directory(...) \u2014 get_home_directory() -> str : get_init_cfg_path \u2014 get_init_cfg_path(...) \u2014 get_init_cfg_path() -> str : get_version \u2014 get_version(...) \u2014 get_version() -> str : get_version_major \u2014 get_version_major(...) \u2014 get_version_major() -> str : get_version_minor \u2014 get_version_minor(...) \u2014 get_version_minor() -> str : get_version_patch \u2014 get_version_patch(...) \u2014 get_version_patch() -> str : get_version_stamp \u2014 get_version_stamp(...) \u2014 get_version_stamp() -> str : go_to \u2014 go_to(...) \u2014 go_to( (str)tab) -> bool : import_clips \u2014 import_clips(...) \u2014 import_clips( (object)path [, (object)destination=None]) -> list : schedule_idle_event \u2014 schedule_idle_event(...) \u2014 schedule_idle_event( (object)function [, (int)delay=0]) -> None : set_current_tab \u2014 set_current_tab(...) \u2014 set_current_tab( (str)arg1) -> bool : set_render_option \u2014 set_render_option(...) \u2014 set_render_option( (str)render_option [, (str)render_context='']) -> bool : Constants / Attributes batch browser media_panel mediahub messages project projects timeline users","title":"Module: flame"},{"location":"api/flame/#module-flame","text":"","title":"Module: flame"},{"location":"api/flame/#classes","text":"","title":"Classes"},{"location":"api/flame/#class-pyactionfamilynode","text":"Class derived from PyNode. Represents an Action Family node object.","title":"class PyActionFamilyNode"},{"location":"api/flame/#methods","text":"node_types(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list nodes(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list cursor_position(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> tuple all_tabs(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list left_tabs(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list right_tabs(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list create_node(...) (builtin) \u2014 create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : organize(...) (builtin) \u2014 organize( (PyActionFamilyNode)arg1) -> bool : get_node(...) (builtin) \u2014 get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : connect_nodes(...) (builtin) \u2014 connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : disconnect_nodes(...) (builtin) \u2014 disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : media_layers(...) (property) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list clear_schematic(...) (builtin) \u2014 clear_schematic( (PyActionFamilyNode)arg1) -> bool : encompass_nodes(...) (builtin) \u2014 encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object :","title":"Methods"},{"location":"api/flame/#class-pyactionnode","text":"Class derived from PyActionFamilyNode. Represents an Action node object.","title":"class PyActionNode"},{"location":"api/flame/#methods_1","text":"media_nodes(...) (property) \u2014 None( (flame.PyActionNode)arg1) -> list add_media(...) (builtin) \u2014 add_media( (PyActionFamilyNode)arg1) -> object : import_fbx(...) (builtin) \u2014 import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : export_fbx(...) (builtin) \u2014 export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : read_fbx(...) (builtin) \u2014 read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : import_abc(...) (builtin) \u2014 import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : read_abc(...) (builtin) \u2014 read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : import_psd(...) (builtin) \u2014 import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : enable_output(...) (builtin) \u2014 enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : disable_output(...) (builtin) \u2014 disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : output_types(...) (property) \u2014 None( (flame.PyActionNode)arg1) -> list","title":"Methods"},{"location":"api/flame/#class-pyarchiveentry","text":"Class derived from PyFlameObject. Base class for any object displayed in the Media Panel.","title":"class PyArchiveEntry"},{"location":"api/flame/#methods_2","text":"get_wiretap_storage_id(...) (builtin) \u2014 get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : get_wiretap_node_id(...) (builtin) \u2014 get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : commit(...) (builtin) \u2014 commit( (PyArchiveEntry)arg1) -> None : clear_colour(...) (builtin) \u2014 clear_colour( (PyArchiveEntry)arg1) -> None :","title":"Methods"},{"location":"api/flame/#class-pyattribute","text":"","title":"class PyAttribute"},{"location":"api/flame/#methods_3","text":"values(...) (property) \u2014 None( (flame.PyAttribute)arg1) -> object set_value(...) (builtin) \u2014 set_value( (PyAttribute)arg1, (object)arg2) -> bool : get_value(...) (builtin) \u2014 get_value( (PyAttribute)arg1) -> object :","title":"Methods"},{"location":"api/flame/#class-pyaudiotrack","text":"Object representing an Audio Track.","title":"class PyAudioTrack"},{"location":"api/flame/#methods_4","text":"channels(...) (property) \u2014 None( (flame.PyAudioTrack)arg1) -> list stereo(...) (property) \u2014 None( (flame.PyAudioTrack)arg1) -> bool copy_to_media_panel(...) (builtin) \u2014 copy_to_media_panel( (PyAudioTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object :","title":"Methods"},{"location":"api/flame/#class-pybatch","text":"Class derived from PyFlameObject. This class represents a Batch Group.","title":"class PyBatch"},{"location":"api/flame/#methods_5","text":"nodes(...) (property) \u2014 None( (flame.PyBatch)arg1) -> list node_types(...) (property) \u2014 None( (flame.PyBatch)arg1) -> list reels(...) (property) \u2014 None( (flame.PyBatch)arg1) -> list shelf_reels(...) (property) \u2014 None( (flame.PyBatch)arg1) -> list batch_iterations(...) (property) \u2014 None( (flame.PyBatch)arg1) -> list current_iteration(...) (property) \u2014 None( (flame.PyBatch)arg1) -> object contexts(...) (property) \u2014 None( (flame.PyBatch)arg1) -> dict cursor_position(...) (property) \u2014 None( (flame.PyBatch)arg1) -> tuple opened(...) (property) \u2014 None( (flame.PyBatch)arg1) -> bool current_iteration_number(...) (property) \u2014 None( (flame.PyBatch)arg1) -> int get_node(...) (builtin) \u2014 get_node( (PyBatch)arg1, (str)node_name) -> object : create_node(...) (builtin) \u2014 create_node( (PyBatch)arg1, (str)node_type [, (str)file_path='']) -> object : connect_nodes(...) (builtin) \u2014 connect_nodes( (PyBatch)arg1, (PyNode)output_node, (str)output_socket_name='Default', (PyNode)input_node [, (str)input_socket_name='Default']) -> bool : disconnect_node(...) (builtin) \u2014 disconnect_node( (PyBatch)arg1, (PyNode)node [, (str)input_socket_name='']) -> bool : mimic_link(...) (builtin) \u2014 mimic_link( (PyBatch)arg1, (PyNode)leader_node, (PyNode)follower_node) -> bool : clear_context(...) (builtin) \u2014 clear_context( (PyBatch)arg1, (int)index) -> bool : clear_all_contexts(...) (builtin) \u2014 clear_all_contexts( (PyBatch)arg1) -> bool : organize(...) (builtin) \u2014 organize( (PyBatch)arg1) -> bool : frame_selected(...) (builtin) \u2014 frame_selected( (PyBatch)arg1) -> bool : frame_all(...) (builtin) \u2014 frame_all( (PyBatch)arg1) -> bool : import_clip(...) (builtin) \u2014 import_clip( (PyBatch)arg1, (str)file_path, (str)reel_name) -> object : import_clips(...) (builtin) \u2014 import_clips( (PyBatch)arg1, (object)file_paths, (str)reel_name) -> object : save_setup(...) (builtin) \u2014 save_setup( (PyBatch)arg1, (str)setup_path) -> bool : append_setup(...) (builtin) \u2014 append_setup( (PyBatch)arg1, (str)setup_path [, (bool)confirm=True]) -> bool : set_viewport_layout(...) (builtin) \u2014 set_viewport_layout( (PyBatch)arg1, (object)num_views) -> bool : create_batch_group(...) (builtin) \u2014 create_batch_group( (PyBatch)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : encompass_nodes(...) (builtin) \u2014 encompass_nodes( (PyBatch)arg1, (list)nodes) -> object : select_nodes(...) (builtin) \u2014 select_nodes( (PyBatch)arg1, (object)nodes) -> bool : open(...) (builtin) \u2014 open( (PyBatch)arg1) -> bool : close(...) (builtin) \u2014 close( (PyBatch)arg1) -> bool : clear(...) (builtin) \u2014 clear( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : save(...) (builtin) \u2014 save( (PyBatch)arg1) -> object : append_to_setup(...) (builtin) \u2014 append_to_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : append_to_batch(...) (builtin) \u2014 append_to_batch( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : open_as_batch_group(...) (builtin) \u2014 open_as_batch_group( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : replace_setup(...) (builtin) \u2014 replace_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration [, (bool)confirm=True]) -> bool : create_reel(...) (builtin) \u2014 create_reel( (PyBatch)arg1, (str)name) -> object : create_shelf_reel(...) (builtin) \u2014 create_shelf_reel( (PyBatch)arg1, (str)name) -> object : clear_colour(...) (builtin) \u2014 clear_colour( (PyBatch)arg1) -> None : go_to(...) (builtin) \u2014 go_to( (PyBatch)arg1) -> bool : load_setup(...) (builtin) \u2014 load_setup( (PyBatch)arg1, (str)setup_path) -> bool : clear_setup(...) (builtin) \u2014 clear_setup( (PyBatch)arg1) -> bool : iterate(...) (builtin) \u2014 iterate( (PyBatch)arg1 [, (int)index=-1]) -> object : save_current_iteration(...) (builtin) \u2014 save_current_iteration( (PyBatch)arg1) -> object : render(...) (builtin) \u2014 render( (PyBatch)arg1 [, (str)render_option='Foreground' [, (bool)generate_proxies=False [, (bool)include_history=False]]]) -> bool :","title":"Methods"},{"location":"api/flame/#class-pybatchiteration","text":"Class derived from PyArchiveEntry. This class represents a Batch Iteration.","title":"class PyBatchIteration"},{"location":"api/flame/#methods_6","text":"iteration_number(...) (property) \u2014 None( (flame.PyBatchIteration)arg1) -> int open_as_batch_group(...) (builtin) \u2014 open_as_batch_group( (PyBatchIteration)arg1 [, (bool)confirm=True]) -> bool :","title":"Methods"},{"location":"api/flame/#class-pybrowser","text":"This class represents the file browser.","title":"class PyBrowser"},{"location":"api/flame/#methods_7","text":"show(...) (builtin) \u2014 show( (PyBrowser)arg1, (str)default_path [, (object)extension='' [, (bool)select_directory=False [, (bool)multi_selection=False [, (object)include_resolution=False [, (str)title='Load']]]]]) -> None : selection(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object sequence_mode(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> bool width(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object height(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object scaling_presets_value(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object bit_depth(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object frame_ratio(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> object scan_mode(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> str colour_space(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> str resize_mode(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> str resize_filter(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> str resolution(...) (property) \u2014 None( (flame.PyBrowser)arg1) -> str","title":"Methods"},{"location":"api/flame/#class-pyclip","text":"CLass derived from PyArchiveEntry. This class represents a Clip.","title":"class PyClip"},{"location":"api/flame/#methods_8","text":"frame_rate(...) (property) \u2014 None( (flame.PyClip)arg1) -> object duration(...) (property) \u2014 None( (flame.PyClip)arg1) -> object versions(...) (property) \u2014 None( (flame.PyClip)arg1) -> list audio_tracks(...) (property) \u2014 None( (flame.PyClip)arg1) -> list markers(...) (property) \u2014 None( (flame.PyClip)arg1) -> list subtitles(...) (property) \u2014 None( (flame.PyClip)arg1) -> list width(...) (property) \u2014 None( (flame.PyClip)arg1) -> int height(...) (property) \u2014 None( (flame.PyClip)arg1) -> int bit_depth(...) (property) \u2014 None( (flame.PyClip)arg1) -> int ratio(...) (property) \u2014 None( (flame.PyClip)arg1) -> float scan_mode(...) (property) \u2014 None( (flame.PyClip)arg1) -> str colour_primaries(...) (property) \u2014 None( (flame.PyClip)arg1) -> int transfer_characteristics(...) (property) \u2014 None( (flame.PyClip)arg1) -> int matrix_coefficients(...) (property) \u2014 None( (flame.PyClip)arg1) -> int proxy_resolution(...) (property) \u2014 None( (flame.PyClip)arg1) -> object has_deliverables(...) (property) \u2014 None( (flame.PyClip)arg1) -> bool has_history(...) (property) \u2014 None( (flame.PyClip)arg1) -> bool unlinked(...) (property) \u2014 None( (flame.PyClip)arg1) -> str creation_date(...) (property) \u2014 None( (flame.PyClip)arg1) -> str archive_date(...) (property) \u2014 None( (flame.PyClip)arg1) -> str archive_error(...) (property) \u2014 None( (flame.PyClip)arg1) -> str essence_uid(...) (property) \u2014 None( (flame.PyClip)arg1) -> str source_uid(...) (property) \u2014 None( (flame.PyClip)arg1) -> str original_source_uid(...) (property) \u2014 None( (flame.PyClip)arg1) -> str sample_rate(...) (property) \u2014 None( (flame.PyClip)arg1) -> str cached(...) (property) \u2014 None( (flame.PyClip)arg1) -> str start_frame(...) (property) \u2014 None( (flame.PyClip)arg1) -> int open_as_sequence(...) (builtin) \u2014 open_as_sequence( (PyClip)arg1) -> object : open_container(...) (builtin) \u2014 open_container( (PyClip)arg1) -> bool : close_container(...) (builtin) \u2014 close_container( (PyClip)arg1) -> None : reformat(...) (builtin) \u2014 reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None : create_marker(...) (builtin) \u2014 create_marker( (PyClip)arg1, (object)location) -> object : change_dominance(...) (builtin) \u2014 change_dominance( (PyClip)arg1, (str)scan_mode) -> None : cache_media(...) (builtin) \u2014 cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : flush_cache_media(...) (builtin) \u2014 flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : clear_cache_media(...) (builtin) \u2014 clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : render(...) (builtin) \u2014 render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool : flush_renders(...) (builtin) \u2014 flush_renders( (PyClip)arg1) -> None : clear_renders(...) (builtin) \u2014 clear_renders( (PyClip)arg1) -> None : is_rendered(...) (builtin) \u2014 is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool : save(...) (builtin) \u2014 save( (PyClip)arg1) -> bool : cut(...) (builtin) \u2014 cut( (PyClip)arg1, (PyTime)cut_time) -> None : get_colour_space(...) (builtin) \u2014 get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str : change_start_frame(...) (builtin) \u2014 change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : get_metadata(...) (builtin) \u2014 get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object :","title":"Methods"},{"location":"api/flame/#class-pyclipnode","text":"Class derived from PyNode. This class represents a Clip node.","title":"class PyClipNode"},{"location":"api/flame/#methods_9","text":"clip(...) (property) \u2014 None( (flame.PyClipNode)arg1) -> object version_uids(...) (property) \u2014 None( (flame.PyClipNode)arg1) -> list version_uid(...) (property) \u2014 None( (flame.PyClipNode)arg1) -> object set_version_uid(...) (builtin) \u2014 set_version_uid( (PyClipNode)arg1, (str)version_uid) -> bool : set_metadata_value(...) (builtin) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : set_metadata_discarded(...) (builtin) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_key(...) (builtin) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None :","title":"Methods"},{"location":"api/flame/#class-pyclrmgmtnode","text":"Object representing a Colour Mgmt node.","title":"class PyClrMgmtNode"},{"location":"api/flame/#methods_10","text":"set_context_variable(...) (builtin) \u2014 set_context_variable( (PyClrMgmtNode)arg1, (str)name, (str)value) -> None : get_context_variables(...) (builtin) \u2014 get_context_variables( (PyClrMgmtNode)arg1) -> dict : reset_context_variables(...) (builtin) \u2014 reset_context_variables( (PyClrMgmtNode)arg1) -> None : import_transform(...) (builtin) \u2014 import_transform( (PyClrMgmtNode)arg1, (str)file_path) -> None :","title":"Methods"},{"location":"api/flame/#class-pycocameraanalysis","text":"Class derived from PyCoNode. This class represents the camera analysis node in the Action schematic.","title":"class PyCoCameraAnalysis"},{"location":"api/flame/#methods_11","text":"resetAnalysis(...) (builtin) \u2014 resetAnalysis( (PyCoCameraAnalysis)arg1) -> bool : analyseRange(...) (builtin) \u2014 analyseRange( (PyCoCameraAnalysis)arg1, (object)arg2, (object)start) -> bool :","title":"Methods"},{"location":"api/flame/#class-pycocompass","text":"Class derived from PyCoNode. This class represents the compass node in the Action schematic.","title":"class PyCoCompass"},{"location":"api/flame/#methods_12","text":"nodes(...) (property) \u2014 None( (flame.PyCoCompass)arg1) -> list","title":"Methods"},{"location":"api/flame/#class-pyconode","text":"Class derived from PyFlameObject. This class represents an Action node in the Action schematic.","title":"class PyCoNode"},{"location":"api/flame/#methods_13","text":"assign_media(...) (builtin) \u2014 assign_media( (PyCoNode)arg1, (object)media_name) -> bool : cache_range(...) (builtin) \u2014 cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : add_reference(...) (builtin) \u2014 add_reference( (PyCoNode)arg1, (object)frame) -> bool : parents(...) (builtin) \u2014 parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : children(...) (builtin) \u2014 children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : type(...) (property) \u2014 None( (flame.PyCoNode)arg1) -> str","title":"Methods"},{"location":"api/flame/#class-pycolourmgttimelinefx","text":"Object representing a Colour Mgmt Timeline FX.","title":"class PyColourMgtTimelineFX"},{"location":"api/flame/#methods_14","text":"set_context_variable(...) (builtin) \u2014 set_context_variable( (PyColourMgtTimelineFX)arg1, (str)name, (str)value) -> None : get_context_variables(...) (builtin) \u2014 get_context_variables( (PyColourMgtTimelineFX)arg1) -> dict : import_transform(...) (builtin) \u2014 import_transform( (PyColourMgtTimelineFX)arg1, (str)file_path) -> None : reset_context_variables(...) (builtin) \u2014 reset_context_variables( (PyColourMgtTimelineFX)arg1) -> None :","title":"Methods"},{"location":"api/flame/#class-pycompassnode","text":"Class derived from PyNode. This class represents a Compass node.","title":"class PyCompassNode"},{"location":"api/flame/#methods_15","text":"nodes(...) (property) \u2014 None( (flame.PyCompassNode)arg1) -> list","title":"Methods"},{"location":"api/flame/#class-pydesktop","text":"Class derived from PyArchiveEntry. This class represents a Desktop.","title":"class PyDesktop"},{"location":"api/flame/#methods_16","text":"children(...) (property) \u2014 None( (flame.PyDesktop)arg1) -> list batch_groups(...) (property) \u2014 None( (flame.PyDesktop)arg1) -> list reel_groups(...) (property) \u2014 None( (flame.PyDesktop)arg1) -> list create_reel_group(...) (builtin) \u2014 create_reel_group( (PyDesktop)arg1, (str)name) -> object : save(...) (builtin) \u2014 save( (PyDesktop)arg1) -> bool : create_batch_group(...) (builtin) \u2014 create_batch_group( (PyDesktop)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : clear(...) (builtin) \u2014 clear( (PyDesktop)arg1) -> bool :","title":"Methods"},{"location":"api/flame/#class-pyexporter","text":"Object holding export settings.","title":"class PyExporter"},{"location":"api/flame/#methods_17","text":"use_top_video_track(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool export_between_marks(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool foreground(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool include_subtitles(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool export_subtitles_as_files(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool export_all_subtitles(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_unlinked(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_unrendered(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_pending_render(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_no_media(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_mixed_colour_space(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool warn_on_reimport_unsupported(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool keep_timeline_fx_renders(...) (property) \u2014 None( (flame.PyExporter)arg1) -> bool get_presets_base_dir(...) (staticmethod) \u2014 get_presets_base_dir( (PyExporter.PresetVisibility)preset_visibility) -> str : get_presets_dir(...) (staticmethod) \u2014 get_presets_dir( (PyExporter.PresetVisibility)preset_visibility, (PyExporter.PresetType)preset_type) -> str : export(...) (builtin) \u2014 export( (PyExporter)arg1, (object)sources, (str)preset_path, (str)output_directory [, (PyExporter.BackgroundJobSettings)background_job_settings=None [, (object)hooks=None [, (object)hooks_user_data=None]]]) -> None : BackgroundJobSettings(...) (callable) \u2014 Object holding background export job settings. These settings refer to the Backburner job, server and manager. PresetType(...) (callable) \u2014 int([x]) -> integer Image_Sequence(...) (attribute) \u2014 Audio(...) (attribute) \u2014 Movie(...) (attribute) \u2014 Sequence_Publish(...) (attribute) \u2014 Distribution_Package(...) (attribute) \u2014 PresetVisibility(...) (callable) \u2014 int([x]) -> integer User(...) (attribute) \u2014 Project(...) (attribute) \u2014 Shared(...) (attribute) \u2014 Autodesk(...) (attribute) \u2014 Flow_Production_Tracking(...) (attribute) \u2014 Shotgun(...) (attribute) \u2014","title":"Methods"},{"location":"api/flame/#class-pyflameobject","text":"The basic type of all accessible Flame objects from the python API.","title":"class PyFlameObject"},{"location":"api/flame/#methods_18","text":"attributes(...) (property) \u2014 None( (flame.PyFlameObject)arg1) -> list parent(...) (property) \u2014 None( (flame.PyFlameObject)arg1) -> object","title":"Methods"},{"location":"api/flame/#class-pyfolder","text":"Class derived from PyArchiveEntry. This class represents a Folder.","title":"class PyFolder"},{"location":"api/flame/#methods_19","text":"children(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list folders(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list batch_iterations(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list desktops(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list reel_groups(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list reels(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list sequences(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list clips(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list batch_groups(...) (property) \u2014 None( (flame.PyFolder)arg1) -> list clear(...) (builtin) \u2014 clear( (PyFolder)arg1 [, (bool)confirm=True]) -> bool : create_reel_group(...) (builtin) \u2014 create_reel_group( (PyFolder)arg1, (str)name) -> object : create_reel(...) (builtin) \u2014 create_reel( (PyFolder)arg1, (str)name) -> object : create_folder(...) (builtin) \u2014 create_folder( (PyFolder)arg1, (str)name) -> object : create_sequence(...) (builtin) \u2014 create_sequence( (PyFolder)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object :","title":"Methods"},{"location":"api/flame/#class-pygmasktracernode","text":"Class derived from PyActionFamilyNode. Represents a GMask Tracer node object.","title":"class PyGMaskTracerNode"},{"location":"api/flame/#methods_20","text":"import_fbx(...) (builtin) \u2014 import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : export_fbx(...) (builtin) \u2014 export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : read_fbx(...) (builtin) \u2014 read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : import_abc(...) (builtin) \u2014 import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : read_abc(...) (builtin) \u2014 read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : import_psd(...) (builtin) \u2014 import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : enable_output(...) (builtin) \u2014 enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : disable_output(...) (builtin) \u2014 disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : output_types(...) (property) \u2014 None( (flame.PyGMaskTracerNode)arg1) -> list","title":"Methods"},{"location":"api/flame/#class-pyhdrnode","text":"Object representing a HDR node.","title":"class PyHDRNode"},{"location":"api/flame/#methods_21","text":"analysis_status(...) (property) \u2014 None( (flame.PyHDRNode)arg1) -> object analyze(...) (builtin) \u2014 analyze( (PyHDRNode)arg1 [, (str)analyze_mode='Current Shot']) -> None : keep_analysis(...) (builtin) \u2014 keep_analysis( (PyHDRNode)arg1) -> None : reset_analysis(...) (builtin) \u2014 reset_analysis( (PyHDRNode)arg1) -> None : interpolate_trims(...) (builtin) \u2014 interpolate_trims( (PyHDRNode)arg1) -> None : reset_trims(...) (builtin) \u2014 reset_trims( (PyHDRNode)arg1) -> None : export_DolbyVision_xml(...) (builtin) \u2014 export_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)comment='']) -> None : import_DolbyVision_xml(...) (builtin) \u2014 import_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : mastering_display_ids(...) (property) \u2014 None( (flame.PyHDRNode)arg1) -> list target_display_ids(...) (property) \u2014 None( (flame.PyHDRNode)arg1) -> list mastering_display_info(...) (property) \u2014 None( (flame.PyHDRNode)arg1) -> object target_display_info(...) (property) \u2014 None( (flame.PyHDRNode)arg1) -> object has_trim(...) (builtin) \u2014 has_trim( (PyHDRNode)arg1, (int)target_display_id) -> bool : l2_from_l8(...) (builtin) \u2014 l2_from_l8( (PyHDRNode)arg1) -> object :","title":"Methods"},{"location":"api/flame/#class-pyhdrtimelinefx","text":"Object representing a HDR Timeline FX.","title":"class PyHDRTimelineFX"},{"location":"api/flame/#methods_22","text":"analysis_status(...) (property) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object analyze(...) (builtin) \u2014 analyze( (PyHDRTimelineFX)arg1 [, (str)analyze_mode='Current Shot']) -> None : keep_analysis(...) (builtin) \u2014 keep_analysis( (PyHDRTimelineFX)arg1) -> None : reset_analysis(...) (builtin) \u2014 reset_analysis( (PyHDRTimelineFX)arg1) -> None : interpolate_trims(...) (builtin) \u2014 interpolate_trims( (PyHDRTimelineFX)arg1, (str)arg2) -> None : reset_trims(...) (builtin) \u2014 reset_trims( (PyHDRTimelineFX)arg1) -> None : export_DolbyVision_xml(...) (builtin) \u2014 export_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (bool)shot_only=False [, (str)comment='']]) -> None : import_DolbyVision_xml(...) (builtin) \u2014 import_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : mastering_display_ids(...) (property) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> list target_display_ids(...) (property) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> list mastering_display_info(...) (property) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object target_display_info(...) (property) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object has_trim(...) (builtin) \u2014 has_trim( (PyHDRTimelineFX)arg1, (int)target_display_id) -> bool : l2_from_l8(...) (builtin) \u2014 l2_from_l8( (PyHDRTimelineFX)arg1) -> object :","title":"Methods"},{"location":"api/flame/#class-pyimagenode","text":"Class derived from PyActionFamilyNode. Represents an Image node object.","title":"class PyImageNode"},{"location":"api/flame/#methods_23","text":"media_nodes(...) (property) \u2014 None( (flame.PyImageNode)arg1) -> list add_media(...) (builtin) \u2014 add_media( (PyActionFamilyNode)arg1) -> object :","title":"Methods"},{"location":"api/flame/#class-pylensdistortionnode","text":"Object representing a Lens Distortion node.","title":"class PyLensDistortionNode"},{"location":"api/flame/#methods_24","text":"import_lens_distortion(...) (builtin) \u2014 import_lens_distortion( (PyLensDistortionNode)arg1, (str)filename) -> None : calculate(...) (builtin) \u2014 calculate( (PyLensDistortionNode)arg1) -> None :","title":"Methods"},{"location":"api/flame/#class-pylibrary","text":"Class derived from PyArchiveEntry. This class represents a Library.","title":"class PyLibrary"},{"location":"api/flame/#methods_25","text":"children(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list folders(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list batch_iterations(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list desktops(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list reel_groups(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list reels(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list sequences(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list clips(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list batch_groups(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> list opened(...) (property) \u2014 None( (flame.PyLibrary)arg1) -> bool open(...) (builtin) \u2014 open( (PyLibrary)arg1) -> bool : close(...) (builtin) \u2014 close( (PyLibrary)arg1) -> bool : clear(...) (builtin) \u2014 clear( (PyLibrary)arg1 [, (bool)confirm=True]) -> bool : acquire_exclusive_access(...) (builtin) \u2014 acquire_exclusive_access( (PyLibrary)arg1) -> bool : release_exclusive_access(...) (builtin) \u2014 release_exclusive_access( (PyLibrary)arg1) -> bool : create_reel_group(...) (builtin) \u2014 create_reel_group( (PyLibrary)arg1, (str)name) -> object : create_reel(...) (builtin) \u2014 create_reel( (PyLibrary)arg1, (str)name) -> object : create_folder(...) (builtin) \u2014 create_folder( (PyLibrary)arg1, (str)name) -> object : create_sequence(...) (builtin) \u2014 create_sequence( (PyLibrary)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object :","title":"Methods"},{"location":"api/flame/#class-pymarker","text":"Object representing a Marker.","title":"class PyMarker"},{"location":"api/flame/#methods_26","text":"has_annotations(...) (property) \u2014 None( (flame.PyMarker)arg1) -> bool clear_annotations(...) (builtin) \u2014 clear_annotations( (PyMarker)arg1) -> None : sync_connected_segments(...) (builtin) \u2014 sync_connected_segments( (PyMarker)arg1) -> None :","title":"Methods"},{"location":"api/flame/#class-pymediahub","text":"This class represents the MediaHub.","title":"class PyMediaHub"},{"location":"api/flame/#methods_27","text":"files(...) (property) \u2014 None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubFilesTab archives(...) (property) \u2014 None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubTab","title":"Methods"},{"location":"api/flame/#class-pymediahubfilesentry","text":"Object representing a clip in the MediaHub Files tabs","title":"class PyMediaHubFilesEntry"},{"location":"api/flame/#methods_28","text":"path(...) (property) \u2014 None( (flame.PyMediaHubFilesEntry)arg1) -> str","title":"Methods"},{"location":"api/flame/#class-pymediahubfilesfolder","text":"Object representing a folder in the MediaHub Files tabs","title":"class PyMediaHubFilesFolder"},{"location":"api/flame/#methods_29","text":"path(...) (property) \u2014 None( (flame.PyMediaHubFilesFolder)arg1) -> str","title":"Methods"},{"location":"api/flame/#class-pymediahubfilestab","text":"This class represents the MediaHub Files tab.","title":"class PyMediaHubFilesTab"},{"location":"api/flame/#methods_30","text":"options(...) (property) \u2014 None( (flame.PyMediaHubFilesTab)arg1) -> flame.PyMediaHubFilesTabOptions","title":"Methods"},{"location":"api/flame/#class-pymediahubfilestaboptions","text":"This class represents the MediaHub Files tab options.","title":"class PyMediaHubFilesTabOptions"},{"location":"api/flame/#methods_31","text":"multi_channel_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str sequence_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool cache_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool proxies_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool cache_and_proxies_all_versions(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool resize_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str resize_filter(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str resolution(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str width(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object height(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object scaling_presets_value(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object frame_ratio(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object bit_depth(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object scan_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str pixel_ratio(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object colour_mgmt_mode(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_view(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str tagged_colour_space(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_display(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_working_space(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_invert(...) (property) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool import_transform(...) (builtin) \u2014 import_transform( (PyMediaHubFilesTabOptions)arg1, (str)file_path) -> None : set_tagged_colour_space(...) (builtin) \u2014 set_tagged_colour_space( (PyMediaHubFilesTabOptions)arg1, (str)colour_space) -> None :","title":"Methods"},{"location":"api/flame/#class-pymediahubprojectsentry","text":"Object representing a clip in the MediaHub Projects tabs","title":"class PyMediaHubProjectsEntry"},{"location":"api/flame/#methods_32","text":"uid(...) (property) \u2014 None( (flame.PyMediaHubProjectsEntry)arg1) -> str path(...) (property) \u2014 None( (flame.PyMediaHubProjectsEntry)arg1) -> str","title":"Methods"},{"location":"api/flame/#class-pymediahubprojectsfolder","text":"Object representing a folder in the MediaHub Projects tabs","title":"class PyMediaHubProjectsFolder"},{"location":"api/flame/#methods_33","text":"uid(...) (property) \u2014 None( (flame.PyMediaHubProjectsFolder)arg1) -> str path(...) (property) \u2014 None( (flame.PyMediaHubProjectsFolder)arg1) -> str","title":"Methods"},{"location":"api/flame/#class-pymediahubtab","text":"This class represents a MediaHub tab.","title":"class PyMediaHubTab"},{"location":"api/flame/#methods_34","text":"get_path(...) (builtin) \u2014 get_path( (PyMediaHubTab)arg1) -> str : set_path(...) (builtin) \u2014 set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool :","title":"Methods"},{"location":"api/flame/#class-pymediapanel","text":"This class represents the media panel.","title":"class PyMediaPanel"},{"location":"api/flame/#methods_35","text":"selected_entries(...) (property) \u2014 None( (flame.PyMediaPanel)arg1) -> object visible(...) (property) \u2014 None( (flame.PyMediaPanel)arg1) -> bool full_height(...) (property) \u2014 None( (flame.PyMediaPanel)arg1) -> bool full_width(...) (property) \u2014 None( (flame.PyMediaPanel)arg1) -> bool dual(...) (property) \u2014 None( (flame.PyMediaPanel)arg1) -> bool move(...) (builtin) \u2014 move( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : copy(...) (builtin) \u2014 copy( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object :","title":"Methods"},{"location":"api/flame/#class-pymessages","text":"Module handling message bar in application UI.","title":"class PyMessages"},{"location":"api/flame/#methods_36","text":"show_in_console(...) (builtin) \u2014 show_in_console( (PyMessages)arg1, (str)message [, (str)type='info' [, (int)duration=-1]]) -> None : clear_console(...) (builtin) \u2014 clear_console( (PyMessages)arg1) -> None : show_in_dialog(...) (builtin) \u2014 show_in_dialog( (PyMessages)arg1, (str)title, (str)message, (str)type, (list)buttons [, (str)cancel_button='']) -> str :","title":"Methods"},{"location":"api/flame/#class-pymetadatanode","text":"Class derived from PyNode. This class represents a Metadata node.","title":"class PyMetadataNode"},{"location":"api/flame/#methods_37","text":"set_metadata_value(...) (builtin) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : set_metadata_discarded(...) (builtin) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_key(...) (builtin) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : load_node_setup(...) (builtin) \u2014 load_node_setup( (PyMetadataNode)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)replaced_keys=True [, (bool)update_tokens=True]]]]]) -> bool :","title":"Methods"},{"location":"api/flame/#class-pymetadatatimelinefx","text":"Object representing a Metadata Timeline FX.","title":"class PyMetadataTimelineFX"},{"location":"api/flame/#methods_38","text":"get_metadata(...) (builtin) \u2014 get_metadata( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (int)frame=1]]) -> object : set_metadata_value(...) (builtin) \u2014 set_metadata_value( (PyMetadataTimelineFX)arg1, (str)key [, (object)value=None]) -> None : set_metadata_discarded(...) (builtin) \u2014 set_metadata_discarded( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (bool)discarded=True]]) -> None : set_metadata_key(...) (builtin) \u2014 set_metadata_key( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (object)name=None]]) -> None : load_setup(...) (builtin) \u2014 load_setup( (PyMetadataTimelineFX)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)update_tokens=True]]]]) -> bool :","title":"Methods"},{"location":"api/flame/#class-pymetadatavalue","text":"This class holds the metadata of a specific data type.","title":"class PyMetadataValue"},{"location":"api/flame/#methods_39","text":"get_value(...) (builtin) \u2014 get_value( (PyMetadataValue)arg1) -> object : set_value(...) (builtin) \u2014 set_value( (PyMetadataValue)arg1, (object)value) -> None : type(...) (property) \u2014 None( (flame.PyMetadataValue)arg1) -> str","title":"Methods"},{"location":"api/flame/#class-pymorphnode","text":"Object representing a Morph node.","title":"class PyMorphNode"},{"location":"api/flame/#methods_40","text":"set_mix_to_range(...) (builtin) \u2014 set_mix_to_range( (PyMorphNode)arg1) -> None :","title":"Methods"},{"location":"api/flame/#class-pynode","text":"Object representing a Node.","title":"class PyNode"},{"location":"api/flame/#methods_41","text":"sockets(...) (property) \u2014 None( (flame.PyNode)arg1) -> dict input_sockets(...) (property) \u2014 None( (flame.PyNode)arg1) -> list output_sockets(...) (property) \u2014 None( (flame.PyNode)arg1) -> list load_node_setup(...) (builtin) \u2014 load_node_setup( (PyNode)arg1, (str)file_name) -> bool : save_node_setup(...) (builtin) \u2014 save_node_setup( (PyNode)arg1, (str)file_name) -> bool : delete(...) (builtin) \u2014 delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : duplicate(...) (builtin) \u2014 duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : set_context(...) (builtin) \u2014 set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : clear_schematic_colour(...) (builtin) \u2014 clear_schematic_colour( (PyNode)arg1) -> None : get_metadata(...) (builtin) \u2014 get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : cache_range(...) (builtin) \u2014 cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : output_channel_as_metadata_key(...) (builtin) \u2014 output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None :","title":"Methods"},{"location":"api/flame/#class-pyofxnode","text":"Object representing a OpenFX node.","title":"class PyOFXNode"},{"location":"api/flame/#methods_42","text":"change_plugin(...) (builtin) \u2014 change_plugin( (PyOFXNode)arg1, (str)plugin_name) -> bool :","title":"Methods"},{"location":"api/flame/#class-pypaintnode","text":"Object representing a Paint node.","title":"class PyPaintNode"},{"location":"api/flame/#methods_43","text":"add_source(...) (builtin) \u2014 add_source( (PyPaintNode)arg1) -> object :","title":"Methods"},{"location":"api/flame/#class-pyproject","text":"Object representing a Project.","title":"class PyProject"},{"location":"api/flame/#methods_44","text":"name(...) (property) \u2014 None( (flame.PyProject)arg1) -> str nickname(...) (property) \u2014 None( (flame.PyProject)arg1) -> str description(...) (property) \u2014 None( (flame.PyProject)arg1) -> str project_name(...) (property) \u2014 None( (flame.PyProject)arg1) -> str workspaces_count(...) (property) \u2014 None( (flame.PyProject)arg1) -> int current_workspace(...) (property) \u2014 None( (flame.PyProject)arg1) -> object shared_libraries(...) (property) \u2014 None( (flame.PyProject)arg1) -> list project_folder(...) (property) \u2014 None( (flame.PyProject)arg1) -> str setups_folder(...) (property) \u2014 None( (flame.PyProject)arg1) -> str media_folder(...) (property) \u2014 None( (flame.PyProject)arg1) -> str create_shared_library(...) (builtin) \u2014 create_shared_library( (PyProject)arg1, (str)name) -> object : refresh_shared_libraries(...) (builtin) \u2014 refresh_shared_libraries( (PyProject)arg1) -> bool : reload_ocio_config(...) (builtin) \u2014 reload_ocio_config( (PyProject)arg1 [, (bool)reset_colour_policy=False]) -> bool : export_ocio_config(...) (builtin) \u2014 export_ocio_config( (PyProject)arg1, (str)config_name [, (str)destination_folder='' [, (bool)overwrite_existing=False [, (bool)export_as_locked=False [, (bool)generate_ocioz=False]]]]) -> bool : set_context_variable(...) (builtin) \u2014 set_context_variable( (PyProject)arg1, (str)name, (str)value) -> None : get_context_variables(...) (builtin) \u2014 get_context_variables( (PyProject)arg1) -> dict : reset_context_variables(...) (builtin) \u2014 reset_context_variables( (PyProject)arg1) -> None :","title":"Methods"},{"location":"api/flame/#class-pyprojectselector","text":"Object representing the Project manager.","title":"class PyProjectSelector"},{"location":"api/flame/#methods_45","text":"current_project(...) (property) \u2014 None( (flame.PyProjectSelector)arg1) -> object","title":"Methods"},{"location":"api/flame/#class-pyreadfilenode","text":"Class derived from PyNode. This class represents a ReadFile node.","title":"class PyReadFileNode"},{"location":"api/flame/#class-pyreel","text":"Object representing a Reel.","title":"class PyReel"},{"location":"api/flame/#methods_46","text":"children(...) (property) \u2014 None( (flame.PyReel)arg1) -> list sequences(...) (property) \u2014 None( (flame.PyReel)arg1) -> list clips(...) (property) \u2014 None( (flame.PyReel)arg1) -> list type(...) (property) \u2014 None( (flame.PyReel)arg1) -> object clear(...) (builtin) \u2014 clear( (PyReel)arg1 [, (bool)confirm=True]) -> bool : create_sequence(...) (builtin) \u2014 create_sequence( (PyReel)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : save(...) (builtin) \u2014 save( (PyReel)arg1) -> bool :","title":"Methods"},{"location":"api/flame/#class-pyreelgroup","text":"Object representing a Reel Group.","title":"class PyReelGroup"},{"location":"api/flame/#methods_47","text":"children(...) (property) \u2014 None( (flame.PyReelGroup)arg1) -> list reels(...) (property) \u2014 None( (flame.PyReelGroup)arg1) -> list clear(...) (builtin) \u2014 clear( (PyReelGroup)arg1 [, (bool)confirm=True]) -> bool : create_reel(...) (builtin) \u2014 create_reel( (PyReelGroup)arg1, (str)name [, (bool)sequence=False]) -> object : save(...) (builtin) \u2014 save( (PyReelGroup)arg1) -> bool :","title":"Methods"},{"location":"api/flame/#class-pyrendernode","text":"Class derived from PyNode. This class represents a Render node.","title":"class PyRenderNode"},{"location":"api/flame/#methods_48","text":"channels(...) (property) \u2014 None( (flame.PyRenderNode)arg1) -> list set_channel_name(...) (builtin) \u2014 set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None : set_metadata_value(...) (builtin) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None : set_metadata_discarded(...) (builtin) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_key(...) (builtin) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None :","title":"Methods"},{"location":"api/flame/#class-pyresolution","text":"Object representing a resolution","title":"class PyResolution"},{"location":"api/flame/#methods_49","text":"resolution(...) (property) \u2014 None( (flame.PyResolution)arg1) -> str width(...) (property) \u2014 None( (flame.PyResolution)arg1) -> int height(...) (property) \u2014 None( (flame.PyResolution)arg1) -> int frame_ratio(...) (property) \u2014 None( (flame.PyResolution)arg1) -> float scan_mode(...) (property) \u2014 None( (flame.PyResolution)arg1) -> str bit_depth(...) (property) \u2014 None( (flame.PyResolution)arg1) -> int","title":"Methods"},{"location":"api/flame/#class-pysearch","text":"This class represents the search.","title":"class PySearch"},{"location":"api/flame/#methods_50","text":"use_weight(...) (property) \u2014 None( (flame.PySearch)arg1) -> bool set_tool_favorite(...) (builtin) \u2014 set_tool_favorite( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : set_tool_hidden(...) (builtin) \u2014 set_tool_hidden( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : set_tool_weight(...) (builtin) \u2014 set_tool_weight( (PySearch)arg1, (str)arg2, (str)name, (int)type) -> None : search_results(...) (builtin) \u2014 search_results( (PySearch)arg1 [, (str)search_str='*' [, (str)tab='Tools']]) -> list : activate_search_result(...) (builtin) \u2014 activate_search_result( (PySearch)arg1, (str)name, (str)type [, (str)tab='Tools']) -> None :","title":"Methods"},{"location":"api/flame/#class-pysegment","text":"Object representing a Segment.","title":"class PySegment"},{"location":"api/flame/#methods_51","text":"source_name(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_in(...) (property) \u2014 None( (flame.PySegment)arg1) -> object source_out(...) (property) \u2014 None( (flame.PySegment)arg1) -> object source_duration(...) (property) \u2014 None( (flame.PySegment)arg1) -> object source_width(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_height(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_bit_depth(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_ratio(...) (property) \u2014 None( (flame.PySegment)arg1) -> float source_scan_mode(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_frame_rate(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_cached(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_has_history(...) (property) \u2014 None( (flame.PySegment)arg1) -> bool source_unlinked(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_sample_rate(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_audio_track(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_essence_uid(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_uid(...) (property) \u2014 None( (flame.PySegment)arg1) -> str original_source_uid(...) (property) \u2014 None( (flame.PySegment)arg1) -> str source_colour_primaries(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_transfer_characteristics(...) (property) \u2014 None( (flame.PySegment)arg1) -> int source_matrix_coefficients(...) (property) \u2014 None( (flame.PySegment)arg1) -> int tape_name(...) (property) \u2014 None( (flame.PySegment)arg1) -> str record_in(...) (property) \u2014 None( (flame.PySegment)arg1) -> object record_out(...) (property) \u2014 None( (flame.PySegment)arg1) -> object record_duration(...) (property) \u2014 None( (flame.PySegment)arg1) -> object start_frame(...) (property) \u2014 None( (flame.PySegment)arg1) -> int file_path(...) (property) \u2014 None( (flame.PySegment)arg1) -> str markers(...) (property) \u2014 None( (flame.PySegment)arg1) -> list effect_types(...) (property) \u2014 None( (flame.PySegment)arg1) -> list effects(...) (property) \u2014 None( (flame.PySegment)arg1) -> list groups(...) (property) \u2014 None( (flame.PySegment)arg1) -> list type(...) (property) \u2014 None( (flame.PySegment)arg1) -> str head(...) (property) \u2014 None( (flame.PySegment)arg1) -> object tail(...) (property) \u2014 None( (flame.PySegment)arg1) -> object rgb_channel(...) (property) \u2014 None( (flame.PySegment)arg1) -> str matte_channel(...) (property) \u2014 None( (flame.PySegment)arg1) -> str rgb_channels(...) (property) \u2014 None( (flame.PySegment)arg1) -> list matte_channels(...) (property) \u2014 None( (flame.PySegment)arg1) -> list version_uid(...) (property) \u2014 None( (flame.PySegment)arg1) -> str version_uids(...) (property) \u2014 None( (flame.PySegment)arg1) -> list matte_mode(...) (property) \u2014 None( (flame.PySegment)arg1) -> str container_clip(...) (property) \u2014 None( (flame.PySegment)arg1) -> object create_effect(...) (builtin) \u2014 create_effect( (PySegment)arg1, (str)effect_type [, (str)after_effect_type='']) -> object : create_marker(...) (builtin) \u2014 create_marker( (PySegment)arg1, (object)location) -> object : create_connection(...) (builtin) \u2014 create_connection( (PySegment)arg1) -> None : remove_connection(...) (builtin) \u2014 remove_connection( (PySegment)arg1) -> None : sync_connected_segments(...) (builtin) \u2014 sync_connected_segments( (PySegment)arg1) -> None : connected_segments(...) (builtin) \u2014 connected_segments( (PySegment)arg1 [, (str)scoping='all reels']) -> object : duplicate_source(...) (builtin) \u2014 duplicate_source( (PySegment)arg1) -> None : shared_source_segments(...) (builtin) \u2014 shared_source_segments( (PySegment)arg1) -> object : copy_to_media_panel(...) (builtin) \u2014 copy_to_media_panel( (PySegment)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : trim_head(...) (builtin) \u2014 trim_head( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : trim_tail(...) (builtin) \u2014 trim_tail( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : slip(...) (builtin) \u2014 slip( (PySegment)arg1, (int)offset [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]) -> bool : slide_keyframes(...) (builtin) \u2014 slide_keyframes( (PySegment)arg1, (int)offset [, (bool)sync=False]) -> bool : set_gap_colour(...) (builtin) \u2014 set_gap_colour( (PySegment)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : set_gap_bars(...) (builtin) \u2014 set_gap_bars( (PySegment)arg1 [, (str)type='smpte' [, (bool)full_luminance=False [, (float)softness=0.0]]]) -> object : smart_replace(...) (builtin) \u2014 smart_replace( (PySegment)arg1, (PyClip)source_clip) -> None : smart_replace_media(...) (builtin) \u2014 smart_replace_media( (PySegment)arg1, (PyClip)source_clip) -> None : match(...) (builtin) \u2014 match( (PySegment)arg1, (PyArchiveEntry)destination [, (bool)preserve_handle=False [, (bool)use_sequence_info=True [, (bool)include_nested_content=False [, (bool)include_timeline_fx=False]]]]) -> object : clear_colour(...) (builtin) \u2014 clear_colour( (PySegment)arg1) -> None : set_rgb_channel(...) (builtin) \u2014 set_rgb_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences']]]) -> bool : set_matte_channel(...) (builtin) \u2014 set_matte_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences' [, (str)matte_mode='Custom Matte']]]]) -> bool : set_version_uid(...) (builtin) \u2014 set_version_uid( (PySegment)arg1, (str)version_uid [, (str)scope='Follow Source Sharing']) -> bool : get_colour_space(...) (builtin) \u2014 get_colour_space( (PySegment)arg1 [, (PyTime)time=None]) -> str : create_unlinked_segment(...) (builtin) \u2014 create_unlinked_segment( (PySegment)arg1 [, (str)source_name='' [, (str)tape_name='' [, (object)start_time=0 [, (object)source_duration=0 [, (object)head=0 [, (str)file_path='' [, (int)source_audio_track=1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='Same As Sequence' [, (str)frame_rate='Same As Sequence' [, (object)timewarp_speed=None]]]]]]]]]]]]]]) -> None : change_start_frame(...) (builtin) \u2014 change_start_frame( (PySegment)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : get_metadata(...) (builtin) \u2014 get_metadata( (PySegment)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object :","title":"Methods"},{"location":"api/flame/#class-pysequence","text":"Object representing a Sequence.","title":"class PySequence"},{"location":"api/flame/#methods_52","text":"open(...) (builtin) \u2014 open( (PySequence)arg1) -> bool : create_container(...) (builtin) \u2014 create_container( (PySequence)arg1) -> object : create_version(...) (builtin) \u2014 create_version( (PySequence)arg1 [, (bool)stereo=False]) -> object : create_audio(...) (builtin) \u2014 create_audio( (PySequence)arg1 [, (bool)stereo=False]) -> object : create_subtitle(...) (builtin) \u2014 create_subtitle( (PySequence)arg1) -> object : import_subtitles_file(...) (builtin) \u2014 import_subtitles_file( (PySequence)arg1, (str)file_name [, (object)file_type=None [, (bool)align_first_event_to_clip_start=False [, (object)convert_from_frame_rate=None]]]) -> object : create_group(...) (builtin) \u2014 create_group( (PySequence)arg1, (str)name) -> object : insert(...) (builtin) \u2014 insert( (PySequence)arg1, (PyClip)source_clip [, (PyTime)insert_time=None [, (PyTrack)destination_track=None]]) -> bool : overwrite(...) (builtin) \u2014 overwrite( (PySequence)arg1, (PyClip)source_clip [, (PyTime)overwrite_time=None [, (PyTrack)destination_track=None]]) -> bool : copy_selection_to_media_panel(...) (builtin) \u2014 copy_selection_to_media_panel( (PySequence)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : extract_selection_to_media_panel(...) (builtin) \u2014 extract_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : lift_selection_to_media_panel(...) (builtin) \u2014 lift_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : groups(...) (property) \u2014 None( (flame.PySequence)arg1) -> list","title":"Methods"},{"location":"api/flame/#class-pysequencegroup","text":"Object representing a Group in a Sequence.","title":"class PySequenceGroup"},{"location":"api/flame/#methods_53","text":"segments(...) (property) \u2014 None( (flame.PySequenceGroup)arg1) -> list add(...) (builtin) \u2014 add( (PySequenceGroup)arg1, (object)segments) -> None : remove(...) (builtin) \u2014 remove( (PySequenceGroup)arg1, (object)segments) -> None :","title":"Methods"},{"location":"api/flame/#class-pysubtitletrack","text":"Object representing a Subtitle Track.","title":"class PySubtitleTrack"},{"location":"api/flame/#methods_54","text":"export_as_srt_file(...) (builtin) \u2014 export_as_srt_file( (PySubtitleTrack)arg1, (str)file_name [, (bool)character_based_attributes=True [, (bool)export_colours=False [, (str)exclude_colour='' [, (bool)use_original_colours=False [, (bool)use_original_alignment=False [, (bool)export_alignments=False [, (str)alignment_type='an' [, (str)exclude_alignment='' [, (str)start_timecode='Same as Clip']]]]]]]]]) -> None :","title":"Methods"},{"location":"api/flame/#class-pytime","text":"Object representing a time unit","title":"class PyTime"},{"location":"api/flame/#methods_55","text":"frame(...) (property) \u2014 None( (flame.PyTime)arg1) -> int relative_frame(...) (property) \u2014 None( (flame.PyTime)arg1) -> int timecode(...) (property) \u2014 None( (flame.PyTime)arg1) -> str frame_rate(...) (property) \u2014 None( (flame.PyTime)arg1) -> object","title":"Methods"},{"location":"api/flame/#class-pytimeline","text":"This class represents the Timeline.","title":"class PyTimeline"},{"location":"api/flame/#methods_56","text":"clip(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> object current_segment(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> object current_marker(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> object current_effect(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> object current_transition(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> object type(...) (property) \u2014 None( (flame.PyTimeline)arg1) -> str","title":"Methods"},{"location":"api/flame/#class-pytimelinefx","text":"Object representing a Timeline FX.","title":"class PyTimelineFX"},{"location":"api/flame/#methods_57","text":"type(...) (property) \u2014 None( (flame.PyTimelineFX)arg1) -> object has_maps_cache_media(...) (property) \u2014 None( (flame.PyTimelineFX)arg1) -> bool load_setup(...) (builtin) \u2014 load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : save_setup(...) (builtin) \u2014 save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : flush_maps_cache_media(...) (builtin) \u2014 flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : clear_maps_cache_media(...) (builtin) \u2014 clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : sync_connected_segments(...) (builtin) \u2014 sync_connected_segments( (PyTimelineFX)arg1) -> None : slide_keyframes(...) (builtin) \u2014 slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : output_channel_as_metadata_key(...) (builtin) \u2014 output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None :","title":"Methods"},{"location":"api/flame/#class-pytimewarpnode","text":"Object representing a Timewarp node.","title":"class PyTimewarpNode"},{"location":"api/flame/#methods_58","text":"get_speed(...) (builtin) \u2014 get_speed( (PyTimewarpNode)arg1, (float)frame) -> float : set_speed(...) (builtin) \u2014 set_speed( (PyTimewarpNode)arg1, (float)frame, (float)new_speed) -> None : set_timing(...) (builtin) \u2014 set_timing( (PyTimewarpNode)arg1, (float)frame, (float)new_timing) -> None : get_timing(...) (builtin) \u2014 get_timing( (PyTimewarpNode)arg1, (float)frame) -> float : get_duration_timing(...) (builtin) \u2014 get_duration_timing( (PyTimewarpNode)arg1, (float)frame) -> float : get_speed_timing(...) (builtin) \u2014 get_speed_timing( (PyTimewarpNode)arg1, (float)frame) -> float :","title":"Methods"},{"location":"api/flame/#class-pytimewarptimelinefx","text":"Object representing a Timewarp node.","title":"class PyTimewarpTimelineFX"},{"location":"api/flame/#methods_59","text":"get_speed(...) (builtin) \u2014 get_speed( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : set_speed(...) (builtin) \u2014 set_speed( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_speed) -> None : set_timing(...) (builtin) \u2014 set_timing( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_timing) -> None : get_timing(...) (builtin) \u2014 get_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_duration_timing(...) (builtin) \u2014 get_duration_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_speed_timing(...) (builtin) \u2014 get_speed_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float :","title":"Methods"},{"location":"api/flame/#class-pytrack","text":"Object representing a Track.","title":"class PyTrack"},{"location":"api/flame/#methods_60","text":"segments(...) (property) \u2014 None( (flame.PyTrack)arg1) -> list transitions(...) (property) \u2014 None( (flame.PyTrack)arg1) -> list copy_to_media_panel(...) (builtin) \u2014 copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : cut(...) (builtin) \u2014 cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None : insert_transition(...) (builtin) \u2014 insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object :","title":"Methods"},{"location":"api/flame/#class-pytransition","text":"Object representing a Transition.","title":"class PyTransition"},{"location":"api/flame/#methods_61","text":"type(...) (property) \u2014 None( (flame.PyTransition)arg1) -> str record_time(...) (property) \u2014 None( (flame.PyTransition)arg1) -> object in_offset(...) (property) \u2014 None( (flame.PyTransition)arg1) -> int set_transition(...) (builtin) \u2014 set_transition( (PyTransition)arg1, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0]]]) -> object : slide(...) (builtin) \u2014 slide( (PyTransition)arg1, (int)offset [, (bool)sync=False]) -> bool : set_dissolve_to_from_colour(...) (builtin) \u2014 set_dissolve_to_from_colour( (PyTransition)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : set_fade_to_from_silence(...) (builtin) \u2014 set_fade_to_from_silence( (PyTransition)arg1) -> None :","title":"Methods"},{"location":"api/flame/#class-pytypefx","text":"Object representing a Type Timeline FX.","title":"class PyTypeFX"},{"location":"api/flame/#methods_62","text":"layers(...) (property) \u2014 None( (flame.PyTypeFX)arg1) -> list add_layer(...) (builtin) \u2014 add_layer( (PyTypeFX)arg1 [, (str)layer_type='Centre']) -> object : append_type_setup(...) (builtin) \u2014 append_type_setup( (PyTypeFX)arg1, (str)file_name) -> bool :","title":"Methods"},{"location":"api/flame/#class-pytypelayer","text":"Object representing a Type Layer.","title":"class PyTypeLayer"},{"location":"api/flame/#methods_63","text":"type(...) (property) \u2014 None( (flame.PyTypeLayer)arg1) -> object","title":"Methods"},{"location":"api/flame/#class-pytypenode","text":"Object representing a Type node.","title":"class PyTypeNode"},{"location":"api/flame/#methods_64","text":"layers(...) (property) \u2014 None( (flame.PyTypeNode)arg1) -> list add_layer(...) (builtin) \u2014 add_layer( (PyTypeNode)arg1 [, (str)layer_type='Centre']) -> object : append_type_setup(...) (builtin) \u2014 append_type_setup( (PyTypeNode)arg1, (str)file_name) -> bool :","title":"Methods"},{"location":"api/flame/#class-pyuser","text":"Object representing a User.","title":"class PyUser"},{"location":"api/flame/#methods_65","text":"name(...) (property) \u2014 None( (flame.PyUser)arg1) -> str nickname(...) (property) \u2014 None( (flame.PyUser)arg1) -> str shortcuts_profile(...) (property) \u2014 None( (flame.PyUser)arg1) -> str","title":"Methods"},{"location":"api/flame/#class-pyusers","text":"Object representing the User manager.","title":"class PyUsers"},{"location":"api/flame/#methods_66","text":"current_user(...) (property) \u2014 None( (flame.PyUsers)arg1) -> object","title":"Methods"},{"location":"api/flame/#class-pyversion","text":"Object representing a Version.","title":"class PyVersion"},{"location":"api/flame/#methods_67","text":"tracks(...) (property) \u2014 None( (flame.PyVersion)arg1) -> list stereo(...) (property) \u2014 None( (flame.PyVersion)arg1) -> bool copy_to_media_panel(...) (builtin) \u2014 copy_to_media_panel( (PyVersion)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : create_track(...) (builtin) \u2014 create_track( (PyVersion)arg1 [, (int)track_index=-1 [, (bool)hdr=False]]) -> object : import_DolbyVision_xml(...) (builtin) \u2014 import_DolbyVision_xml( (PyVersion)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)track_index=-1]]) -> object :","title":"Methods"},{"location":"api/flame/#class-pyworkspace","text":"Object representing a Workspace.","title":"class PyWorkspace"},{"location":"api/flame/#methods_68","text":"desktop(...) (property) \u2014 None( (flame.PyWorkspace)arg1) -> object libraries(...) (property) \u2014 None( (flame.PyWorkspace)arg1) -> list create_library(...) (builtin) \u2014 create_library( (PyWorkspace)arg1, (str)name) -> object : replace_desktop(...) (builtin) \u2014 replace_desktop( (PyWorkspace)arg1, (PyDesktop)desktop) -> bool : set_desktop_reels(...) (builtin) \u2014 set_desktop_reels( (PyWorkspace)arg1 [, (object)group=None]) -> bool : set_freeform(...) (builtin) \u2014 set_freeform( (PyWorkspace)arg1 [, (object)reel=None]) -> bool :","title":"Methods"},{"location":"api/flame/#class-pywritefilenode","text":"Class derived from PyRenderNode. This class represents a WriteFile node.","title":"class PyWriteFileNode"},{"location":"api/flame/#methods_69","text":"get_resolved_media_path(...) (builtin) \u2014 get_resolved_media_path( (PyWriteFileNode)arg1 [, (bool)show_extension=True [, (bool)translate_path=True [, (object)frame=None]]]) -> object :","title":"Methods"},{"location":"api/flame/#functions","text":"clear_graphics_memory \u2014 clear_graphics_memory(...) \u2014 clear_graphics_memory() -> None : clear_unreferenced_cache \u2014 clear_unreferenced_cache(...) \u2014 clear_unreferenced_cache([ (bool)all_projects=False]) -> None : delete \u2014 delete(...) \u2014 delete( (PyFlameObject)object [, (bool)confirm=True]) -> bool : duplicate \u2014 duplicate(...) \u2014 duplicate( (PyFlameObject)object [, (bool)keep_node_connections=False]) -> object : duplicate_many \u2014 duplicate_many(...) \u2014 duplicate_many( (list)object_list [, (bool)keep_node_connections=False]) -> list : execute_command \u2014 execute_command(...) \u2014 execute_command( (str)command [, (bool)blocking=True [, (bool)shell=False [, (bool)capture_stdout=False [, (bool)capture_stderr=False]]]]) -> tuple : execute_shortcut \u2014 execute_shortcut(...) \u2014 execute_shortcut( (str)description [, (bool)update_list=True]) -> bool : exit \u2014 exit(...) \u2014 exit() -> None : find_by_name \u2014 find_by_name(...) \u2014 find_by_name( (str)name [, (object)parent=None]) -> list : find_by_uid \u2014 find_by_uid(...) \u2014 find_by_uid( (str)uid) -> object : find_by_wiretap_node_id \u2014 find_by_wiretap_node_id(...) \u2014 find_by_wiretap_node_id( (str)node_id) -> object : flush_graphics_memory \u2014 flush_graphics_memory(...) \u2014 flush_graphics_memory() -> None : get_current_tab \u2014 get_current_tab(...) \u2014 get_current_tab() -> str : get_home_directory \u2014 get_home_directory(...) \u2014 get_home_directory() -> str : get_init_cfg_path \u2014 get_init_cfg_path(...) \u2014 get_init_cfg_path() -> str : get_version \u2014 get_version(...) \u2014 get_version() -> str : get_version_major \u2014 get_version_major(...) \u2014 get_version_major() -> str : get_version_minor \u2014 get_version_minor(...) \u2014 get_version_minor() -> str : get_version_patch \u2014 get_version_patch(...) \u2014 get_version_patch() -> str : get_version_stamp \u2014 get_version_stamp(...) \u2014 get_version_stamp() -> str : go_to \u2014 go_to(...) \u2014 go_to( (str)tab) -> bool : import_clips \u2014 import_clips(...) \u2014 import_clips( (object)path [, (object)destination=None]) -> list : schedule_idle_event \u2014 schedule_idle_event(...) \u2014 schedule_idle_event( (object)function [, (int)delay=0]) -> None : set_current_tab \u2014 set_current_tab(...) \u2014 set_current_tab( (str)arg1) -> bool : set_render_option \u2014 set_render_option(...) \u2014 set_render_option( (str)render_option [, (str)render_context='']) -> bool :","title":"Functions"},{"location":"api/flame/#constants-attributes","text":"batch browser media_panel mediahub messages project projects timeline users","title":"Constants / Attributes"},{"location":"api/classes/","text":"Classes PyActionFamilyNode PyActionNode PyArchiveEntry PyAttribute PyAudioTrack PyBatch PyBatchIteration PyBrowser PyClip PyClipNode PyClrMgmtNode PyCoCameraAnalysis PyCoCompass PyCoNode PyColourMgtTimelineFX PyCompassNode PyDesktop PyExporter PyFlameObject PyFolder PyGMaskTracerNode PyHDRNode PyHDRTimelineFX PyImageNode PyLensDistortionNode PyLibrary PyMarker PyMediaHub PyMediaHubFilesEntry PyMediaHubFilesFolder PyMediaHubFilesTab PyMediaHubFilesTabOptions PyMediaHubProjectsEntry PyMediaHubProjectsFolder PyMediaHubTab PyMediaPanel PyMessages PyMetadataNode PyMetadataTimelineFX PyMetadataValue PyMorphNode PyNode PyOFXNode PyPaintNode PyProject PyProjectSelector PyReadFileNode PyReel PyReelGroup PyRenderNode PyResolution PySearch PySegment PySequence PySequenceGroup PySubtitleTrack PyTime PyTimeline PyTimelineFX PyTimewarpNode PyTimewarpTimelineFX PyTrack PyTransition PyTypeFX PyTypeLayer PyTypeNode PyUser PyUsers PyVersion PyWorkspace PyWriteFileNode","title":"Classes"},{"location":"api/classes/#classes","text":"PyActionFamilyNode PyActionNode PyArchiveEntry PyAttribute PyAudioTrack PyBatch PyBatchIteration PyBrowser PyClip PyClipNode PyClrMgmtNode PyCoCameraAnalysis PyCoCompass PyCoNode PyColourMgtTimelineFX PyCompassNode PyDesktop PyExporter PyFlameObject PyFolder PyGMaskTracerNode PyHDRNode PyHDRTimelineFX PyImageNode PyLensDistortionNode PyLibrary PyMarker PyMediaHub PyMediaHubFilesEntry PyMediaHubFilesFolder PyMediaHubFilesTab PyMediaHubFilesTabOptions PyMediaHubProjectsEntry PyMediaHubProjectsFolder PyMediaHubTab PyMediaPanel PyMessages PyMetadataNode PyMetadataTimelineFX PyMetadataValue PyMorphNode PyNode PyOFXNode PyPaintNode PyProject PyProjectSelector PyReadFileNode PyReel PyReelGroup PyRenderNode PyResolution PySearch PySegment PySequence PySequenceGroup PySubtitleTrack PyTime PyTimeline PyTimelineFX PyTimewarpNode PyTimewarpTimelineFX PyTrack PyTransition PyTypeFX PyTypeLayer PyTypeNode PyUser PyUsers PyVersion PyWorkspace PyWriteFileNode","title":"Classes"},{"location":"api/classes/PyActionFamilyNode/","text":"Class: PyActionFamilyNode Module : flame Class derived from PyNode. Represents an Action Family node object. Methods Properties node_types(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list nodes(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list cursor_position(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> tuple None( (flame.PyActionFamilyNode)arg1) -> tuple all_tabs(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list left_tabs(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list right_tabs(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list media_layers(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list Built-in methods create_node(...) \u2014 create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic. Keyword argument: file_path -- Required by nodes that load an asset, such as Matchbox. input_colour_space -- Optional for nodes that load external media, such as IBL. organize(...) \u2014 organize( (PyActionFamilyNode)arg1) -> bool : organize( (PyActionFamilyNode)arg1) -> bool : Clean up the Action/Image/GMaskTracer schematic. get_node(...) \u2014 get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : Get a node by node name. Doesn't select it in the UI. connect_nodes(...) \u2014 connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Connect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) disconnect_nodes(...) \u2014 disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Disconnect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) clear_schematic(...) \u2014 clear_schematic( (PyActionFamilyNode)arg1) -> bool : clear_schematic( (PyActionFamilyNode)arg1) -> bool : Clear the Action/Image/GMaskTracer schematic of all nodes. encompass_nodes(...) \u2014 encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : Create a compass including the node list given as argument Keyword argument: node_list -- a list of nodes (either string or node objects) output_type -- the created compass node","title":"Class: PyActionFamilyNode"},{"location":"api/classes/PyActionFamilyNode/#class-pyactionfamilynode","text":"Module : flame Class derived from PyNode. Represents an Action Family node object.","title":"Class: PyActionFamilyNode"},{"location":"api/classes/PyActionFamilyNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyActionFamilyNode/#properties","text":"node_types(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list nodes(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list cursor_position(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> tuple None( (flame.PyActionFamilyNode)arg1) -> tuple all_tabs(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list left_tabs(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list right_tabs(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list media_layers(...) \u2014 None( (flame.PyActionFamilyNode)arg1) -> list None( (flame.PyActionFamilyNode)arg1) -> list","title":"Properties"},{"location":"api/classes/PyActionFamilyNode/#built-in-methods","text":"create_node(...) \u2014 create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object : Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic. Keyword argument: file_path -- Required by nodes that load an asset, such as Matchbox. input_colour_space -- Optional for nodes that load external media, such as IBL. organize(...) \u2014 organize( (PyActionFamilyNode)arg1) -> bool : organize( (PyActionFamilyNode)arg1) -> bool : Clean up the Action/Image/GMaskTracer schematic. get_node(...) \u2014 get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object : Get a node by node name. Doesn't select it in the UI. connect_nodes(...) \u2014 connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Connect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) disconnect_nodes(...) \u2014 disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool : Disconnect two nodes in the Action/Image/GMaskTracer schematic. Keyword argument: type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) clear_schematic(...) \u2014 clear_schematic( (PyActionFamilyNode)arg1) -> bool : clear_schematic( (PyActionFamilyNode)arg1) -> bool : Clear the Action/Image/GMaskTracer schematic of all nodes. encompass_nodes(...) \u2014 encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object : Create a compass including the node list given as argument Keyword argument: node_list -- a list of nodes (either string or node objects) output_type -- the created compass node","title":"Built-in methods"},{"location":"api/classes/PyActionNode/","text":"Class: PyActionNode Module : flame Class derived from PyActionFamilyNode. Represents an Action node object. Methods Properties media_nodes(...) \u2014 None( (flame.PyActionNode)arg1) -> list None( (flame.PyActionNode)arg1) -> list output_types(...) \u2014 None( (flame.PyActionNode)arg1) -> list None( (flame.PyActionNode)arg1) -> list Built-in methods add_media(...) \u2014 add_media( (PyActionFamilyNode)arg1) -> object : add_media( (PyActionFamilyNode)arg1) -> object : Add a Media layer to the Batch Action node. Also instantiates a matching Surface node (and Axis) in the Action node schematic. import_fbx(...) \u2014 import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : Import an FBX file into the Action schematic using the Action Objects mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. export_fbx(...) \u2014 export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : Export Action nodes to an FBX file. Keyword argument: file_path -- Path to the output FBX file. Mandatory. read_fbx(...) \u2014 read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : Import an FBX file into the Action schematic using the Read File mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. import_abc(...) \u2014 import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : Import an Alembic (ABC) file into the Action schematic using the Action Objects mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. read_abc(...) \u2014 read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : Import an Alembic (ABC) file into the Action schematic using the Read File mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. import_psd(...) \u2014 import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : Import a PSD file into the Action schematic. Keyword arguments: file_path -- Path to the PSD file. Mandatory. input_colour_space -- The colour space used as input. Optional. enable_output(...) \u2014 enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Enable the render output_type for the Action node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectoars Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth) disable_output(...) \u2014 disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Disable the render output_type for the Action node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectors Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)","title":"Class: PyActionNode"},{"location":"api/classes/PyActionNode/#class-pyactionnode","text":"Module : flame Class derived from PyActionFamilyNode. Represents an Action node object.","title":"Class: PyActionNode"},{"location":"api/classes/PyActionNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyActionNode/#properties","text":"media_nodes(...) \u2014 None( (flame.PyActionNode)arg1) -> list None( (flame.PyActionNode)arg1) -> list output_types(...) \u2014 None( (flame.PyActionNode)arg1) -> list None( (flame.PyActionNode)arg1) -> list","title":"Properties"},{"location":"api/classes/PyActionNode/#built-in-methods","text":"add_media(...) \u2014 add_media( (PyActionFamilyNode)arg1) -> object : add_media( (PyActionFamilyNode)arg1) -> object : Add a Media layer to the Batch Action node. Also instantiates a matching Surface node (and Axis) in the Action node schematic. import_fbx(...) \u2014 import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : Import an FBX file into the Action schematic using the Action Objects mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. export_fbx(...) \u2014 export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : Export Action nodes to an FBX file. Keyword argument: file_path -- Path to the output FBX file. Mandatory. read_fbx(...) \u2014 read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : Import an FBX file into the Action schematic using the Read File mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. import_abc(...) \u2014 import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : Import an Alembic (ABC) file into the Action schematic using the Action Objects mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. read_abc(...) \u2014 read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : Import an Alembic (ABC) file into the Action schematic using the Read File mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. import_psd(...) \u2014 import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : Import a PSD file into the Action schematic. Keyword arguments: file_path -- Path to the PSD file. Mandatory. input_colour_space -- The colour space used as input. Optional. enable_output(...) \u2014 enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Enable the render output_type for the Action node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectoars Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth) disable_output(...) \u2014 disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Disable the render output_type for the Action node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectors Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)","title":"Built-in methods"},{"location":"api/classes/PyArchiveEntry/","text":"Class: PyArchiveEntry Module : flame Class derived from PyFlameObject. Base class for any object displayed in the Media Panel. Methods Built-in methods get_wiretap_storage_id(...) \u2014 get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. get_wiretap_node_id(...) \u2014 get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. commit(...) \u2014 commit( (PyArchiveEntry)arg1) -> None : commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. clear_colour(...) \u2014 clear_colour( (PyArchiveEntry)arg1) -> None : clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"Class: PyArchiveEntry"},{"location":"api/classes/PyArchiveEntry/#class-pyarchiveentry","text":"Module : flame Class derived from PyFlameObject. Base class for any object displayed in the Media Panel.","title":"Class: PyArchiveEntry"},{"location":"api/classes/PyArchiveEntry/#methods","text":"","title":"Methods"},{"location":"api/classes/PyArchiveEntry/#built-in-methods","text":"get_wiretap_storage_id(...) \u2014 get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel. get_wiretap_node_id(...) \u2014 get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : get_wiretap_node_id( (PyArchiveEntry)arg1) -> str : Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel. commit(...) \u2014 commit( (PyArchiveEntry)arg1) -> None : commit( (PyArchiveEntry)arg1) -> None : Commit to disk the Media Panel object or its closest container possible. clear_colour(...) \u2014 clear_colour( (PyArchiveEntry)arg1) -> None : clear_colour( (PyArchiveEntry)arg1) -> None : Clear the colour of an object in the Media Panel.","title":"Built-in methods"},{"location":"api/classes/PyAttribute/","text":"Class: PyAttribute Module : flame Methods Properties values(...) \u2014 None( (flame.PyAttribute)arg1) -> object None( (flame.PyAttribute)arg1) -> object Built-in methods set_value(...) \u2014 set_value( (PyAttribute)arg1, (object)arg2) -> bool : set_value( (PyAttribute)arg1, (object)arg2) -> bool : Set the value of an attribute. get_value(...) \u2014 get_value( (PyAttribute)arg1) -> object : get_value( (PyAttribute)arg1) -> object : Get the value of an attribute.","title":"Class: PyAttribute"},{"location":"api/classes/PyAttribute/#class-pyattribute","text":"Module : flame","title":"Class: PyAttribute"},{"location":"api/classes/PyAttribute/#methods","text":"","title":"Methods"},{"location":"api/classes/PyAttribute/#properties","text":"values(...) \u2014 None( (flame.PyAttribute)arg1) -> object None( (flame.PyAttribute)arg1) -> object","title":"Properties"},{"location":"api/classes/PyAttribute/#built-in-methods","text":"set_value(...) \u2014 set_value( (PyAttribute)arg1, (object)arg2) -> bool : set_value( (PyAttribute)arg1, (object)arg2) -> bool : Set the value of an attribute. get_value(...) \u2014 get_value( (PyAttribute)arg1) -> object : get_value( (PyAttribute)arg1) -> object : Get the value of an attribute.","title":"Built-in methods"},{"location":"api/classes/PyAudioTrack/","text":"Class: PyAudioTrack Module : flame Object representing an Audio Track. Methods Properties channels(...) \u2014 None( (flame.PyAudioTrack)arg1) -> list None( (flame.PyAudioTrack)arg1) -> list stereo(...) \u2014 None( (flame.PyAudioTrack)arg1) -> bool None( (flame.PyAudioTrack)arg1) -> bool Built-in methods copy_to_media_panel(...) \u2014 copy_to_media_panel( (PyAudioTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : copy_to_media_panel( (PyAudioTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject.","title":"Class: PyAudioTrack"},{"location":"api/classes/PyAudioTrack/#class-pyaudiotrack","text":"Module : flame Object representing an Audio Track.","title":"Class: PyAudioTrack"},{"location":"api/classes/PyAudioTrack/#methods","text":"","title":"Methods"},{"location":"api/classes/PyAudioTrack/#properties","text":"channels(...) \u2014 None( (flame.PyAudioTrack)arg1) -> list None( (flame.PyAudioTrack)arg1) -> list stereo(...) \u2014 None( (flame.PyAudioTrack)arg1) -> bool None( (flame.PyAudioTrack)arg1) -> bool","title":"Properties"},{"location":"api/classes/PyAudioTrack/#built-in-methods","text":"copy_to_media_panel(...) \u2014 copy_to_media_panel( (PyAudioTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : copy_to_media_panel( (PyAudioTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject.","title":"Built-in methods"},{"location":"api/classes/PyBatch/","text":"Class: PyBatch Module : flame Class derived from PyFlameObject. This class represents a Batch Group. Methods Properties nodes(...) \u2014 None( (flame.PyBatch)arg1) -> list None( (flame.PyBatch)arg1) -> list node_types(...) \u2014 None( (flame.PyBatch)arg1) -> list None( (flame.PyBatch)arg1) -> list reels(...) \u2014 None( (flame.PyBatch)arg1) -> list None( (flame.PyBatch)arg1) -> list shelf_reels(...) \u2014 None( (flame.PyBatch)arg1) -> list None( (flame.PyBatch)arg1) -> list batch_iterations(...) \u2014 None( (flame.PyBatch)arg1) -> list None( (flame.PyBatch)arg1) -> list current_iteration(...) \u2014 None( (flame.PyBatch)arg1) -> object None( (flame.PyBatch)arg1) -> object contexts(...) \u2014 None( (flame.PyBatch)arg1) -> dict None( (flame.PyBatch)arg1) -> dict cursor_position(...) \u2014 None( (flame.PyBatch)arg1) -> tuple None( (flame.PyBatch)arg1) -> tuple opened(...) \u2014 None( (flame.PyBatch)arg1) -> bool None( (flame.PyBatch)arg1) -> bool current_iteration_number(...) \u2014 None( (flame.PyBatch)arg1) -> int None( (flame.PyBatch)arg1) -> int Built-in methods get_node(...) \u2014 get_node( (PyBatch)arg1, (str)node_name) -> object : get_node( (PyBatch)arg1, (str)node_name) -> object : Return a Batch node object with a name matching the parameter. Every node in a Batch schematic has a unique name: no duplicates allowed. Keyword argument: node_name -- Node name. create_node(...) \u2014 create_node( (PyBatch)arg1, (str)node_type [, (str)file_path='']) -> object : create_node( (PyBatch)arg1, (str)node_type [, (str)file_path='']) -> object : Create a Batch node object in the Batch schematic. Keyword argument: node_type -- Must be a value from the PyBatch.node_types or the name of a node in the User, Project, or Shared bin. connect_nodes(...) \u2014 connect_nodes( (PyBatch)arg1, (PyNode)output_node, (str)output_socket_name='Default', (PyNode)input_node [, (str)input_socket_name='Default']) -> bool : connect_nodes( (PyBatch)arg1, (PyNode)output_node, (str)output_socket_name='Default', (PyNode)input_node [, (str)input_socket_name='Default']) -> bool : Connect two nodes in the Batch schematic. Keyword arguments: output_node -- The Batch node object, the origin of the connection. output_socket_name -- The name of the output socket where the connector starts; use Default to use the first output socket, usually Result . input_node -- The child Batch node object, the target of the connection. input_socket_name -- The name of the input socket where the connector ends; use Default to use the first input socket, usually Front . Using Default on an Action node connects to the Background socket. To connect to an Action media node, use .media_nodes[]. disconnect_node(...) \u2014 disconnect_node( (PyBatch)arg1, (PyNode)node [, (str)input_socket_name='']) -> bool : disconnect_node( (PyBatch)arg1, (PyNode)node [, (str)input_socket_name='']) -> bool : Disconnect the input links of a given node, given an input socket. Keyword arguments: node -- The Batch node object, the origin of the connection. input_socket_name -- The name of the input socket to disconnect. mimic_link(...) \u2014 mimic_link( (PyBatch)arg1, (PyNode)leader_node, (PyNode)follower_node) -> bool : mimic_link( (PyBatch)arg1, (PyNode)leader_node, (PyNode)follower_node) -> bool : Create a Mimic Link between two Batch nodes. They must be of the same node_type. Keyword arguments: leader_node -- The node being mimicked. follower_node -- The node doing the mimicking. clear_context(...) \u2014 clear_context( (PyBatch)arg1, (int)index) -> bool : clear_context( (PyBatch)arg1, (int)index) -> bool : Clear a specific Context view in the Batch Group. clear_all_contexts(...) \u2014 clear_all_contexts( (PyBatch)arg1) -> bool : clear_all_contexts( (PyBatch)arg1) -> bool : Clear all registered Context views in the Batch Group. organize(...) \u2014 organize( (PyBatch)arg1) -> bool : organize( (PyBatch)arg1) -> bool : Clean up the nodes layout in the Batch schematic. frame_selected(...) \u2014 frame_selected( (PyBatch)arg1) -> bool : frame_selected( (PyBatch)arg1) -> bool : Set the Batch schematic view to frame the nodes selected in the Batch schematic. frame_all(...) \u2014 frame_all( (PyBatch)arg1) -> bool : frame_all( (PyBatch)arg1) -> bool : Set the Batch schematic view to frame all the nodes in the Batch schematic. import_clip(...) \u2014 import_clip( (PyBatch)arg1, (str)file_path, (str)reel_name) -> object : import_clip( (PyBatch)arg1, (str)file_path, (str)reel_name) -> object : Import a clip using the Import node, and create a Clip node. Keyword arguments: file_path -- The path to the media can be: A path to a single media file. A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). A pattern to media files (ie \"/dir/name_v{version}.{frame}.{extension}\").reel_name -- The name of the destination Schematic Reel. import_clips(...) \u2014 import_clips( (PyBatch)arg1, (object)file_paths, (str)reel_name) -> object : import_clips( (PyBatch)arg1, (object)file_paths, (str)reel_name) -> object : Import clips using the Import node, and then create Clip nodes in the Schematic Reel. Keyword arguments: file_paths -- A path, or a list of paths, to the media that can be: A path to a single media file. A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). A pattern to media files (ie \"/dir/name_v{version}.{frame}.{extension}\").reel_name -- The name of the destination Schematic Reel. save_setup(...) \u2014 save_setup( (PyBatch)arg1, (str)setup_path) -> bool : save_setup( (PyBatch)arg1, (str)setup_path) -> bool : Save the Batch Group setup to disk. Includes media paths for clip node object, but not the media files themselves. Keyword argument: setup_path -- The filepath includes the filename. File extension must be .batch. append_setup(...) \u2014 append_setup( (PyBatch)arg1, (str)setup_path [, (bool)confirm=True]) -> bool : append_setup( (PyBatch)arg1, (str)setup_path [, (bool)confirm=True]) -> bool : Append a Batch setup file to the existing Batch setup. Keywords arguments: setup_path -- A path and a filename must be defined as arguments. confirm -- Set to True (default) to display a dialogue box in case of set_viewport_layout(...) \u2014 set_viewport_layout( (PyBatch)arg1, (object)num_views) -> bool : set_viewport_layout( (PyBatch)arg1, (object)num_views) -> bool : Set the viewport layout for Batch. Keyword argument: num_views -- The layout used. (1-Up, 2-Up, 3-Up, 3-Up Split Top, 3-Up Split Left, 3-Up Split Right, 3-Up Split Bottom, 4-Up Split, 4-Up) create_batch_group(...) \u2014 create_batch_group( (PyBatch)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : create_batch_group( (PyBatch)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : Create a new Batch Group object in the Desktop catalogue. Keyword arguments: name -- Name of the Batch Group. nb_reels -- Number of reels created. reels overrides nb_reels . nb_shelf_reels -- Number of shelf reels. The first shelf reel created is named Batch Renders. shelf_reels ovverides nb_shelf_reels . reels -- A list of reel names. Overrides nb_reels . shelf_reels -- A list of shelf reel names. Overrides nb_shelf_reels . start_frame -- The Batch Group's start frame. No timecodes, only a frame value. duration -- The number of frames. Sets the Duration field in the Batch UI. Will be set to the first clip duration when not specified. encompass_nodes(...) \u2014 encompass_nodes( (PyBatch)arg1, (list)nodes) -> object : encompass_nodes( (PyBatch)arg1, (list)nodes) -> object : Create a Compass around a list of nodes in the Batch schematic. Keyword argument: nodes -- List of strings of node names. select_nodes(...) \u2014 select_nodes( (PyBatch)arg1, (object)nodes) -> bool : select_nodes( (PyBatch)arg1, (object)nodes) -> bool : Select nodes. Keyword argument: nodes -- A list of the names of Batch node objects. open(...) \u2014 open( (PyBatch)arg1) -> bool : open( (PyBatch)arg1) -> bool : Open the Batch Group and display it in the Batch view. close(...) \u2014 close( (PyBatch)arg1) -> bool : close( (PyBatch)arg1) -> bool : Close the Batch Group. You cannot close the Batch Group currently selected. Closing a Batch Group frees up the application it occupies when open. The size of the used memory is significant if in Batch Group schematic hosts many Action nodes with textures or 3D geoms. clear(...) \u2014 clear( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : clear( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : Clear the Batch Group. save(...) \u2014 save( (PyBatch)arg1) -> object : save( (PyBatch)arg1) -> object : Save the Batch Group to the location defined by PyDesktop.destination. append_to_setup(...) \u2014 append_to_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : append_to_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : Append a Batch Iteration object to the Batch Group's setup. append_to_batch(...) \u2014 append_to_batch( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : append_to_batch( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : Append a Batch Iteration object to the current Batch Group. A duplicate Batch Iteration object is renamed to the next available vDD . Batch Iteration objects are displayed in the Iterations folder. Iterations folder is a UI construction, not accessible directly. open_as_batch_group(...) \u2014 open_as_batch_group( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : open_as_batch_group( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : Open a Batch Group as a new Batch Group, adding it to PyDesktop.batch_groups. Can only be called from a Library. replace_setup(...) \u2014 replace_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration [, (bool)confirm=True]) -> bool : replace_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration [, (bool)confirm=True]) -> bool : Replace the Batch Group setup with the specified Batch Iteration. Cannot be called on the Batch Group currently selected and displayed in the Batch view. create_reel(...) \u2014 create_reel( (PyBatch)arg1, (str)name) -> object : create_reel( (PyBatch)arg1, (str)name) -> object : Create a new Schematic Reel in the Batch Gtroup. create_shelf_reel(...) \u2014 create_shelf_reel( (PyBatch)arg1, (str)name) -> object : create_shelf_reel( (PyBatch)arg1, (str)name) -> object : Create a new Shelf Reel in the Batch Group. clear_colour(...) \u2014 clear_colour( (PyBatch)arg1) -> None : clear_colour( (PyBatch)arg1) -> None : Clear the colour of an object in the Media Panel. go_to(...) \u2014 go_to( (PyBatch)arg1) -> bool : go_to( (PyBatch)arg1) -> bool : Display and set the Batch tab as the active environment. load_setup(...) \u2014 load_setup( (PyBatch)arg1, (str)setup_path) -> bool : load_setup( (PyBatch)arg1, (str)setup_path) -> bool : Load a Batch setup from disk and replace the current Batch Group's setup. Keyword argument: setup_path -- Filepath + Batch Setup filename. clear_setup(...) \u2014 clear_setup( (PyBatch)arg1) -> bool : clear_setup( (PyBatch)arg1) -> bool : Clear the Batch Group's setup. iterate(...) \u2014 iterate( (PyBatch)arg1 [, (int)index=-1]) -> object : iterate( (PyBatch)arg1 [, (int)index=-1]) -> object : Iterate the current Batch Setup, creating a new iteration named BatchSetupName_X, where X is the Batch Iteration's index, and starts at 001. Keyword argument: index -- Specifies the iteration's index. If none is specified, the iteration is assigned the next available index (max index + 1). If the index matches that of an existing Batch Iteration, its overwrites the iteration without warning. save_current_iteration(...) \u2014 save_current_iteration( (PyBatch)arg1) -> object : save_current_iteration( (PyBatch)arg1) -> object : Save the current Batch Group setup to the location defined by PyDesktop.destination. render(...) \u2014 render( (PyBatch)arg1 [, (str)render_option='Foreground' [, (bool)generate_proxies=False [, (bool)include_history=False]]]) -> bool : render( (PyBatch)arg1 [, (str)render_option='Foreground' [, (bool)generate_proxies=False [, (bool)include_history=False]]]) -> bool : Trigger the rendering of the Batch Group setup. Every active Render and Write File nodes render. If specified render_option is not supported by the workstation, returns an error. Keyword arguments: render_option -- Defines the rendering method used. (Foreground, Background Reactor, Burn) generate_proxies -- Set to True to render at proxy resolution. (Default: False) include_history -- Set to True to create History with the rendering. (Default:False)","title":"Class: PyBatch"},{"location":"api/classes/PyBatch/#class-pybatch","text":"Module : flame Class derived from PyFlameObject. This class represents a Batch Group.","title":"Class: PyBatch"},{"location":"api/classes/PyBatch/#methods","text":"","title":"Methods"},{"location":"api/classes/PyBatch/#properties","text":"nodes(...) \u2014 None( (flame.PyBatch)arg1) -> list None( (flame.PyBatch)arg1) -> list node_types(...) \u2014 None( (flame.PyBatch)arg1) -> list None( (flame.PyBatch)arg1) -> list reels(...) \u2014 None( (flame.PyBatch)arg1) -> list None( (flame.PyBatch)arg1) -> list shelf_reels(...) \u2014 None( (flame.PyBatch)arg1) -> list None( (flame.PyBatch)arg1) -> list batch_iterations(...) \u2014 None( (flame.PyBatch)arg1) -> list None( (flame.PyBatch)arg1) -> list current_iteration(...) \u2014 None( (flame.PyBatch)arg1) -> object None( (flame.PyBatch)arg1) -> object contexts(...) \u2014 None( (flame.PyBatch)arg1) -> dict None( (flame.PyBatch)arg1) -> dict cursor_position(...) \u2014 None( (flame.PyBatch)arg1) -> tuple None( (flame.PyBatch)arg1) -> tuple opened(...) \u2014 None( (flame.PyBatch)arg1) -> bool None( (flame.PyBatch)arg1) -> bool current_iteration_number(...) \u2014 None( (flame.PyBatch)arg1) -> int None( (flame.PyBatch)arg1) -> int","title":"Properties"},{"location":"api/classes/PyBatch/#built-in-methods","text":"get_node(...) \u2014 get_node( (PyBatch)arg1, (str)node_name) -> object : get_node( (PyBatch)arg1, (str)node_name) -> object : Return a Batch node object with a name matching the parameter. Every node in a Batch schematic has a unique name: no duplicates allowed. Keyword argument: node_name -- Node name. create_node(...) \u2014 create_node( (PyBatch)arg1, (str)node_type [, (str)file_path='']) -> object : create_node( (PyBatch)arg1, (str)node_type [, (str)file_path='']) -> object : Create a Batch node object in the Batch schematic. Keyword argument: node_type -- Must be a value from the PyBatch.node_types or the name of a node in the User, Project, or Shared bin. connect_nodes(...) \u2014 connect_nodes( (PyBatch)arg1, (PyNode)output_node, (str)output_socket_name='Default', (PyNode)input_node [, (str)input_socket_name='Default']) -> bool : connect_nodes( (PyBatch)arg1, (PyNode)output_node, (str)output_socket_name='Default', (PyNode)input_node [, (str)input_socket_name='Default']) -> bool : Connect two nodes in the Batch schematic. Keyword arguments: output_node -- The Batch node object, the origin of the connection. output_socket_name -- The name of the output socket where the connector starts; use Default to use the first output socket, usually Result . input_node -- The child Batch node object, the target of the connection. input_socket_name -- The name of the input socket where the connector ends; use Default to use the first input socket, usually Front . Using Default on an Action node connects to the Background socket. To connect to an Action media node, use .media_nodes[]. disconnect_node(...) \u2014 disconnect_node( (PyBatch)arg1, (PyNode)node [, (str)input_socket_name='']) -> bool : disconnect_node( (PyBatch)arg1, (PyNode)node [, (str)input_socket_name='']) -> bool : Disconnect the input links of a given node, given an input socket. Keyword arguments: node -- The Batch node object, the origin of the connection. input_socket_name -- The name of the input socket to disconnect. mimic_link(...) \u2014 mimic_link( (PyBatch)arg1, (PyNode)leader_node, (PyNode)follower_node) -> bool : mimic_link( (PyBatch)arg1, (PyNode)leader_node, (PyNode)follower_node) -> bool : Create a Mimic Link between two Batch nodes. They must be of the same node_type. Keyword arguments: leader_node -- The node being mimicked. follower_node -- The node doing the mimicking. clear_context(...) \u2014 clear_context( (PyBatch)arg1, (int)index) -> bool : clear_context( (PyBatch)arg1, (int)index) -> bool : Clear a specific Context view in the Batch Group. clear_all_contexts(...) \u2014 clear_all_contexts( (PyBatch)arg1) -> bool : clear_all_contexts( (PyBatch)arg1) -> bool : Clear all registered Context views in the Batch Group. organize(...) \u2014 organize( (PyBatch)arg1) -> bool : organize( (PyBatch)arg1) -> bool : Clean up the nodes layout in the Batch schematic. frame_selected(...) \u2014 frame_selected( (PyBatch)arg1) -> bool : frame_selected( (PyBatch)arg1) -> bool : Set the Batch schematic view to frame the nodes selected in the Batch schematic. frame_all(...) \u2014 frame_all( (PyBatch)arg1) -> bool : frame_all( (PyBatch)arg1) -> bool : Set the Batch schematic view to frame all the nodes in the Batch schematic. import_clip(...) \u2014 import_clip( (PyBatch)arg1, (str)file_path, (str)reel_name) -> object : import_clip( (PyBatch)arg1, (str)file_path, (str)reel_name) -> object : Import a clip using the Import node, and create a Clip node. Keyword arguments: file_path -- The path to the media can be: A path to a single media file. A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). A pattern to media files (ie \"/dir/name_v{version}.{frame}.{extension}\").reel_name -- The name of the destination Schematic Reel. import_clips(...) \u2014 import_clips( (PyBatch)arg1, (object)file_paths, (str)reel_name) -> object : import_clips( (PyBatch)arg1, (object)file_paths, (str)reel_name) -> object : Import clips using the Import node, and then create Clip nodes in the Schematic Reel. Keyword arguments: file_paths -- A path, or a list of paths, to the media that can be: A path to a single media file. A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). A pattern to media files (ie \"/dir/name_v{version}.{frame}.{extension}\").reel_name -- The name of the destination Schematic Reel. save_setup(...) \u2014 save_setup( (PyBatch)arg1, (str)setup_path) -> bool : save_setup( (PyBatch)arg1, (str)setup_path) -> bool : Save the Batch Group setup to disk. Includes media paths for clip node object, but not the media files themselves. Keyword argument: setup_path -- The filepath includes the filename. File extension must be .batch. append_setup(...) \u2014 append_setup( (PyBatch)arg1, (str)setup_path [, (bool)confirm=True]) -> bool : append_setup( (PyBatch)arg1, (str)setup_path [, (bool)confirm=True]) -> bool : Append a Batch setup file to the existing Batch setup. Keywords arguments: setup_path -- A path and a filename must be defined as arguments. confirm -- Set to True (default) to display a dialogue box in case of set_viewport_layout(...) \u2014 set_viewport_layout( (PyBatch)arg1, (object)num_views) -> bool : set_viewport_layout( (PyBatch)arg1, (object)num_views) -> bool : Set the viewport layout for Batch. Keyword argument: num_views -- The layout used. (1-Up, 2-Up, 3-Up, 3-Up Split Top, 3-Up Split Left, 3-Up Split Right, 3-Up Split Bottom, 4-Up Split, 4-Up) create_batch_group(...) \u2014 create_batch_group( (PyBatch)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : create_batch_group( (PyBatch)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : Create a new Batch Group object in the Desktop catalogue. Keyword arguments: name -- Name of the Batch Group. nb_reels -- Number of reels created. reels overrides nb_reels . nb_shelf_reels -- Number of shelf reels. The first shelf reel created is named Batch Renders. shelf_reels ovverides nb_shelf_reels . reels -- A list of reel names. Overrides nb_reels . shelf_reels -- A list of shelf reel names. Overrides nb_shelf_reels . start_frame -- The Batch Group's start frame. No timecodes, only a frame value. duration -- The number of frames. Sets the Duration field in the Batch UI. Will be set to the first clip duration when not specified. encompass_nodes(...) \u2014 encompass_nodes( (PyBatch)arg1, (list)nodes) -> object : encompass_nodes( (PyBatch)arg1, (list)nodes) -> object : Create a Compass around a list of nodes in the Batch schematic. Keyword argument: nodes -- List of strings of node names. select_nodes(...) \u2014 select_nodes( (PyBatch)arg1, (object)nodes) -> bool : select_nodes( (PyBatch)arg1, (object)nodes) -> bool : Select nodes. Keyword argument: nodes -- A list of the names of Batch node objects. open(...) \u2014 open( (PyBatch)arg1) -> bool : open( (PyBatch)arg1) -> bool : Open the Batch Group and display it in the Batch view. close(...) \u2014 close( (PyBatch)arg1) -> bool : close( (PyBatch)arg1) -> bool : Close the Batch Group. You cannot close the Batch Group currently selected. Closing a Batch Group frees up the application it occupies when open. The size of the used memory is significant if in Batch Group schematic hosts many Action nodes with textures or 3D geoms. clear(...) \u2014 clear( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : clear( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : Clear the Batch Group. save(...) \u2014 save( (PyBatch)arg1) -> object : save( (PyBatch)arg1) -> object : Save the Batch Group to the location defined by PyDesktop.destination. append_to_setup(...) \u2014 append_to_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : append_to_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : Append a Batch Iteration object to the Batch Group's setup. append_to_batch(...) \u2014 append_to_batch( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : append_to_batch( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool : Append a Batch Iteration object to the current Batch Group. A duplicate Batch Iteration object is renamed to the next available vDD . Batch Iteration objects are displayed in the Iterations folder. Iterations folder is a UI construction, not accessible directly. open_as_batch_group(...) \u2014 open_as_batch_group( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : open_as_batch_group( (PyBatch)arg1 [, (bool)confirm=True]) -> bool : Open a Batch Group as a new Batch Group, adding it to PyDesktop.batch_groups. Can only be called from a Library. replace_setup(...) \u2014 replace_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration [, (bool)confirm=True]) -> bool : replace_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration [, (bool)confirm=True]) -> bool : Replace the Batch Group setup with the specified Batch Iteration. Cannot be called on the Batch Group currently selected and displayed in the Batch view. create_reel(...) \u2014 create_reel( (PyBatch)arg1, (str)name) -> object : create_reel( (PyBatch)arg1, (str)name) -> object : Create a new Schematic Reel in the Batch Gtroup. create_shelf_reel(...) \u2014 create_shelf_reel( (PyBatch)arg1, (str)name) -> object : create_shelf_reel( (PyBatch)arg1, (str)name) -> object : Create a new Shelf Reel in the Batch Group. clear_colour(...) \u2014 clear_colour( (PyBatch)arg1) -> None : clear_colour( (PyBatch)arg1) -> None : Clear the colour of an object in the Media Panel. go_to(...) \u2014 go_to( (PyBatch)arg1) -> bool : go_to( (PyBatch)arg1) -> bool : Display and set the Batch tab as the active environment. load_setup(...) \u2014 load_setup( (PyBatch)arg1, (str)setup_path) -> bool : load_setup( (PyBatch)arg1, (str)setup_path) -> bool : Load a Batch setup from disk and replace the current Batch Group's setup. Keyword argument: setup_path -- Filepath + Batch Setup filename. clear_setup(...) \u2014 clear_setup( (PyBatch)arg1) -> bool : clear_setup( (PyBatch)arg1) -> bool : Clear the Batch Group's setup. iterate(...) \u2014 iterate( (PyBatch)arg1 [, (int)index=-1]) -> object : iterate( (PyBatch)arg1 [, (int)index=-1]) -> object : Iterate the current Batch Setup, creating a new iteration named BatchSetupName_X, where X is the Batch Iteration's index, and starts at 001. Keyword argument: index -- Specifies the iteration's index. If none is specified, the iteration is assigned the next available index (max index + 1). If the index matches that of an existing Batch Iteration, its overwrites the iteration without warning. save_current_iteration(...) \u2014 save_current_iteration( (PyBatch)arg1) -> object : save_current_iteration( (PyBatch)arg1) -> object : Save the current Batch Group setup to the location defined by PyDesktop.destination. render(...) \u2014 render( (PyBatch)arg1 [, (str)render_option='Foreground' [, (bool)generate_proxies=False [, (bool)include_history=False]]]) -> bool : render( (PyBatch)arg1 [, (str)render_option='Foreground' [, (bool)generate_proxies=False [, (bool)include_history=False]]]) -> bool : Trigger the rendering of the Batch Group setup. Every active Render and Write File nodes render. If specified render_option is not supported by the workstation, returns an error. Keyword arguments: render_option -- Defines the rendering method used. (Foreground, Background Reactor, Burn) generate_proxies -- Set to True to render at proxy resolution. (Default: False) include_history -- Set to True to create History with the rendering. (Default:False)","title":"Built-in methods"},{"location":"api/classes/PyBatchIteration/","text":"Class: PyBatchIteration Module : flame Class derived from PyArchiveEntry. This class represents a Batch Iteration. Methods Properties iteration_number(...) \u2014 None( (flame.PyBatchIteration)arg1) -> int None( (flame.PyBatchIteration)arg1) -> int Built-in methods open_as_batch_group(...) \u2014 open_as_batch_group( (PyBatchIteration)arg1 [, (bool)confirm=True]) -> bool : open_as_batch_group( (PyBatchIteration)arg1 [, (bool)confirm=True]) -> bool : Open a Batch Iteration as a new Batch Group, adding it to PyDesktop.batch_groups. Can only be called from a Library.","title":"Class: PyBatchIteration"},{"location":"api/classes/PyBatchIteration/#class-pybatchiteration","text":"Module : flame Class derived from PyArchiveEntry. This class represents a Batch Iteration.","title":"Class: PyBatchIteration"},{"location":"api/classes/PyBatchIteration/#methods","text":"","title":"Methods"},{"location":"api/classes/PyBatchIteration/#properties","text":"iteration_number(...) \u2014 None( (flame.PyBatchIteration)arg1) -> int None( (flame.PyBatchIteration)arg1) -> int","title":"Properties"},{"location":"api/classes/PyBatchIteration/#built-in-methods","text":"open_as_batch_group(...) \u2014 open_as_batch_group( (PyBatchIteration)arg1 [, (bool)confirm=True]) -> bool : open_as_batch_group( (PyBatchIteration)arg1 [, (bool)confirm=True]) -> bool : Open a Batch Iteration as a new Batch Group, adding it to PyDesktop.batch_groups. Can only be called from a Library.","title":"Built-in methods"},{"location":"api/classes/PyBrowser/","text":"Class: PyBrowser Module : flame This class represents the file browser. Methods Properties selection(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object sequence_mode(...) \u2014 None( (flame.PyBrowser)arg1) -> bool None( (flame.PyBrowser)arg1) -> bool width(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object height(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object scaling_presets_value(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object bit_depth(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object frame_ratio(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object scan_mode(...) \u2014 None( (flame.PyBrowser)arg1) -> str None( (flame.PyBrowser)arg1) -> str colour_space(...) \u2014 None( (flame.PyBrowser)arg1) -> str None( (flame.PyBrowser)arg1) -> str resize_mode(...) \u2014 None( (flame.PyBrowser)arg1) -> str None( (flame.PyBrowser)arg1) -> str resize_filter(...) \u2014 None( (flame.PyBrowser)arg1) -> str None( (flame.PyBrowser)arg1) -> str resolution(...) \u2014 None( (flame.PyBrowser)arg1) -> str None( (flame.PyBrowser)arg1) -> str Built-in methods show(...) \u2014 show( (PyBrowser)arg1, (str)default_path [, (object)extension='' [, (bool)select_directory=False [, (bool)multi_selection=False [, (object)include_resolution=False [, (str)title='Load']]]]]) -> None : show( (PyBrowser)arg1, (str)default_path [, (object)extension='' [, (bool)select_directory=False [, (bool)multi_selection=False [, (object)include_resolution=False [, (str)title='Load']]]]]) -> None : Show the file browser.Keyword arguments: default_path -- Set the path. extension -- Set the extension filter. Can be a single extension or a list of extensions.Leave empty to see all files. select_directory -- Only show directories. multi_selection -- Allow the user to select multiple files. include_resolution -- Display the resolution controls. Possible values are False, True, or \"Full\". The Full mode includes the new adaptive and scaling presets modes. title -- Set the window title.","title":"Class: PyBrowser"},{"location":"api/classes/PyBrowser/#class-pybrowser","text":"Module : flame This class represents the file browser.","title":"Class: PyBrowser"},{"location":"api/classes/PyBrowser/#methods","text":"","title":"Methods"},{"location":"api/classes/PyBrowser/#properties","text":"selection(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object sequence_mode(...) \u2014 None( (flame.PyBrowser)arg1) -> bool None( (flame.PyBrowser)arg1) -> bool width(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object height(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object scaling_presets_value(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object bit_depth(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object frame_ratio(...) \u2014 None( (flame.PyBrowser)arg1) -> object None( (flame.PyBrowser)arg1) -> object scan_mode(...) \u2014 None( (flame.PyBrowser)arg1) -> str None( (flame.PyBrowser)arg1) -> str colour_space(...) \u2014 None( (flame.PyBrowser)arg1) -> str None( (flame.PyBrowser)arg1) -> str resize_mode(...) \u2014 None( (flame.PyBrowser)arg1) -> str None( (flame.PyBrowser)arg1) -> str resize_filter(...) \u2014 None( (flame.PyBrowser)arg1) -> str None( (flame.PyBrowser)arg1) -> str resolution(...) \u2014 None( (flame.PyBrowser)arg1) -> str None( (flame.PyBrowser)arg1) -> str","title":"Properties"},{"location":"api/classes/PyBrowser/#built-in-methods","text":"show(...) \u2014 show( (PyBrowser)arg1, (str)default_path [, (object)extension='' [, (bool)select_directory=False [, (bool)multi_selection=False [, (object)include_resolution=False [, (str)title='Load']]]]]) -> None : show( (PyBrowser)arg1, (str)default_path [, (object)extension='' [, (bool)select_directory=False [, (bool)multi_selection=False [, (object)include_resolution=False [, (str)title='Load']]]]]) -> None : Show the file browser.Keyword arguments: default_path -- Set the path. extension -- Set the extension filter. Can be a single extension or a list of extensions.Leave empty to see all files. select_directory -- Only show directories. multi_selection -- Allow the user to select multiple files. include_resolution -- Display the resolution controls. Possible values are False, True, or \"Full\". The Full mode includes the new adaptive and scaling presets modes. title -- Set the window title.","title":"Built-in methods"},{"location":"api/classes/PyClip/","text":"Class: PyClip Module : flame CLass derived from PyArchiveEntry. This class represents a Clip. Methods Properties frame_rate(...) \u2014 None( (flame.PyClip)arg1) -> object None( (flame.PyClip)arg1) -> object duration(...) \u2014 None( (flame.PyClip)arg1) -> object None( (flame.PyClip)arg1) -> object versions(...) \u2014 None( (flame.PyClip)arg1) -> list None( (flame.PyClip)arg1) -> list audio_tracks(...) \u2014 None( (flame.PyClip)arg1) -> list None( (flame.PyClip)arg1) -> list markers(...) \u2014 None( (flame.PyClip)arg1) -> list None( (flame.PyClip)arg1) -> list subtitles(...) \u2014 None( (flame.PyClip)arg1) -> list None( (flame.PyClip)arg1) -> list width(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int height(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int bit_depth(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int ratio(...) \u2014 None( (flame.PyClip)arg1) -> float None( (flame.PyClip)arg1) -> float scan_mode(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str colour_primaries(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int transfer_characteristics(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int matrix_coefficients(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int proxy_resolution(...) \u2014 None( (flame.PyClip)arg1) -> object None( (flame.PyClip)arg1) -> object has_deliverables(...) \u2014 None( (flame.PyClip)arg1) -> bool None( (flame.PyClip)arg1) -> bool has_history(...) \u2014 None( (flame.PyClip)arg1) -> bool None( (flame.PyClip)arg1) -> bool unlinked(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str creation_date(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str archive_date(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str archive_error(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str essence_uid(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str source_uid(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str original_source_uid(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str sample_rate(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str cached(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str start_frame(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int Built-in methods open_as_sequence(...) \u2014 open_as_sequence( (PyClip)arg1) -> object : open_as_sequence( (PyClip)arg1) -> object : Open the Clip as a Sequence. Mutates the PyClip object into a PySequence object. open_container(...) \u2014 open_container( (PyClip)arg1) -> bool : open_container( (PyClip)arg1) -> bool : Open the container timeline if the Clip is inside a container. close_container(...) \u2014 close_container( (PyClip)arg1) -> None : close_container( (PyClip)arg1) -> None : Close the container timeline if the Clip is inside a container. reformat(...) \u2014 reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None : reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None : Reformat the Clip to the specified format. Keywords arguments: width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. bit_depth -- Bit depth. (8, 10, 12, 16 or 32) scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) resize_mode -- Resize mode. (Letterbox, Crop Edges, Fill, Centre) create_marker(...) \u2014 create_marker( (PyClip)arg1, (object)location) -> object : create_marker( (PyClip)arg1, (object)location) -> object : Add a Marker to the Clip.Keyword argument: location -- The frame where the marker gets created. change_dominance(...) \u2014 change_dominance( (PyClip)arg1, (str)scan_mode) -> None : change_dominance( (PyClip)arg1, (str)scan_mode) -> None : Change the Clip's dominance. Changes only the clip's metadata. Keyword argument: scan_mode -- Field dominance. (P, F1, F2) cache_media(...) \u2014 cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Cache the Clip's linked media. Keyword argument: mode -- Determine the version to cache (currently selected or all versions). All Versions is only useful with to multi-version clips (Current, All Versions) flush_cache_media(...) \u2014 flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current)(Deprecated: use 'clear_cache_media' instead.) clear_cache_media(...) \u2014 clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current) render(...) \u2014 render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool : render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool : Trigger a render of the Clip The following attributes can be defined: render_mode, render_option, render_quality, effect_type, effect_caching_mode and include_handles. flush_renders(...) \u2014 flush_renders( (PyClip)arg1) -> None : flush_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders.(Deprecated: use 'clear_renders' instead.) clear_renders(...) \u2014 clear_renders( (PyClip)arg1) -> None : clear_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders. is_rendered(...) \u2014 is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool : is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool : Return if a Clip is rendered. The following attributes can be defined: top_only, render_quality. save(...) \u2014 save( (PyClip)arg1) -> bool : save( (PyClip)arg1) -> bool : Save the Clip to the defined save destination. cut(...) \u2014 cut( (PyClip)arg1, (PyTime)cut_time) -> None : cut( (PyClip)arg1, (PyTime)cut_time) -> None : Cut all tracks of the Clip. get_colour_space(...) \u2014 get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str : get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str : Return the colour space at the requested time. Use current_time when no time is supplied. change_start_frame(...) \u2014 change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : Modify the start frame of a source Clip. Keywords argument: start_frame -- New start frame of the clip. use_segment_connections -- Sync the start frame of connected segments. get_metadata(...) \u2014 get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : Return the metadata of the clip. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. time -- Must be a PyTime. If not specified, the current clip time is used.","title":"Class: PyClip"},{"location":"api/classes/PyClip/#class-pyclip","text":"Module : flame CLass derived from PyArchiveEntry. This class represents a Clip.","title":"Class: PyClip"},{"location":"api/classes/PyClip/#methods","text":"","title":"Methods"},{"location":"api/classes/PyClip/#properties","text":"frame_rate(...) \u2014 None( (flame.PyClip)arg1) -> object None( (flame.PyClip)arg1) -> object duration(...) \u2014 None( (flame.PyClip)arg1) -> object None( (flame.PyClip)arg1) -> object versions(...) \u2014 None( (flame.PyClip)arg1) -> list None( (flame.PyClip)arg1) -> list audio_tracks(...) \u2014 None( (flame.PyClip)arg1) -> list None( (flame.PyClip)arg1) -> list markers(...) \u2014 None( (flame.PyClip)arg1) -> list None( (flame.PyClip)arg1) -> list subtitles(...) \u2014 None( (flame.PyClip)arg1) -> list None( (flame.PyClip)arg1) -> list width(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int height(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int bit_depth(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int ratio(...) \u2014 None( (flame.PyClip)arg1) -> float None( (flame.PyClip)arg1) -> float scan_mode(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str colour_primaries(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int transfer_characteristics(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int matrix_coefficients(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int proxy_resolution(...) \u2014 None( (flame.PyClip)arg1) -> object None( (flame.PyClip)arg1) -> object has_deliverables(...) \u2014 None( (flame.PyClip)arg1) -> bool None( (flame.PyClip)arg1) -> bool has_history(...) \u2014 None( (flame.PyClip)arg1) -> bool None( (flame.PyClip)arg1) -> bool unlinked(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str creation_date(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str archive_date(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str archive_error(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str essence_uid(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str source_uid(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str original_source_uid(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str sample_rate(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str cached(...) \u2014 None( (flame.PyClip)arg1) -> str None( (flame.PyClip)arg1) -> str start_frame(...) \u2014 None( (flame.PyClip)arg1) -> int None( (flame.PyClip)arg1) -> int","title":"Properties"},{"location":"api/classes/PyClip/#built-in-methods","text":"open_as_sequence(...) \u2014 open_as_sequence( (PyClip)arg1) -> object : open_as_sequence( (PyClip)arg1) -> object : Open the Clip as a Sequence. Mutates the PyClip object into a PySequence object. open_container(...) \u2014 open_container( (PyClip)arg1) -> bool : open_container( (PyClip)arg1) -> bool : Open the container timeline if the Clip is inside a container. close_container(...) \u2014 close_container( (PyClip)arg1) -> None : close_container( (PyClip)arg1) -> None : Close the container timeline if the Clip is inside a container. reformat(...) \u2014 reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None : reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None : Reformat the Clip to the specified format. Keywords arguments: width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. bit_depth -- Bit depth. (8, 10, 12, 16 or 32) scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) resize_mode -- Resize mode. (Letterbox, Crop Edges, Fill, Centre) create_marker(...) \u2014 create_marker( (PyClip)arg1, (object)location) -> object : create_marker( (PyClip)arg1, (object)location) -> object : Add a Marker to the Clip.Keyword argument: location -- The frame where the marker gets created. change_dominance(...) \u2014 change_dominance( (PyClip)arg1, (str)scan_mode) -> None : change_dominance( (PyClip)arg1, (str)scan_mode) -> None : Change the Clip's dominance. Changes only the clip's metadata. Keyword argument: scan_mode -- Field dominance. (P, F1, F2) cache_media(...) \u2014 cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Cache the Clip's linked media. Keyword argument: mode -- Determine the version to cache (currently selected or all versions). All Versions is only useful with to multi-version clips (Current, All Versions) flush_cache_media(...) \u2014 flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current)(Deprecated: use 'clear_cache_media' instead.) clear_cache_media(...) \u2014 clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool : Clear the Clip's media cache. Keyword argument: mode -- Determine the version's cache to clear. (Current, All Versions, All But Current) render(...) \u2014 render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool : render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool : Trigger a render of the Clip The following attributes can be defined: render_mode, render_option, render_quality, effect_type, effect_caching_mode and include_handles. flush_renders(...) \u2014 flush_renders( (PyClip)arg1) -> None : flush_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders.(Deprecated: use 'clear_renders' instead.) clear_renders(...) \u2014 clear_renders( (PyClip)arg1) -> None : clear_renders( (PyClip)arg1) -> None : Clear the Clip's Timeline FX renders. is_rendered(...) \u2014 is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool : is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool : Return if a Clip is rendered. The following attributes can be defined: top_only, render_quality. save(...) \u2014 save( (PyClip)arg1) -> bool : save( (PyClip)arg1) -> bool : Save the Clip to the defined save destination. cut(...) \u2014 cut( (PyClip)arg1, (PyTime)cut_time) -> None : cut( (PyClip)arg1, (PyTime)cut_time) -> None : Cut all tracks of the Clip. get_colour_space(...) \u2014 get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str : get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str : Return the colour space at the requested time. Use current_time when no time is supplied. change_start_frame(...) \u2014 change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : Modify the start frame of a source Clip. Keywords argument: start_frame -- New start frame of the clip. use_segment_connections -- Sync the start frame of connected segments. get_metadata(...) \u2014 get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : Return the metadata of the clip. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. time -- Must be a PyTime. If not specified, the current clip time is used.","title":"Built-in methods"},{"location":"api/classes/PyClipNode/","text":"Class: PyClipNode Module : flame Class derived from PyNode. This class represents a Clip node. Methods Properties clip(...) \u2014 None( (flame.PyClipNode)arg1) -> object None( (flame.PyClipNode)arg1) -> object version_uids(...) \u2014 None( (flame.PyClipNode)arg1) -> list None( (flame.PyClipNode)arg1) -> list version_uid(...) \u2014 None( (flame.PyClipNode)arg1) -> object None( (flame.PyClipNode)arg1) -> object Built-in methods set_version_uid(...) \u2014 set_version_uid( (PyClipNode)arg1, (str)version_uid) -> bool : set_version_uid( (PyClipNode)arg1, (str)version_uid) -> bool : Set the clip node's current version unique ID. Keywords argument: version_uid -- version unique ID. set_metadata_value(...) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. set_metadata_discarded(...) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key. set_metadata_key(...) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value.","title":"Class: PyClipNode"},{"location":"api/classes/PyClipNode/#class-pyclipnode","text":"Module : flame Class derived from PyNode. This class represents a Clip node.","title":"Class: PyClipNode"},{"location":"api/classes/PyClipNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyClipNode/#properties","text":"clip(...) \u2014 None( (flame.PyClipNode)arg1) -> object None( (flame.PyClipNode)arg1) -> object version_uids(...) \u2014 None( (flame.PyClipNode)arg1) -> list None( (flame.PyClipNode)arg1) -> list version_uid(...) \u2014 None( (flame.PyClipNode)arg1) -> object None( (flame.PyClipNode)arg1) -> object","title":"Properties"},{"location":"api/classes/PyClipNode/#built-in-methods","text":"set_version_uid(...) \u2014 set_version_uid( (PyClipNode)arg1, (str)version_uid) -> bool : set_version_uid( (PyClipNode)arg1, (str)version_uid) -> bool : Set the clip node's current version unique ID. Keywords argument: version_uid -- version unique ID. set_metadata_value(...) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. set_metadata_discarded(...) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key. set_metadata_key(...) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value.","title":"Built-in methods"},{"location":"api/classes/PyClrMgmtNode/","text":"Class: PyClrMgmtNode Module : flame Object representing a Colour Mgmt node. Methods Built-in methods set_context_variable(...) \u2014 set_context_variable( (PyClrMgmtNode)arg1, (str)name, (str)value) -> None : set_context_variable( (PyClrMgmtNode)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable. get_context_variables(...) \u2014 get_context_variables( (PyClrMgmtNode)arg1) -> dict : get_context_variables( (PyClrMgmtNode)arg1) -> dict : Get the context variables in a dictionary. reset_context_variables(...) \u2014 reset_context_variables( (PyClrMgmtNode)arg1) -> None : reset_context_variables( (PyClrMgmtNode)arg1) -> None : Reset the context variables to their initial state from the ocio config. import_transform(...) \u2014 import_transform( (PyClrMgmtNode)arg1, (str)file_path) -> None : import_transform( (PyClrMgmtNode)arg1, (str)file_path) -> None : Import a transform from a file.","title":"Class: PyClrMgmtNode"},{"location":"api/classes/PyClrMgmtNode/#class-pyclrmgmtnode","text":"Module : flame Object representing a Colour Mgmt node.","title":"Class: PyClrMgmtNode"},{"location":"api/classes/PyClrMgmtNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyClrMgmtNode/#built-in-methods","text":"set_context_variable(...) \u2014 set_context_variable( (PyClrMgmtNode)arg1, (str)name, (str)value) -> None : set_context_variable( (PyClrMgmtNode)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable. get_context_variables(...) \u2014 get_context_variables( (PyClrMgmtNode)arg1) -> dict : get_context_variables( (PyClrMgmtNode)arg1) -> dict : Get the context variables in a dictionary. reset_context_variables(...) \u2014 reset_context_variables( (PyClrMgmtNode)arg1) -> None : reset_context_variables( (PyClrMgmtNode)arg1) -> None : Reset the context variables to their initial state from the ocio config. import_transform(...) \u2014 import_transform( (PyClrMgmtNode)arg1, (str)file_path) -> None : import_transform( (PyClrMgmtNode)arg1, (str)file_path) -> None : Import a transform from a file.","title":"Built-in methods"},{"location":"api/classes/PyCoCameraAnalysis/","text":"Class: PyCoCameraAnalysis Module : flame Class derived from PyCoNode. This class represents the camera analysis node in the Action schematic. Methods Built-in methods resetAnalysis(...) \u2014 resetAnalysis( (PyCoCameraAnalysis)arg1) -> bool : resetAnalysis( (PyCoCameraAnalysis)arg1) -> bool : Reset the current analysis. analyseRange(...) \u2014 analyseRange( (PyCoCameraAnalysis)arg1, (object)arg2, (object)start) -> bool : analyseRange( (PyCoCameraAnalysis)arg1, (object)arg2, (object)start) -> bool : Run the analysis for the given frame range using the first frame as a reference if none has been already set.","title":"Class: PyCoCameraAnalysis"},{"location":"api/classes/PyCoCameraAnalysis/#class-pycocameraanalysis","text":"Module : flame Class derived from PyCoNode. This class represents the camera analysis node in the Action schematic.","title":"Class: PyCoCameraAnalysis"},{"location":"api/classes/PyCoCameraAnalysis/#methods","text":"","title":"Methods"},{"location":"api/classes/PyCoCameraAnalysis/#built-in-methods","text":"resetAnalysis(...) \u2014 resetAnalysis( (PyCoCameraAnalysis)arg1) -> bool : resetAnalysis( (PyCoCameraAnalysis)arg1) -> bool : Reset the current analysis. analyseRange(...) \u2014 analyseRange( (PyCoCameraAnalysis)arg1, (object)arg2, (object)start) -> bool : analyseRange( (PyCoCameraAnalysis)arg1, (object)arg2, (object)start) -> bool : Run the analysis for the given frame range using the first frame as a reference if none has been already set.","title":"Built-in methods"},{"location":"api/classes/PyCoCompass/","text":"Class: PyCoCompass Module : flame Class derived from PyCoNode. This class represents the compass node in the Action schematic. Methods Properties nodes(...) \u2014 None( (flame.PyCoCompass)arg1) -> list None( (flame.PyCoCompass)arg1) -> list","title":"Class: PyCoCompass"},{"location":"api/classes/PyCoCompass/#class-pycocompass","text":"Module : flame Class derived from PyCoNode. This class represents the compass node in the Action schematic.","title":"Class: PyCoCompass"},{"location":"api/classes/PyCoCompass/#methods","text":"","title":"Methods"},{"location":"api/classes/PyCoCompass/#properties","text":"nodes(...) \u2014 None( (flame.PyCoCompass)arg1) -> list None( (flame.PyCoCompass)arg1) -> list","title":"Properties"},{"location":"api/classes/PyCoNode/","text":"Class: PyCoNode Module : flame Class derived from PyFlameObject. This class represents an Action node in the Action schematic. Methods Properties type(...) \u2014 None( (flame.PyCoNode)arg1) -> str None( (flame.PyCoNode)arg1) -> str Built-in methods assign_media(...) \u2014 assign_media( (PyCoNode)arg1, (object)media_name) -> bool : assign_media( (PyCoNode)arg1, (object)media_name) -> bool : Assign a media layer to the node. Keyword argument media_name -- The index of the media layer from Actions' media_layers ; or the name of the media layer. cache_range(...) \u2014 cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : Cache the selected Map Analysis over the specified range. Keyword arguments start -- The first frame of the range. An integer. end -- The last frame of the range. An integer. add_reference(...) \u2014 add_reference( (PyCoNode)arg1, (object)frame) -> bool : add_reference( (PyCoNode)arg1, (object)frame) -> bool : Add a Motion Warp map's reference frame at specified index. Keyword argument frame -- The reference frame's index. An integer. parents(...) \u2014 parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the parents of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) children(...) \u2014 children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the children of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"Class: PyCoNode"},{"location":"api/classes/PyCoNode/#class-pyconode","text":"Module : flame Class derived from PyFlameObject. This class represents an Action node in the Action schematic.","title":"Class: PyCoNode"},{"location":"api/classes/PyCoNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyCoNode/#properties","text":"type(...) \u2014 None( (flame.PyCoNode)arg1) -> str None( (flame.PyCoNode)arg1) -> str","title":"Properties"},{"location":"api/classes/PyCoNode/#built-in-methods","text":"assign_media(...) \u2014 assign_media( (PyCoNode)arg1, (object)media_name) -> bool : assign_media( (PyCoNode)arg1, (object)media_name) -> bool : Assign a media layer to the node. Keyword argument media_name -- The index of the media layer from Actions' media_layers ; or the name of the media layer. cache_range(...) \u2014 cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool : Cache the selected Map Analysis over the specified range. Keyword arguments start -- The first frame of the range. An integer. end -- The last frame of the range. An integer. add_reference(...) \u2014 add_reference( (PyCoNode)arg1, (object)frame) -> bool : add_reference( (PyCoNode)arg1, (object)frame) -> bool : Add a Motion Warp map's reference frame at specified index. Keyword argument frame -- The reference frame's index. An integer. parents(...) \u2014 parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the parents of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic) children(...) \u2014 children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list : Return a list of PyCoNode objects that are the children of the action node. Keyword argument: link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)","title":"Built-in methods"},{"location":"api/classes/PyColourMgtTimelineFX/","text":"Class: PyColourMgtTimelineFX Module : flame Object representing a Colour Mgmt Timeline FX. Methods Built-in methods set_context_variable(...) \u2014 set_context_variable( (PyColourMgtTimelineFX)arg1, (str)name, (str)value) -> None : set_context_variable( (PyColourMgtTimelineFX)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable. get_context_variables(...) \u2014 get_context_variables( (PyColourMgtTimelineFX)arg1) -> dict : get_context_variables( (PyColourMgtTimelineFX)arg1) -> dict : Get the context variables in a dictionary. import_transform(...) \u2014 import_transform( (PyColourMgtTimelineFX)arg1, (str)file_path) -> None : import_transform( (PyColourMgtTimelineFX)arg1, (str)file_path) -> None : Import a transform from a file. reset_context_variables(...) \u2014 reset_context_variables( (PyColourMgtTimelineFX)arg1) -> None : reset_context_variables( (PyColourMgtTimelineFX)arg1) -> None : Reset the context variables to their initial state from the ocio config.","title":"Class: PyColourMgtTimelineFX"},{"location":"api/classes/PyColourMgtTimelineFX/#class-pycolourmgttimelinefx","text":"Module : flame Object representing a Colour Mgmt Timeline FX.","title":"Class: PyColourMgtTimelineFX"},{"location":"api/classes/PyColourMgtTimelineFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyColourMgtTimelineFX/#built-in-methods","text":"set_context_variable(...) \u2014 set_context_variable( (PyColourMgtTimelineFX)arg1, (str)name, (str)value) -> None : set_context_variable( (PyColourMgtTimelineFX)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable. get_context_variables(...) \u2014 get_context_variables( (PyColourMgtTimelineFX)arg1) -> dict : get_context_variables( (PyColourMgtTimelineFX)arg1) -> dict : Get the context variables in a dictionary. import_transform(...) \u2014 import_transform( (PyColourMgtTimelineFX)arg1, (str)file_path) -> None : import_transform( (PyColourMgtTimelineFX)arg1, (str)file_path) -> None : Import a transform from a file. reset_context_variables(...) \u2014 reset_context_variables( (PyColourMgtTimelineFX)arg1) -> None : reset_context_variables( (PyColourMgtTimelineFX)arg1) -> None : Reset the context variables to their initial state from the ocio config.","title":"Built-in methods"},{"location":"api/classes/PyCompassNode/","text":"Class: PyCompassNode Module : flame Class derived from PyNode. This class represents a Compass node. Methods Properties nodes(...) \u2014 None( (flame.PyCompassNode)arg1) -> list None( (flame.PyCompassNode)arg1) -> list","title":"Class: PyCompassNode"},{"location":"api/classes/PyCompassNode/#class-pycompassnode","text":"Module : flame Class derived from PyNode. This class represents a Compass node.","title":"Class: PyCompassNode"},{"location":"api/classes/PyCompassNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyCompassNode/#properties","text":"nodes(...) \u2014 None( (flame.PyCompassNode)arg1) -> list None( (flame.PyCompassNode)arg1) -> list","title":"Properties"},{"location":"api/classes/PyDesktop/","text":"Class: PyDesktop Module : flame Class derived from PyArchiveEntry. This class represents a Desktop. Methods Properties children(...) \u2014 None( (flame.PyDesktop)arg1) -> list None( (flame.PyDesktop)arg1) -> list batch_groups(...) \u2014 None( (flame.PyDesktop)arg1) -> list None( (flame.PyDesktop)arg1) -> list reel_groups(...) \u2014 None( (flame.PyDesktop)arg1) -> list None( (flame.PyDesktop)arg1) -> list Built-in methods create_reel_group(...) \u2014 create_reel_group( (PyDesktop)arg1, (str)name) -> object : create_reel_group( (PyDesktop)arg1, (str)name) -> object : Create a new Reel Group object in the Desktop catalogue. save(...) \u2014 save( (PyDesktop)arg1) -> bool : save( (PyDesktop)arg1) -> bool : Save the Desktop to the location defined by the destination attribute. create_batch_group(...) \u2014 create_batch_group( (PyDesktop)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : create_batch_group( (PyDesktop)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : Create a new Batch Group object in the Desktop catalogue. Keyword arguments: name -- Name of the Batch Group. nb_reels -- Number of reels created. reels overrides nb_reels . nb_shelf_reels -- Number of shelf reels. The first shelf reel created is named Batch Renders. shelf_reels ovverides nb_shelf_reels . reels -- A list of reel names. Overrides nb_reels . shelf_reels -- A list of shelf reel names. Overrides nb_shelf_reels . start_frame -- The Batch Group's start frame. No timecodes, only a frame value. duration -- The number of frames. Sets the Duration field in the Batch UI. Will be set to the first clip duration when not specified. clear(...) \u2014 clear( (PyDesktop)arg1) -> bool : clear( (PyDesktop)arg1) -> bool : Clear the Desktop.","title":"Class: PyDesktop"},{"location":"api/classes/PyDesktop/#class-pydesktop","text":"Module : flame Class derived from PyArchiveEntry. This class represents a Desktop.","title":"Class: PyDesktop"},{"location":"api/classes/PyDesktop/#methods","text":"","title":"Methods"},{"location":"api/classes/PyDesktop/#properties","text":"children(...) \u2014 None( (flame.PyDesktop)arg1) -> list None( (flame.PyDesktop)arg1) -> list batch_groups(...) \u2014 None( (flame.PyDesktop)arg1) -> list None( (flame.PyDesktop)arg1) -> list reel_groups(...) \u2014 None( (flame.PyDesktop)arg1) -> list None( (flame.PyDesktop)arg1) -> list","title":"Properties"},{"location":"api/classes/PyDesktop/#built-in-methods","text":"create_reel_group(...) \u2014 create_reel_group( (PyDesktop)arg1, (str)name) -> object : create_reel_group( (PyDesktop)arg1, (str)name) -> object : Create a new Reel Group object in the Desktop catalogue. save(...) \u2014 save( (PyDesktop)arg1) -> bool : save( (PyDesktop)arg1) -> bool : Save the Desktop to the location defined by the destination attribute. create_batch_group(...) \u2014 create_batch_group( (PyDesktop)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : create_batch_group( (PyDesktop)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object : Create a new Batch Group object in the Desktop catalogue. Keyword arguments: name -- Name of the Batch Group. nb_reels -- Number of reels created. reels overrides nb_reels . nb_shelf_reels -- Number of shelf reels. The first shelf reel created is named Batch Renders. shelf_reels ovverides nb_shelf_reels . reels -- A list of reel names. Overrides nb_reels . shelf_reels -- A list of shelf reel names. Overrides nb_shelf_reels . start_frame -- The Batch Group's start frame. No timecodes, only a frame value. duration -- The number of frames. Sets the Duration field in the Batch UI. Will be set to the first clip duration when not specified. clear(...) \u2014 clear( (PyDesktop)arg1) -> bool : clear( (PyDesktop)arg1) -> bool : Clear the Desktop.","title":"Built-in methods"},{"location":"api/classes/PyExporter/","text":"Class: PyExporter Module : flame Object holding export settings. Methods Properties use_top_video_track(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool export_between_marks(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool foreground(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool include_subtitles(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool export_subtitles_as_files(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool export_all_subtitles(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_unlinked(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_unrendered(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_pending_render(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_no_media(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_mixed_colour_space(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_reimport_unsupported(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool keep_timeline_fx_renders(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool Static methods get_presets_base_dir(...) \u2014 get_presets_base_dir( (PyExporter.PresetVisibility)preset_visibility) -> str : get_presets_base_dir( (PyExporter.PresetVisibility)preset_visibility) -> str : Get a presets base directory. get_presets_dir(...) \u2014 get_presets_dir( (PyExporter.PresetVisibility)preset_visibility, (PyExporter.PresetType)preset_type) -> str : get_presets_dir( (PyExporter.PresetVisibility)preset_visibility, (PyExporter.PresetType)preset_type) -> str : Get a presets directory. Built-in methods export(...) \u2014 export( (PyExporter)arg1, (object)sources, (str)preset_path, (str)output_directory [, (PyExporter.BackgroundJobSettings)background_job_settings=None [, (object)hooks=None [, (object)hooks_user_data=None]]]) -> None : export( (PyExporter)arg1, (object)sources, (str)preset_path, (str)output_directory [, (PyExporter.BackgroundJobSettings)background_job_settings=None [, (object)hooks=None [, (object)hooks_user_data=None]]]) -> None : Perform export. Keyword arguments: sources -- Flame clip object, a Flame container object or a list of either first. If a container is passed, a multi-export will be done and structure will be respected as much as possible. preset_path -- Absolute path to the export preset to use. output_directory -- Absolute path to the output directory root. background_job_settings -- Settings of background job(s) created if any. hooks -- Export python hooks override. If passed, regular export python hooks implemented in exportHooks.py will be bypassed for this export and methods in the passed object with matching name will be called. Instance of object passed should implement the following signature: class PythonHookOverride(object): def preExport(self, info, userData, *args, **kwargs) pass def postExport(self, info, userData, *args, **kwargs): pass def preExportSequence(self, info, userData, *args, **kwargs): pass def postExportSequence(self, info, userData, *args, **kwargs): pass def preExportAsset(self, info, userData, *args, **kwargs): pass def postExportAsset(self, info, userData, *args, **kwargs): pass def exportOverwriteFile(self, path, *args, **kwargs): return \"ask\" # or \"overwrite\" hooks_user_data -- User data object passed to the export python hooks. This object can be modified by the PythonHookOverride methods but cannot be re-assigned Callable attributes BackgroundJobSettings(...) \u2014 Object holding background export job settings. These settings refer to the Backburner job, server and manager. Object holding background export job settings. These settings refer to the Backburner job, server and manager. PresetType(...) \u2014 int([x]) -> integer int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating-point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. int('0b100', base=0) 4 PresetVisibility(...) \u2014 int([x]) -> integer int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating-point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. int('0b100', base=0) 4 Attributes Image_Sequence(...) \u2014 Audio(...) \u2014 Movie(...) \u2014 Sequence_Publish(...) \u2014 Distribution_Package(...) \u2014 User(...) \u2014 Project(...) \u2014 Shared(...) \u2014 Autodesk(...) \u2014 Flow_Production_Tracking(...) \u2014 Shotgun(...) \u2014","title":"Class: PyExporter"},{"location":"api/classes/PyExporter/#class-pyexporter","text":"Module : flame Object holding export settings.","title":"Class: PyExporter"},{"location":"api/classes/PyExporter/#methods","text":"","title":"Methods"},{"location":"api/classes/PyExporter/#properties","text":"use_top_video_track(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool export_between_marks(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool foreground(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool include_subtitles(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool export_subtitles_as_files(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool export_all_subtitles(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_unlinked(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_unrendered(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_pending_render(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_no_media(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_mixed_colour_space(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool warn_on_reimport_unsupported(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool keep_timeline_fx_renders(...) \u2014 None( (flame.PyExporter)arg1) -> bool None( (flame.PyExporter)arg1) -> bool","title":"Properties"},{"location":"api/classes/PyExporter/#static-methods","text":"get_presets_base_dir(...) \u2014 get_presets_base_dir( (PyExporter.PresetVisibility)preset_visibility) -> str : get_presets_base_dir( (PyExporter.PresetVisibility)preset_visibility) -> str : Get a presets base directory. get_presets_dir(...) \u2014 get_presets_dir( (PyExporter.PresetVisibility)preset_visibility, (PyExporter.PresetType)preset_type) -> str : get_presets_dir( (PyExporter.PresetVisibility)preset_visibility, (PyExporter.PresetType)preset_type) -> str : Get a presets directory.","title":"Static methods"},{"location":"api/classes/PyExporter/#built-in-methods","text":"export(...) \u2014 export( (PyExporter)arg1, (object)sources, (str)preset_path, (str)output_directory [, (PyExporter.BackgroundJobSettings)background_job_settings=None [, (object)hooks=None [, (object)hooks_user_data=None]]]) -> None : export( (PyExporter)arg1, (object)sources, (str)preset_path, (str)output_directory [, (PyExporter.BackgroundJobSettings)background_job_settings=None [, (object)hooks=None [, (object)hooks_user_data=None]]]) -> None : Perform export. Keyword arguments: sources -- Flame clip object, a Flame container object or a list of either first. If a container is passed, a multi-export will be done and structure will be respected as much as possible. preset_path -- Absolute path to the export preset to use. output_directory -- Absolute path to the output directory root. background_job_settings -- Settings of background job(s) created if any. hooks -- Export python hooks override. If passed, regular export python hooks implemented in exportHooks.py will be bypassed for this export and methods in the passed object with matching name will be called. Instance of object passed should implement the following signature: class PythonHookOverride(object): def preExport(self, info, userData, *args, **kwargs) pass def postExport(self, info, userData, *args, **kwargs): pass def preExportSequence(self, info, userData, *args, **kwargs): pass def postExportSequence(self, info, userData, *args, **kwargs): pass def preExportAsset(self, info, userData, *args, **kwargs): pass def postExportAsset(self, info, userData, *args, **kwargs): pass def exportOverwriteFile(self, path, *args, **kwargs): return \"ask\" # or \"overwrite\" hooks_user_data -- User data object passed to the export python hooks. This object can be modified by the PythonHookOverride methods but cannot be re-assigned","title":"Built-in methods"},{"location":"api/classes/PyExporter/#callable-attributes","text":"BackgroundJobSettings(...) \u2014 Object holding background export job settings. These settings refer to the Backburner job, server and manager. Object holding background export job settings. These settings refer to the Backburner job, server and manager. PresetType(...) \u2014 int([x]) -> integer int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating-point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. int('0b100', base=0) 4 PresetVisibility(...) \u2014 int([x]) -> integer int([x]) -> integer int(x, base=10) -> integer Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x. int (). For floating-point numbers, this truncates towards zero. If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by '+' or '-' and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. int('0b100', base=0) 4","title":"Callable attributes"},{"location":"api/classes/PyExporter/#attributes","text":"Image_Sequence(...) \u2014 Audio(...) \u2014 Movie(...) \u2014 Sequence_Publish(...) \u2014 Distribution_Package(...) \u2014 User(...) \u2014 Project(...) \u2014 Shared(...) \u2014 Autodesk(...) \u2014 Flow_Production_Tracking(...) \u2014 Shotgun(...) \u2014","title":"Attributes"},{"location":"api/classes/PyFlameObject/","text":"Class: PyFlameObject Module : flame The basic type of all accessible Flame objects from the python API. Methods Properties attributes(...) \u2014 None( (flame.PyFlameObject)arg1) -> list None( (flame.PyFlameObject)arg1) -> list parent(...) \u2014 None( (flame.PyFlameObject)arg1) -> object None( (flame.PyFlameObject)arg1) -> object","title":"Class: PyFlameObject"},{"location":"api/classes/PyFlameObject/#class-pyflameobject","text":"Module : flame The basic type of all accessible Flame objects from the python API.","title":"Class: PyFlameObject"},{"location":"api/classes/PyFlameObject/#methods","text":"","title":"Methods"},{"location":"api/classes/PyFlameObject/#properties","text":"attributes(...) \u2014 None( (flame.PyFlameObject)arg1) -> list None( (flame.PyFlameObject)arg1) -> list parent(...) \u2014 None( (flame.PyFlameObject)arg1) -> object None( (flame.PyFlameObject)arg1) -> object","title":"Properties"},{"location":"api/classes/PyFolder/","text":"Class: PyFolder Module : flame Class derived from PyArchiveEntry. This class represents a Folder. Methods Properties children(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list folders(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list batch_iterations(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list desktops(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list reel_groups(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list reels(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list sequences(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list clips(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list batch_groups(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list Built-in methods clear(...) \u2014 clear( (PyFolder)arg1 [, (bool)confirm=True]) -> bool : clear( (PyFolder)arg1 [, (bool)confirm=True]) -> bool : Clear the contents of the Folder object. create_reel_group(...) \u2014 create_reel_group( (PyFolder)arg1, (str)name) -> object : create_reel_group( (PyFolder)arg1, (str)name) -> object : Create a new Reel Group object inside the Folder. create_reel(...) \u2014 create_reel( (PyFolder)arg1, (str)name) -> object : create_reel( (PyFolder)arg1, (str)name) -> object : Create a new Reel object inside the Folder. create_folder(...) \u2014 create_folder( (PyFolder)arg1, (str)name) -> object : create_folder( (PyFolder)arg1, (str)name) -> object : Create a new Folder object inside the Folder. create_sequence(...) \u2014 create_sequence( (PyFolder)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : create_sequence( (PyFolder)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by frame_rate . duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by frame_rate . If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all audio_tracks . False for mono tracks, True for stereo.","title":"Class: PyFolder"},{"location":"api/classes/PyFolder/#class-pyfolder","text":"Module : flame Class derived from PyArchiveEntry. This class represents a Folder.","title":"Class: PyFolder"},{"location":"api/classes/PyFolder/#methods","text":"","title":"Methods"},{"location":"api/classes/PyFolder/#properties","text":"children(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list folders(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list batch_iterations(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list desktops(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list reel_groups(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list reels(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list sequences(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list clips(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list batch_groups(...) \u2014 None( (flame.PyFolder)arg1) -> list None( (flame.PyFolder)arg1) -> list","title":"Properties"},{"location":"api/classes/PyFolder/#built-in-methods","text":"clear(...) \u2014 clear( (PyFolder)arg1 [, (bool)confirm=True]) -> bool : clear( (PyFolder)arg1 [, (bool)confirm=True]) -> bool : Clear the contents of the Folder object. create_reel_group(...) \u2014 create_reel_group( (PyFolder)arg1, (str)name) -> object : create_reel_group( (PyFolder)arg1, (str)name) -> object : Create a new Reel Group object inside the Folder. create_reel(...) \u2014 create_reel( (PyFolder)arg1, (str)name) -> object : create_reel( (PyFolder)arg1, (str)name) -> object : Create a new Reel object inside the Folder. create_folder(...) \u2014 create_folder( (PyFolder)arg1, (str)name) -> object : create_folder( (PyFolder)arg1, (str)name) -> object : Create a new Folder object inside the Folder. create_sequence(...) \u2014 create_sequence( (PyFolder)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : create_sequence( (PyFolder)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by frame_rate . duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by frame_rate . If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all audio_tracks . False for mono tracks, True for stereo.","title":"Built-in methods"},{"location":"api/classes/PyGMaskTracerNode/","text":"Class: PyGMaskTracerNode Module : flame Class derived from PyActionFamilyNode. Represents a GMask Tracer node object. Methods Properties output_types(...) \u2014 None( (flame.PyGMaskTracerNode)arg1) -> list None( (flame.PyGMaskTracerNode)arg1) -> list Built-in methods import_fbx(...) \u2014 import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : Import an FBX file into the GMask Tracer schematic using the GMask Tracer Objects mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. export_fbx(...) \u2014 export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : Export GMask Tracer nodes to an FBX file. Keyword argument: file_path -- Path to the output FBX file. Mandatory. read_fbx(...) \u2014 read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : Import an FBX file into the GMask Tracer schematic using the Read File mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. import_abc(...) \u2014 import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : Import an Alembic (ABC) file into the GMask Tracer schematic using the GMask Tracer Objects mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. read_abc(...) \u2014 read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : Import an Alembic (ABC) file into the GMask Tracer schematic using the Read File mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. import_psd(...) \u2014 import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : Import a PSD file into the GMask Tracer schematic. Keyword arguments: file_path -- Path to the PSD file. Mandatory. input_colour_space -- The colour space used as input. Optional. enable_output(...) \u2014 enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Enable the render output_type for the GMask Tracer node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectoars Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth) disable_output(...) \u2014 disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Disable the render output_type for the GMask Tracer node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectors Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)","title":"Class: PyGMaskTracerNode"},{"location":"api/classes/PyGMaskTracerNode/#class-pygmasktracernode","text":"Module : flame Class derived from PyActionFamilyNode. Represents a GMask Tracer node object.","title":"Class: PyGMaskTracerNode"},{"location":"api/classes/PyGMaskTracerNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyGMaskTracerNode/#properties","text":"output_types(...) \u2014 None( (flame.PyGMaskTracerNode)arg1) -> list None( (flame.PyGMaskTracerNode)arg1) -> list","title":"Properties"},{"location":"api/classes/PyGMaskTracerNode/#built-in-methods","text":"import_fbx(...) \u2014 import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list : Import an FBX file into the GMask Tracer schematic using the GMask Tracer Objects mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. export_fbx(...) \u2014 export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool : Export GMask Tracer nodes to an FBX file. Keyword argument: file_path -- Path to the output FBX file. Mandatory. read_fbx(...) \u2014 read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object : Import an FBX file into the GMask Tracer schematic using the Read File mode. Keyword argument: file_path -- Path to the FBX file. Mandatory. input_colour_space -- Colour space name used as input for textures. Optional. import_abc(...) \u2014 import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list : Import an Alembic (ABC) file into the GMask Tracer schematic using the GMask Tracer Objects mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. read_abc(...) \u2014 read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object : Import an Alembic (ABC) file into the GMask Tracer schematic using the Read File mode. Keyword argument: file_path -- Path to the ABC file. Mandatory. import_psd(...) \u2014 import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list : Import a PSD file into the GMask Tracer schematic. Keyword arguments: file_path -- Path to the PSD file. Mandatory. input_colour_space -- The colour space used as input. Optional. enable_output(...) \u2014 enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Enable the render output_type for the GMask Tracer node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectoars Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth) disable_output(...) \u2014 disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool : Disable the render output_type for the GMask Tracer node. Keyword argument: output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectors Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)","title":"Built-in methods"},{"location":"api/classes/PyHDRNode/","text":"Class: PyHDRNode Module : flame Object representing a HDR node. Methods Properties analysis_status(...) \u2014 None( (flame.PyHDRNode)arg1) -> object None( (flame.PyHDRNode)arg1) -> object mastering_display_ids(...) \u2014 None( (flame.PyHDRNode)arg1) -> list None( (flame.PyHDRNode)arg1) -> list target_display_ids(...) \u2014 None( (flame.PyHDRNode)arg1) -> list None( (flame.PyHDRNode)arg1) -> list mastering_display_info(...) \u2014 None( (flame.PyHDRNode)arg1) -> object None( (flame.PyHDRNode)arg1) -> object target_display_info(...) \u2014 None( (flame.PyHDRNode)arg1) -> object None( (flame.PyHDRNode)arg1) -> object Built-in methods analyze(...) \u2014 analyze( (PyHDRNode)arg1 [, (str)analyze_mode='Current Shot']) -> None : analyze( (PyHDRNode)arg1 [, (str)analyze_mode='Current Shot']) -> None : Perform HDR analysis. keep_analysis(...) \u2014 keep_analysis( (PyHDRNode)arg1) -> None : keep_analysis( (PyHDRNode)arg1) -> None : Remove the dirty flag from the HDR analysis. reset_analysis(...) \u2014 reset_analysis( (PyHDRNode)arg1) -> None : reset_analysis( (PyHDRNode)arg1) -> None : Reset the current HDR analysis. interpolate_trims(...) \u2014 interpolate_trims( (PyHDRNode)arg1) -> None : interpolate_trims( (PyHDRNode)arg1) -> None : Interpolate the current HDR trims. reset_trims(...) \u2014 reset_trims( (PyHDRNode)arg1) -> None : reset_trims( (PyHDRNode)arg1) -> None : Reset the current HDR trims. export_DolbyVision_xml(...) \u2014 export_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)comment='']) -> None : export_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)comment='']) -> None : Export the current HDR to a Dolby Vision XML file. import_DolbyVision_xml(...) \u2014 import_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : import_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : Import the current HDR from a Dolby Vision XML file. has_trim(...) \u2014 has_trim( (PyHDRNode)arg1, (int)target_display_id) -> bool : has_trim( (PyHDRNode)arg1, (int)target_display_id) -> bool : Returns True if the given Target Display ID has trims. l2_from_l8(...) \u2014 l2_from_l8( (PyHDRNode)arg1) -> object : l2_from_l8( (PyHDRNode)arg1) -> object : Dictionary containing the L2 values based on L8 values. Not valid in Dolby Vision 2.9.","title":"Class: PyHDRNode"},{"location":"api/classes/PyHDRNode/#class-pyhdrnode","text":"Module : flame Object representing a HDR node.","title":"Class: PyHDRNode"},{"location":"api/classes/PyHDRNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyHDRNode/#properties","text":"analysis_status(...) \u2014 None( (flame.PyHDRNode)arg1) -> object None( (flame.PyHDRNode)arg1) -> object mastering_display_ids(...) \u2014 None( (flame.PyHDRNode)arg1) -> list None( (flame.PyHDRNode)arg1) -> list target_display_ids(...) \u2014 None( (flame.PyHDRNode)arg1) -> list None( (flame.PyHDRNode)arg1) -> list mastering_display_info(...) \u2014 None( (flame.PyHDRNode)arg1) -> object None( (flame.PyHDRNode)arg1) -> object target_display_info(...) \u2014 None( (flame.PyHDRNode)arg1) -> object None( (flame.PyHDRNode)arg1) -> object","title":"Properties"},{"location":"api/classes/PyHDRNode/#built-in-methods","text":"analyze(...) \u2014 analyze( (PyHDRNode)arg1 [, (str)analyze_mode='Current Shot']) -> None : analyze( (PyHDRNode)arg1 [, (str)analyze_mode='Current Shot']) -> None : Perform HDR analysis. keep_analysis(...) \u2014 keep_analysis( (PyHDRNode)arg1) -> None : keep_analysis( (PyHDRNode)arg1) -> None : Remove the dirty flag from the HDR analysis. reset_analysis(...) \u2014 reset_analysis( (PyHDRNode)arg1) -> None : reset_analysis( (PyHDRNode)arg1) -> None : Reset the current HDR analysis. interpolate_trims(...) \u2014 interpolate_trims( (PyHDRNode)arg1) -> None : interpolate_trims( (PyHDRNode)arg1) -> None : Interpolate the current HDR trims. reset_trims(...) \u2014 reset_trims( (PyHDRNode)arg1) -> None : reset_trims( (PyHDRNode)arg1) -> None : Reset the current HDR trims. export_DolbyVision_xml(...) \u2014 export_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)comment='']) -> None : export_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)comment='']) -> None : Export the current HDR to a Dolby Vision XML file. import_DolbyVision_xml(...) \u2014 import_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : import_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : Import the current HDR from a Dolby Vision XML file. has_trim(...) \u2014 has_trim( (PyHDRNode)arg1, (int)target_display_id) -> bool : has_trim( (PyHDRNode)arg1, (int)target_display_id) -> bool : Returns True if the given Target Display ID has trims. l2_from_l8(...) \u2014 l2_from_l8( (PyHDRNode)arg1) -> object : l2_from_l8( (PyHDRNode)arg1) -> object : Dictionary containing the L2 values based on L8 values. Not valid in Dolby Vision 2.9.","title":"Built-in methods"},{"location":"api/classes/PyHDRTimelineFX/","text":"Class: PyHDRTimelineFX Module : flame Object representing a HDR Timeline FX. Methods Properties analysis_status(...) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object None( (flame.PyHDRTimelineFX)arg1) -> object mastering_display_ids(...) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> list None( (flame.PyHDRTimelineFX)arg1) -> list target_display_ids(...) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> list None( (flame.PyHDRTimelineFX)arg1) -> list mastering_display_info(...) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object None( (flame.PyHDRTimelineFX)arg1) -> object target_display_info(...) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object None( (flame.PyHDRTimelineFX)arg1) -> object Built-in methods analyze(...) \u2014 analyze( (PyHDRTimelineFX)arg1 [, (str)analyze_mode='Current Shot']) -> None : analyze( (PyHDRTimelineFX)arg1 [, (str)analyze_mode='Current Shot']) -> None : Perform HDR analysis. keep_analysis(...) \u2014 keep_analysis( (PyHDRTimelineFX)arg1) -> None : keep_analysis( (PyHDRTimelineFX)arg1) -> None : Remove the dirty flag from the HDR analysis. reset_analysis(...) \u2014 reset_analysis( (PyHDRTimelineFX)arg1) -> None : reset_analysis( (PyHDRTimelineFX)arg1) -> None : Reset the current HDR analysis. interpolate_trims(...) \u2014 interpolate_trims( (PyHDRTimelineFX)arg1, (str)arg2) -> None : interpolate_trims( (PyHDRTimelineFX)arg1, (str)arg2) -> None : Interpolate the current HDR trims. reset_trims(...) \u2014 reset_trims( (PyHDRTimelineFX)arg1) -> None : reset_trims( (PyHDRTimelineFX)arg1) -> None : Reset the current HDR trims. export_DolbyVision_xml(...) \u2014 export_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (bool)shot_only=False [, (str)comment='']]) -> None : export_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (bool)shot_only=False [, (str)comment='']]) -> None : Export the current HDR to a Dolby Vision XML file. import_DolbyVision_xml(...) \u2014 import_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : import_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : Import the current HDR from a Dolby Vision XML file. has_trim(...) \u2014 has_trim( (PyHDRTimelineFX)arg1, (int)target_display_id) -> bool : has_trim( (PyHDRTimelineFX)arg1, (int)target_display_id) -> bool : Returns True if the given Target Display ID has trims. l2_from_l8(...) \u2014 l2_from_l8( (PyHDRTimelineFX)arg1) -> object : l2_from_l8( (PyHDRTimelineFX)arg1) -> object : Dictionary containing the L2 values based on L8 values. Not valid in Dolby Vision 2.9.","title":"Class: PyHDRTimelineFX"},{"location":"api/classes/PyHDRTimelineFX/#class-pyhdrtimelinefx","text":"Module : flame Object representing a HDR Timeline FX.","title":"Class: PyHDRTimelineFX"},{"location":"api/classes/PyHDRTimelineFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyHDRTimelineFX/#properties","text":"analysis_status(...) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object None( (flame.PyHDRTimelineFX)arg1) -> object mastering_display_ids(...) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> list None( (flame.PyHDRTimelineFX)arg1) -> list target_display_ids(...) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> list None( (flame.PyHDRTimelineFX)arg1) -> list mastering_display_info(...) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object None( (flame.PyHDRTimelineFX)arg1) -> object target_display_info(...) \u2014 None( (flame.PyHDRTimelineFX)arg1) -> object None( (flame.PyHDRTimelineFX)arg1) -> object","title":"Properties"},{"location":"api/classes/PyHDRTimelineFX/#built-in-methods","text":"analyze(...) \u2014 analyze( (PyHDRTimelineFX)arg1 [, (str)analyze_mode='Current Shot']) -> None : analyze( (PyHDRTimelineFX)arg1 [, (str)analyze_mode='Current Shot']) -> None : Perform HDR analysis. keep_analysis(...) \u2014 keep_analysis( (PyHDRTimelineFX)arg1) -> None : keep_analysis( (PyHDRTimelineFX)arg1) -> None : Remove the dirty flag from the HDR analysis. reset_analysis(...) \u2014 reset_analysis( (PyHDRTimelineFX)arg1) -> None : reset_analysis( (PyHDRTimelineFX)arg1) -> None : Reset the current HDR analysis. interpolate_trims(...) \u2014 interpolate_trims( (PyHDRTimelineFX)arg1, (str)arg2) -> None : interpolate_trims( (PyHDRTimelineFX)arg1, (str)arg2) -> None : Interpolate the current HDR trims. reset_trims(...) \u2014 reset_trims( (PyHDRTimelineFX)arg1) -> None : reset_trims( (PyHDRTimelineFX)arg1) -> None : Reset the current HDR trims. export_DolbyVision_xml(...) \u2014 export_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (bool)shot_only=False [, (str)comment='']]) -> None : export_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (bool)shot_only=False [, (str)comment='']]) -> None : Export the current HDR to a Dolby Vision XML file. import_DolbyVision_xml(...) \u2014 import_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : import_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None : Import the current HDR from a Dolby Vision XML file. has_trim(...) \u2014 has_trim( (PyHDRTimelineFX)arg1, (int)target_display_id) -> bool : has_trim( (PyHDRTimelineFX)arg1, (int)target_display_id) -> bool : Returns True if the given Target Display ID has trims. l2_from_l8(...) \u2014 l2_from_l8( (PyHDRTimelineFX)arg1) -> object : l2_from_l8( (PyHDRTimelineFX)arg1) -> object : Dictionary containing the L2 values based on L8 values. Not valid in Dolby Vision 2.9.","title":"Built-in methods"},{"location":"api/classes/PyImageNode/","text":"Class: PyImageNode Module : flame Class derived from PyActionFamilyNode. Represents an Image node object. Methods Properties media_nodes(...) \u2014 None( (flame.PyImageNode)arg1) -> list None( (flame.PyImageNode)arg1) -> list Built-in methods add_media(...) \u2014 add_media( (PyActionFamilyNode)arg1) -> object : add_media( (PyActionFamilyNode)arg1) -> object : Add a Media layer to the Batch Image node.","title":"Class: PyImageNode"},{"location":"api/classes/PyImageNode/#class-pyimagenode","text":"Module : flame Class derived from PyActionFamilyNode. Represents an Image node object.","title":"Class: PyImageNode"},{"location":"api/classes/PyImageNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyImageNode/#properties","text":"media_nodes(...) \u2014 None( (flame.PyImageNode)arg1) -> list None( (flame.PyImageNode)arg1) -> list","title":"Properties"},{"location":"api/classes/PyImageNode/#built-in-methods","text":"add_media(...) \u2014 add_media( (PyActionFamilyNode)arg1) -> object : add_media( (PyActionFamilyNode)arg1) -> object : Add a Media layer to the Batch Image node.","title":"Built-in methods"},{"location":"api/classes/PyLensDistortionNode/","text":"Class: PyLensDistortionNode Module : flame Object representing a Lens Distortion node. Methods Built-in methods import_lens_distortion(...) \u2014 import_lens_distortion( (PyLensDistortionNode)arg1, (str)filename) -> None : import_lens_distortion( (PyLensDistortionNode)arg1, (str)filename) -> None : Import the Lens Distortion file. calculate(...) \u2014 calculate( (PyLensDistortionNode)arg1) -> None : calculate( (PyLensDistortionNode)arg1) -> None : Calculate the amount of distorsion based on the position of vertices.","title":"Class: PyLensDistortionNode"},{"location":"api/classes/PyLensDistortionNode/#class-pylensdistortionnode","text":"Module : flame Object representing a Lens Distortion node.","title":"Class: PyLensDistortionNode"},{"location":"api/classes/PyLensDistortionNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyLensDistortionNode/#built-in-methods","text":"import_lens_distortion(...) \u2014 import_lens_distortion( (PyLensDistortionNode)arg1, (str)filename) -> None : import_lens_distortion( (PyLensDistortionNode)arg1, (str)filename) -> None : Import the Lens Distortion file. calculate(...) \u2014 calculate( (PyLensDistortionNode)arg1) -> None : calculate( (PyLensDistortionNode)arg1) -> None : Calculate the amount of distorsion based on the position of vertices.","title":"Built-in methods"},{"location":"api/classes/PyLibrary/","text":"Class: PyLibrary Module : flame Class derived from PyArchiveEntry. This class represents a Library. Methods Properties children(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list folders(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list batch_iterations(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list desktops(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list reel_groups(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list reels(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list sequences(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list clips(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list batch_groups(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list opened(...) \u2014 None( (flame.PyLibrary)arg1) -> bool None( (flame.PyLibrary)arg1) -> bool Built-in methods open(...) \u2014 open( (PyLibrary)arg1) -> bool : open( (PyLibrary)arg1) -> bool : Open a Library and load it in the application memory. Until a Library is open, it cannot be accessed. Libraries are created open. close(...) \u2014 close( (PyLibrary)arg1) -> bool : close( (PyLibrary)arg1) -> bool : Close a Library to release it from the application memory. clear(...) \u2014 clear( (PyLibrary)arg1 [, (bool)confirm=True]) -> bool : clear( (PyLibrary)arg1 [, (bool)confirm=True]) -> bool : Clear the Library's contents. acquire_exclusive_access(...) \u2014 acquire_exclusive_access( (PyLibrary)arg1) -> bool : acquire_exclusive_access( (PyLibrary)arg1) -> bool : Acquire exclusive access to the Shared Library. Shared Libraries are created locked. Only use with Shared Libraries. release_exclusive_access(...) \u2014 release_exclusive_access( (PyLibrary)arg1) -> bool : release_exclusive_access( (PyLibrary)arg1) -> bool : Release exclusive access to the Shared Library. Only used for Shared Libraries. Only use with Shared Libraries. create_reel_group(...) \u2014 create_reel_group( (PyLibrary)arg1, (str)name) -> object : create_reel_group( (PyLibrary)arg1, (str)name) -> object : Create a Reel Group inside a Library. create_reel(...) \u2014 create_reel( (PyLibrary)arg1, (str)name) -> object : create_reel( (PyLibrary)arg1, (str)name) -> object : Create a Reel inside a Library. create_folder(...) \u2014 create_folder( (PyLibrary)arg1, (str)name) -> object : create_folder( (PyLibrary)arg1, (str)name) -> object : Create a Folder inside a Library. create_sequence(...) \u2014 create_sequence( (PyLibrary)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : create_sequence( (PyLibrary)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by frame_rate . duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by frame_rate . If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all audio_tracks . False for mono tracks, True for stereo.","title":"Class: PyLibrary"},{"location":"api/classes/PyLibrary/#class-pylibrary","text":"Module : flame Class derived from PyArchiveEntry. This class represents a Library.","title":"Class: PyLibrary"},{"location":"api/classes/PyLibrary/#methods","text":"","title":"Methods"},{"location":"api/classes/PyLibrary/#properties","text":"children(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list folders(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list batch_iterations(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list desktops(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list reel_groups(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list reels(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list sequences(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list clips(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list batch_groups(...) \u2014 None( (flame.PyLibrary)arg1) -> list None( (flame.PyLibrary)arg1) -> list opened(...) \u2014 None( (flame.PyLibrary)arg1) -> bool None( (flame.PyLibrary)arg1) -> bool","title":"Properties"},{"location":"api/classes/PyLibrary/#built-in-methods","text":"open(...) \u2014 open( (PyLibrary)arg1) -> bool : open( (PyLibrary)arg1) -> bool : Open a Library and load it in the application memory. Until a Library is open, it cannot be accessed. Libraries are created open. close(...) \u2014 close( (PyLibrary)arg1) -> bool : close( (PyLibrary)arg1) -> bool : Close a Library to release it from the application memory. clear(...) \u2014 clear( (PyLibrary)arg1 [, (bool)confirm=True]) -> bool : clear( (PyLibrary)arg1 [, (bool)confirm=True]) -> bool : Clear the Library's contents. acquire_exclusive_access(...) \u2014 acquire_exclusive_access( (PyLibrary)arg1) -> bool : acquire_exclusive_access( (PyLibrary)arg1) -> bool : Acquire exclusive access to the Shared Library. Shared Libraries are created locked. Only use with Shared Libraries. release_exclusive_access(...) \u2014 release_exclusive_access( (PyLibrary)arg1) -> bool : release_exclusive_access( (PyLibrary)arg1) -> bool : Release exclusive access to the Shared Library. Only used for Shared Libraries. Only use with Shared Libraries. create_reel_group(...) \u2014 create_reel_group( (PyLibrary)arg1, (str)name) -> object : create_reel_group( (PyLibrary)arg1, (str)name) -> object : Create a Reel Group inside a Library. create_reel(...) \u2014 create_reel( (PyLibrary)arg1, (str)name) -> object : create_reel( (PyLibrary)arg1, (str)name) -> object : Create a Reel inside a Library. create_folder(...) \u2014 create_folder( (PyLibrary)arg1, (str)name) -> object : create_folder( (PyLibrary)arg1, (str)name) -> object : Create a Folder inside a Library. create_sequence(...) \u2014 create_sequence( (PyLibrary)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : create_sequence( (PyLibrary)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by frame_rate . duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by frame_rate . If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all audio_tracks . False for mono tracks, True for stereo.","title":"Built-in methods"},{"location":"api/classes/PyMarker/","text":"Class: PyMarker Module : flame Object representing a Marker. Methods Properties has_annotations(...) \u2014 None( (flame.PyMarker)arg1) -> bool None( (flame.PyMarker)arg1) -> bool Built-in methods clear_annotations(...) \u2014 clear_annotations( (PyMarker)arg1) -> None : clear_annotations( (PyMarker)arg1) -> None : Clear all the annotations from the Marker. sync_connected_segments(...) \u2014 sync_connected_segments( (PyMarker)arg1) -> None : sync_connected_segments( (PyMarker)arg1) -> None : Push the Segment Marker to connected segments.","title":"Class: PyMarker"},{"location":"api/classes/PyMarker/#class-pymarker","text":"Module : flame Object representing a Marker.","title":"Class: PyMarker"},{"location":"api/classes/PyMarker/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMarker/#properties","text":"has_annotations(...) \u2014 None( (flame.PyMarker)arg1) -> bool None( (flame.PyMarker)arg1) -> bool","title":"Properties"},{"location":"api/classes/PyMarker/#built-in-methods","text":"clear_annotations(...) \u2014 clear_annotations( (PyMarker)arg1) -> None : clear_annotations( (PyMarker)arg1) -> None : Clear all the annotations from the Marker. sync_connected_segments(...) \u2014 sync_connected_segments( (PyMarker)arg1) -> None : sync_connected_segments( (PyMarker)arg1) -> None : Push the Segment Marker to connected segments.","title":"Built-in methods"},{"location":"api/classes/PyMediaHub/","text":"Class: PyMediaHub Module : flame This class represents the MediaHub. Methods Properties files(...) \u2014 None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubFilesTab None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubFilesTab archives(...) \u2014 None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubTab None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubTab","title":"Class: PyMediaHub"},{"location":"api/classes/PyMediaHub/#class-pymediahub","text":"Module : flame This class represents the MediaHub.","title":"Class: PyMediaHub"},{"location":"api/classes/PyMediaHub/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHub/#properties","text":"files(...) \u2014 None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubFilesTab None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubFilesTab archives(...) \u2014 None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubTab None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubTab","title":"Properties"},{"location":"api/classes/PyMediaHubFilesEntry/","text":"Class: PyMediaHubFilesEntry Module : flame Object representing a clip in the MediaHub Files tabs Methods Properties path(...) \u2014 None( (flame.PyMediaHubFilesEntry)arg1) -> str None( (flame.PyMediaHubFilesEntry)arg1) -> str","title":"Class: PyMediaHubFilesEntry"},{"location":"api/classes/PyMediaHubFilesEntry/#class-pymediahubfilesentry","text":"Module : flame Object representing a clip in the MediaHub Files tabs","title":"Class: PyMediaHubFilesEntry"},{"location":"api/classes/PyMediaHubFilesEntry/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubFilesEntry/#properties","text":"path(...) \u2014 None( (flame.PyMediaHubFilesEntry)arg1) -> str None( (flame.PyMediaHubFilesEntry)arg1) -> str","title":"Properties"},{"location":"api/classes/PyMediaHubFilesFolder/","text":"Class: PyMediaHubFilesFolder Module : flame Object representing a folder in the MediaHub Files tabs Methods Properties path(...) \u2014 None( (flame.PyMediaHubFilesFolder)arg1) -> str None( (flame.PyMediaHubFilesFolder)arg1) -> str","title":"Class: PyMediaHubFilesFolder"},{"location":"api/classes/PyMediaHubFilesFolder/#class-pymediahubfilesfolder","text":"Module : flame Object representing a folder in the MediaHub Files tabs","title":"Class: PyMediaHubFilesFolder"},{"location":"api/classes/PyMediaHubFilesFolder/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubFilesFolder/#properties","text":"path(...) \u2014 None( (flame.PyMediaHubFilesFolder)arg1) -> str None( (flame.PyMediaHubFilesFolder)arg1) -> str","title":"Properties"},{"location":"api/classes/PyMediaHubFilesTab/","text":"Class: PyMediaHubFilesTab Module : flame This class represents the MediaHub Files tab. Methods Properties options(...) \u2014 None( (flame.PyMediaHubFilesTab)arg1) -> flame.PyMediaHubFilesTabOptions None( (flame.PyMediaHubFilesTab)arg1) -> flame.PyMediaHubFilesTabOptions","title":"Class: PyMediaHubFilesTab"},{"location":"api/classes/PyMediaHubFilesTab/#class-pymediahubfilestab","text":"Module : flame This class represents the MediaHub Files tab.","title":"Class: PyMediaHubFilesTab"},{"location":"api/classes/PyMediaHubFilesTab/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubFilesTab/#properties","text":"options(...) \u2014 None( (flame.PyMediaHubFilesTab)arg1) -> flame.PyMediaHubFilesTabOptions None( (flame.PyMediaHubFilesTab)arg1) -> flame.PyMediaHubFilesTabOptions","title":"Properties"},{"location":"api/classes/PyMediaHubFilesTabOptions/","text":"Class: PyMediaHubFilesTabOptions Module : flame This class represents the MediaHub Files tab options. Methods Properties multi_channel_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str sequence_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool cache_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool proxies_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool cache_and_proxies_all_versions(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool resize_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str resize_filter(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str resolution(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str width(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object height(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object scaling_presets_value(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object frame_ratio(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object bit_depth(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object scan_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str pixel_ratio(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object colour_mgmt_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_view(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str tagged_colour_space(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_display(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_working_space(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_invert(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool Built-in methods import_transform(...) \u2014 import_transform( (PyMediaHubFilesTabOptions)arg1, (str)file_path) -> None : import_transform( (PyMediaHubFilesTabOptions)arg1, (str)file_path) -> None : Import a transform from a file. set_tagged_colour_space(...) \u2014 set_tagged_colour_space( (PyMediaHubFilesTabOptions)arg1, (str)colour_space) -> None : set_tagged_colour_space( (PyMediaHubFilesTabOptions)arg1, (str)colour_space) -> None : Set the tagged colour space to use upon import.","title":"Class: PyMediaHubFilesTabOptions"},{"location":"api/classes/PyMediaHubFilesTabOptions/#class-pymediahubfilestaboptions","text":"Module : flame This class represents the MediaHub Files tab options.","title":"Class: PyMediaHubFilesTabOptions"},{"location":"api/classes/PyMediaHubFilesTabOptions/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubFilesTabOptions/#properties","text":"multi_channel_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str sequence_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool cache_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool proxies_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool cache_and_proxies_all_versions(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool resize_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str resize_filter(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str resolution(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str width(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object height(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object scaling_presets_value(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object frame_ratio(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object bit_depth(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object scan_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str pixel_ratio(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> object None( (flame.PyMediaHubFilesTabOptions)arg1) -> object colour_mgmt_mode(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_view(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str tagged_colour_space(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_display(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_working_space(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> str None( (flame.PyMediaHubFilesTabOptions)arg1) -> str colour_mgmt_invert(...) \u2014 None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool","title":"Properties"},{"location":"api/classes/PyMediaHubFilesTabOptions/#built-in-methods","text":"import_transform(...) \u2014 import_transform( (PyMediaHubFilesTabOptions)arg1, (str)file_path) -> None : import_transform( (PyMediaHubFilesTabOptions)arg1, (str)file_path) -> None : Import a transform from a file. set_tagged_colour_space(...) \u2014 set_tagged_colour_space( (PyMediaHubFilesTabOptions)arg1, (str)colour_space) -> None : set_tagged_colour_space( (PyMediaHubFilesTabOptions)arg1, (str)colour_space) -> None : Set the tagged colour space to use upon import.","title":"Built-in methods"},{"location":"api/classes/PyMediaHubProjectsEntry/","text":"Class: PyMediaHubProjectsEntry Module : flame Object representing a clip in the MediaHub Projects tabs Methods Properties uid(...) \u2014 None( (flame.PyMediaHubProjectsEntry)arg1) -> str None( (flame.PyMediaHubProjectsEntry)arg1) -> str path(...) \u2014 None( (flame.PyMediaHubProjectsEntry)arg1) -> str None( (flame.PyMediaHubProjectsEntry)arg1) -> str","title":"Class: PyMediaHubProjectsEntry"},{"location":"api/classes/PyMediaHubProjectsEntry/#class-pymediahubprojectsentry","text":"Module : flame Object representing a clip in the MediaHub Projects tabs","title":"Class: PyMediaHubProjectsEntry"},{"location":"api/classes/PyMediaHubProjectsEntry/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubProjectsEntry/#properties","text":"uid(...) \u2014 None( (flame.PyMediaHubProjectsEntry)arg1) -> str None( (flame.PyMediaHubProjectsEntry)arg1) -> str path(...) \u2014 None( (flame.PyMediaHubProjectsEntry)arg1) -> str None( (flame.PyMediaHubProjectsEntry)arg1) -> str","title":"Properties"},{"location":"api/classes/PyMediaHubProjectsFolder/","text":"Class: PyMediaHubProjectsFolder Module : flame Object representing a folder in the MediaHub Projects tabs Methods Properties uid(...) \u2014 None( (flame.PyMediaHubProjectsFolder)arg1) -> str None( (flame.PyMediaHubProjectsFolder)arg1) -> str path(...) \u2014 None( (flame.PyMediaHubProjectsFolder)arg1) -> str None( (flame.PyMediaHubProjectsFolder)arg1) -> str","title":"Class: PyMediaHubProjectsFolder"},{"location":"api/classes/PyMediaHubProjectsFolder/#class-pymediahubprojectsfolder","text":"Module : flame Object representing a folder in the MediaHub Projects tabs","title":"Class: PyMediaHubProjectsFolder"},{"location":"api/classes/PyMediaHubProjectsFolder/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubProjectsFolder/#properties","text":"uid(...) \u2014 None( (flame.PyMediaHubProjectsFolder)arg1) -> str None( (flame.PyMediaHubProjectsFolder)arg1) -> str path(...) \u2014 None( (flame.PyMediaHubProjectsFolder)arg1) -> str None( (flame.PyMediaHubProjectsFolder)arg1) -> str","title":"Properties"},{"location":"api/classes/PyMediaHubTab/","text":"Class: PyMediaHubTab Module : flame This class represents a MediaHub tab. Methods Built-in methods get_path(...) \u2014 get_path( (PyMediaHubTab)arg1) -> str : get_path( (PyMediaHubTab)arg1) -> str : Return the MediaHub tab current path. set_path(...) \u2014 set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool : set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool : Set the MediaHub tab current path. If allow_partial_success is True, the path will be set to the last valid folder in the path.","title":"Class: PyMediaHubTab"},{"location":"api/classes/PyMediaHubTab/#class-pymediahubtab","text":"Module : flame This class represents a MediaHub tab.","title":"Class: PyMediaHubTab"},{"location":"api/classes/PyMediaHubTab/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaHubTab/#built-in-methods","text":"get_path(...) \u2014 get_path( (PyMediaHubTab)arg1) -> str : get_path( (PyMediaHubTab)arg1) -> str : Return the MediaHub tab current path. set_path(...) \u2014 set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool : set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool : Set the MediaHub tab current path. If allow_partial_success is True, the path will be set to the last valid folder in the path.","title":"Built-in methods"},{"location":"api/classes/PyMediaPanel/","text":"Class: PyMediaPanel Module : flame This class represents the media panel. Methods Properties selected_entries(...) \u2014 None( (flame.PyMediaPanel)arg1) -> object None( (flame.PyMediaPanel)arg1) -> object visible(...) \u2014 None( (flame.PyMediaPanel)arg1) -> bool None( (flame.PyMediaPanel)arg1) -> bool full_height(...) \u2014 None( (flame.PyMediaPanel)arg1) -> bool None( (flame.PyMediaPanel)arg1) -> bool full_width(...) \u2014 None( (flame.PyMediaPanel)arg1) -> bool None( (flame.PyMediaPanel)arg1) -> bool dual(...) \u2014 None( (flame.PyMediaPanel)arg1) -> bool None( (flame.PyMediaPanel)arg1) -> bool Built-in methods move(...) \u2014 move( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : move( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : Move a PyObject or a list of PyObjects from the Media Panel to a destination inside the Media Panel. Return a list of the moved PyObjects. Keyword arguments: source_entries -- The PyObject or list of PyObjects to move. destination -- The PyObject that acts as destination. duplicate_action -- Action to take when finding an object with the same name (add or replace). copy(...) \u2014 copy( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : copy( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : Copy a PyObject or a list of PyObjects from the Media Panel to a destination inside the Media Panel.Return a list of the copied PyObjects.Keyword arguments: source_entries -- The PyObject or list of PyObjects to copy. destination -- The PyObject that acts as destination. duplicate_action -- Action to take when finding an object with the same name (add or replace).","title":"Class: PyMediaPanel"},{"location":"api/classes/PyMediaPanel/#class-pymediapanel","text":"Module : flame This class represents the media panel.","title":"Class: PyMediaPanel"},{"location":"api/classes/PyMediaPanel/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMediaPanel/#properties","text":"selected_entries(...) \u2014 None( (flame.PyMediaPanel)arg1) -> object None( (flame.PyMediaPanel)arg1) -> object visible(...) \u2014 None( (flame.PyMediaPanel)arg1) -> bool None( (flame.PyMediaPanel)arg1) -> bool full_height(...) \u2014 None( (flame.PyMediaPanel)arg1) -> bool None( (flame.PyMediaPanel)arg1) -> bool full_width(...) \u2014 None( (flame.PyMediaPanel)arg1) -> bool None( (flame.PyMediaPanel)arg1) -> bool dual(...) \u2014 None( (flame.PyMediaPanel)arg1) -> bool None( (flame.PyMediaPanel)arg1) -> bool","title":"Properties"},{"location":"api/classes/PyMediaPanel/#built-in-methods","text":"move(...) \u2014 move( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : move( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : Move a PyObject or a list of PyObjects from the Media Panel to a destination inside the Media Panel. Return a list of the moved PyObjects. Keyword arguments: source_entries -- The PyObject or list of PyObjects to move. destination -- The PyObject that acts as destination. duplicate_action -- Action to take when finding an object with the same name (add or replace). copy(...) \u2014 copy( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : copy( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object : Copy a PyObject or a list of PyObjects from the Media Panel to a destination inside the Media Panel.Return a list of the copied PyObjects.Keyword arguments: source_entries -- The PyObject or list of PyObjects to copy. destination -- The PyObject that acts as destination. duplicate_action -- Action to take when finding an object with the same name (add or replace).","title":"Built-in methods"},{"location":"api/classes/PyMessages/","text":"Class: PyMessages Module : flame Module handling message bar in application UI. Methods Built-in methods show_in_console(...) \u2014 show_in_console( (PyMessages)arg1, (str)message [, (str)type='info' [, (int)duration=-1]]) -> None : show_in_console( (PyMessages)arg1, (str)message [, (str)type='info' [, (int)duration=-1]]) -> None : Display an informative message in application message bar. message -- Message string to display. type -- Message type can be info, warning, or error. duration -- An optional time in seconds to keep message on screen. clear_console(...) \u2014 clear_console( (PyMessages)arg1) -> None : clear_console( (PyMessages)arg1) -> None : Remove currently displayed message in the message bar. show_in_dialog(...) \u2014 show_in_dialog( (PyMessages)arg1, (str)title, (str)message, (str)type, (list)buttons [, (str)cancel_button='']) -> str : show_in_dialog( (PyMessages)arg1, (str)title, (str)message, (str)type, (list)buttons [, (str)cancel_button='']) -> str : Display a custom dialog with a selection of options. Keywords argument: title -- The title of the dialog. message -- The message displayed in the centre of the dialog. type -- The type of dialog. Can be error, info, question, or warning. buttons -- The list of titles used to refer to the options cancel_button -- The text displayed in the cancel option","title":"Class: PyMessages"},{"location":"api/classes/PyMessages/#class-pymessages","text":"Module : flame Module handling message bar in application UI.","title":"Class: PyMessages"},{"location":"api/classes/PyMessages/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMessages/#built-in-methods","text":"show_in_console(...) \u2014 show_in_console( (PyMessages)arg1, (str)message [, (str)type='info' [, (int)duration=-1]]) -> None : show_in_console( (PyMessages)arg1, (str)message [, (str)type='info' [, (int)duration=-1]]) -> None : Display an informative message in application message bar. message -- Message string to display. type -- Message type can be info, warning, or error. duration -- An optional time in seconds to keep message on screen. clear_console(...) \u2014 clear_console( (PyMessages)arg1) -> None : clear_console( (PyMessages)arg1) -> None : Remove currently displayed message in the message bar. show_in_dialog(...) \u2014 show_in_dialog( (PyMessages)arg1, (str)title, (str)message, (str)type, (list)buttons [, (str)cancel_button='']) -> str : show_in_dialog( (PyMessages)arg1, (str)title, (str)message, (str)type, (list)buttons [, (str)cancel_button='']) -> str : Display a custom dialog with a selection of options. Keywords argument: title -- The title of the dialog. message -- The message displayed in the centre of the dialog. type -- The type of dialog. Can be error, info, question, or warning. buttons -- The list of titles used to refer to the options cancel_button -- The text displayed in the cancel option","title":"Built-in methods"},{"location":"api/classes/PyMetadataNode/","text":"Class: PyMetadataNode Module : flame Class derived from PyNode. This class represents a Metadata node. Methods Built-in methods set_metadata_value(...) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. set_metadata_discarded(...) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key. set_metadata_key(...) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value. load_node_setup(...) \u2014 load_node_setup( (PyMetadataNode)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)replaced_keys=True [, (bool)update_tokens=True]]]]]) -> bool : load_node_setup( (PyMetadataNode)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)replaced_keys=True [, (bool)update_tokens=True]]]]]) -> bool : Load a Metadata Node setup. Keywords argument: file_name -- the path and file name of the setup. edited_keys -- apply edited keys from the setup. discarded_keys -- apply discarded keys from the setup. added_keys -- apply added keys from the setup. replaced_keys -- apply replaced keys from the setup.","title":"Class: PyMetadataNode"},{"location":"api/classes/PyMetadataNode/#class-pymetadatanode","text":"Module : flame Class derived from PyNode. This class represents a Metadata node.","title":"Class: PyMetadataNode"},{"location":"api/classes/PyMetadataNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMetadataNode/#built-in-methods","text":"set_metadata_value(...) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. set_metadata_discarded(...) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key. set_metadata_key(...) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value. load_node_setup(...) \u2014 load_node_setup( (PyMetadataNode)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)replaced_keys=True [, (bool)update_tokens=True]]]]]) -> bool : load_node_setup( (PyMetadataNode)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)replaced_keys=True [, (bool)update_tokens=True]]]]]) -> bool : Load a Metadata Node setup. Keywords argument: file_name -- the path and file name of the setup. edited_keys -- apply edited keys from the setup. discarded_keys -- apply discarded keys from the setup. added_keys -- apply added keys from the setup. replaced_keys -- apply replaced keys from the setup.","title":"Built-in methods"},{"location":"api/classes/PyMetadataTimelineFX/","text":"Class: PyMetadataTimelineFX Module : flame Object representing a Metadata Timeline FX. Methods Built-in methods get_metadata(...) \u2014 get_metadata( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (int)frame=1]]) -> object : get_metadata( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (int)frame=1]]) -> object : Return the metadata of a Metadata Timeline FX. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. frame -- Frame number. The first exposed frame being 1. If not specified, the current frame is used. set_metadata_value(...) \u2014 set_metadata_value( (PyMetadataTimelineFX)arg1, (str)key [, (object)value=None]) -> None : set_metadata_value( (PyMetadataTimelineFX)arg1, (str)key [, (object)value=None]) -> None : Set the metadata on a Metadata Timeline FX. Keywords argument: key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. set_metadata_discarded(...) \u2014 set_metadata_discarded( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (bool)discarded=True]]) -> None : set_metadata_discarded( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (bool)discarded=True]]) -> None : Discard key from the metadata output of a Metadata Timeline FX. Keywords argument: key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the Metadata Timeline FX output, False to restore the key. set_metadata_key(...) \u2014 set_metadata_key( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (object)name=None]]) -> None : set_metadata_key( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (object)name=None]]) -> None : Rename a metadata key on a Metadata Timeline FX. Keyword arguments: key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value. load_setup(...) \u2014 load_setup( (PyMetadataTimelineFX)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)update_tokens=True]]]]) -> bool : load_setup( (PyMetadataTimelineFX)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)update_tokens=True]]]]) -> bool : Load a Metadata Timeline FX setup. Keywords argument: file_name -- the path and file name of the setup. edited_keys -- apply edited keys from the setup. discarded_keys -- apply discarded keys from the setup. added_keys -- apply added keys from the setup.","title":"Class: PyMetadataTimelineFX"},{"location":"api/classes/PyMetadataTimelineFX/#class-pymetadatatimelinefx","text":"Module : flame Object representing a Metadata Timeline FX.","title":"Class: PyMetadataTimelineFX"},{"location":"api/classes/PyMetadataTimelineFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMetadataTimelineFX/#built-in-methods","text":"get_metadata(...) \u2014 get_metadata( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (int)frame=1]]) -> object : get_metadata( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (int)frame=1]]) -> object : Return the metadata of a Metadata Timeline FX. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. frame -- Frame number. The first exposed frame being 1. If not specified, the current frame is used. set_metadata_value(...) \u2014 set_metadata_value( (PyMetadataTimelineFX)arg1, (str)key [, (object)value=None]) -> None : set_metadata_value( (PyMetadataTimelineFX)arg1, (str)key [, (object)value=None]) -> None : Set the metadata on a Metadata Timeline FX. Keywords argument: key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. set_metadata_discarded(...) \u2014 set_metadata_discarded( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (bool)discarded=True]]) -> None : set_metadata_discarded( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (bool)discarded=True]]) -> None : Discard key from the metadata output of a Metadata Timeline FX. Keywords argument: key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the Metadata Timeline FX output, False to restore the key. set_metadata_key(...) \u2014 set_metadata_key( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (object)name=None]]) -> None : set_metadata_key( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (object)name=None]]) -> None : Rename a metadata key on a Metadata Timeline FX. Keyword arguments: key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value. load_setup(...) \u2014 load_setup( (PyMetadataTimelineFX)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)update_tokens=True]]]]) -> bool : load_setup( (PyMetadataTimelineFX)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)update_tokens=True]]]]) -> bool : Load a Metadata Timeline FX setup. Keywords argument: file_name -- the path and file name of the setup. edited_keys -- apply edited keys from the setup. discarded_keys -- apply discarded keys from the setup. added_keys -- apply added keys from the setup.","title":"Built-in methods"},{"location":"api/classes/PyMetadataValue/","text":"Class: PyMetadataValue Module : flame This class holds the metadata of a specific data type. Methods Properties type(...) \u2014 None( (flame.PyMetadataValue)arg1) -> str None( (flame.PyMetadataValue)arg1) -> str Built-in methods get_value(...) \u2014 get_value( (PyMetadataValue)arg1) -> object : get_value( (PyMetadataValue)arg1) -> object : Get the metadata value. set_value(...) \u2014 set_value( (PyMetadataValue)arg1, (object)value) -> None : set_value( (PyMetadataValue)arg1, (object)value) -> None : Set the metadata value.","title":"Class: PyMetadataValue"},{"location":"api/classes/PyMetadataValue/#class-pymetadatavalue","text":"Module : flame This class holds the metadata of a specific data type.","title":"Class: PyMetadataValue"},{"location":"api/classes/PyMetadataValue/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMetadataValue/#properties","text":"type(...) \u2014 None( (flame.PyMetadataValue)arg1) -> str None( (flame.PyMetadataValue)arg1) -> str","title":"Properties"},{"location":"api/classes/PyMetadataValue/#built-in-methods","text":"get_value(...) \u2014 get_value( (PyMetadataValue)arg1) -> object : get_value( (PyMetadataValue)arg1) -> object : Get the metadata value. set_value(...) \u2014 set_value( (PyMetadataValue)arg1, (object)value) -> None : set_value( (PyMetadataValue)arg1, (object)value) -> None : Set the metadata value.","title":"Built-in methods"},{"location":"api/classes/PyMorphNode/","text":"Class: PyMorphNode Module : flame Object representing a Morph node. Methods Built-in methods set_mix_to_range(...) \u2014 set_mix_to_range( (PyMorphNode)arg1) -> None : set_mix_to_range( (PyMorphNode)arg1) -> None : Move the first and last keyframes of the mix curve to the range's first and last frame.","title":"Class: PyMorphNode"},{"location":"api/classes/PyMorphNode/#class-pymorphnode","text":"Module : flame Object representing a Morph node.","title":"Class: PyMorphNode"},{"location":"api/classes/PyMorphNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyMorphNode/#built-in-methods","text":"set_mix_to_range(...) \u2014 set_mix_to_range( (PyMorphNode)arg1) -> None : set_mix_to_range( (PyMorphNode)arg1) -> None : Move the first and last keyframes of the mix curve to the range's first and last frame.","title":"Built-in methods"},{"location":"api/classes/PyNode/","text":"Class: PyNode Module : flame Object representing a Node. Methods Properties sockets(...) \u2014 None( (flame.PyNode)arg1) -> dict None( (flame.PyNode)arg1) -> dict input_sockets(...) \u2014 None( (flame.PyNode)arg1) -> list None( (flame.PyNode)arg1) -> list output_sockets(...) \u2014 None( (flame.PyNode)arg1) -> list None( (flame.PyNode)arg1) -> list Built-in methods load_node_setup(...) \u2014 load_node_setup( (PyNode)arg1, (str)file_name) -> bool : load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. save_node_setup(...) \u2014 save_node_setup( (PyNode)arg1, (str)file_name) -> bool : save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. delete(...) \u2014 delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate(...) \u2014 duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. set_context(...) \u2014 set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments. clear_schematic_colour(...) \u2014 clear_schematic_colour( (PyNode)arg1) -> None : clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. get_metadata(...) \u2014 get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. cache_range(...) \u2014 cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. output_channel_as_metadata_key(...) \u2014 output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"Class: PyNode"},{"location":"api/classes/PyNode/#class-pynode","text":"Module : flame Object representing a Node.","title":"Class: PyNode"},{"location":"api/classes/PyNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyNode/#properties","text":"sockets(...) \u2014 None( (flame.PyNode)arg1) -> dict None( (flame.PyNode)arg1) -> dict input_sockets(...) \u2014 None( (flame.PyNode)arg1) -> list None( (flame.PyNode)arg1) -> list output_sockets(...) \u2014 None( (flame.PyNode)arg1) -> list None( (flame.PyNode)arg1) -> list","title":"Properties"},{"location":"api/classes/PyNode/#built-in-methods","text":"load_node_setup(...) \u2014 load_node_setup( (PyNode)arg1, (str)file_name) -> bool : load_node_setup( (PyNode)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. save_node_setup(...) \u2014 save_node_setup( (PyNode)arg1, (str)file_name) -> bool : save_node_setup( (PyNode)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. delete(...) \u2014 delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool : Delete the node. duplicate(...) \u2014 duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object : Duplicate the node. set_context(...) \u2014 set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool : Set a Context view on a Node socket. An index and a socket name must be defined as arguments. clear_schematic_colour(...) \u2014 clear_schematic_colour( (PyNode)arg1) -> None : clear_schematic_colour( (PyNode)arg1) -> None : Clear the schematic colour of the Node. get_metadata(...) \u2014 get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object : Return the metadata of the Node. Keyword arguments: socket_name -- The socket from which to pull the metadata. The default output is used when not specified. key -- key of the requested metadata. All metadata is returned when not specified. frame -- frame of the requested metadata. The current frame is used when not specified. cache_range(...) \u2014 cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int : Cache the Node result. Keyword arguments: start -- The first frame of the cache range. The current Batch start frame is used when not specified. end -- The last frame of the cache range. The current Batch end frame is used when not specified. output_channel_as_metadata_key(...) \u2014 output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Node name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"Built-in methods"},{"location":"api/classes/PyOFXNode/","text":"Class: PyOFXNode Module : flame Object representing a OpenFX node. Methods Built-in methods change_plugin(...) \u2014 change_plugin( (PyOFXNode)arg1, (str)plugin_name) -> bool : change_plugin( (PyOFXNode)arg1, (str)plugin_name) -> bool : Change the active plugin for the openFX node","title":"Class: PyOFXNode"},{"location":"api/classes/PyOFXNode/#class-pyofxnode","text":"Module : flame Object representing a OpenFX node.","title":"Class: PyOFXNode"},{"location":"api/classes/PyOFXNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyOFXNode/#built-in-methods","text":"change_plugin(...) \u2014 change_plugin( (PyOFXNode)arg1, (str)plugin_name) -> bool : change_plugin( (PyOFXNode)arg1, (str)plugin_name) -> bool : Change the active plugin for the openFX node","title":"Built-in methods"},{"location":"api/classes/PyPaintNode/","text":"Class: PyPaintNode Module : flame Object representing a Paint node. Methods Built-in methods add_source(...) \u2014 add_source( (PyPaintNode)arg1) -> object : add_source( (PyPaintNode)arg1) -> object : Add a Source layer to a Paint node.","title":"Class: PyPaintNode"},{"location":"api/classes/PyPaintNode/#class-pypaintnode","text":"Module : flame Object representing a Paint node.","title":"Class: PyPaintNode"},{"location":"api/classes/PyPaintNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyPaintNode/#built-in-methods","text":"add_source(...) \u2014 add_source( (PyPaintNode)arg1) -> object : add_source( (PyPaintNode)arg1) -> object : Add a Source layer to a Paint node.","title":"Built-in methods"},{"location":"api/classes/PyProject/","text":"Class: PyProject Module : flame Object representing a Project. Methods Properties name(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str nickname(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str description(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str project_name(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str workspaces_count(...) \u2014 None( (flame.PyProject)arg1) -> int None( (flame.PyProject)arg1) -> int current_workspace(...) \u2014 None( (flame.PyProject)arg1) -> object None( (flame.PyProject)arg1) -> object shared_libraries(...) \u2014 None( (flame.PyProject)arg1) -> list None( (flame.PyProject)arg1) -> list project_folder(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str setups_folder(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str media_folder(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str Built-in methods create_shared_library(...) \u2014 create_shared_library( (PyProject)arg1, (str)name) -> object : create_shared_library( (PyProject)arg1, (str)name) -> object : Create a new Shared Library in the Project. refresh_shared_libraries(...) \u2014 refresh_shared_libraries( (PyProject)arg1) -> bool : refresh_shared_libraries( (PyProject)arg1) -> bool : Refresh the Shared Libraries list in the Media Panel. reload_ocio_config(...) \u2014 reload_ocio_config( (PyProject)arg1 [, (bool)reset_colour_policy=False]) -> bool : reload_ocio_config( (PyProject)arg1 [, (bool)reset_colour_policy=False]) -> bool : Reload the OCIO config file. Keyword argument: reset_colour_policy -- Delete the project's custom colour spaces, roles, and rules (false by default). export_ocio_config(...) \u2014 export_ocio_config( (PyProject)arg1, (str)config_name [, (str)destination_folder='' [, (bool)overwrite_existing=False [, (bool)export_as_locked=False [, (bool)generate_ocioz=False]]]]) -> bool : export_ocio_config( (PyProject)arg1, (str)config_name [, (str)destination_folder='' [, (bool)overwrite_existing=False [, (bool)export_as_locked=False [, (bool)generate_ocioz=False]]]]) -> bool : Export the OCIO config file. Keyword arguments: config_name -- Specifies the name that will be written inside the exported OCIO config and used as the parent folder name where the config will be exported. It should not contain the '.ocio' extension. Mandatory. destination_folder -- Specifies the absolute destination folder for the exported OCIO config. It will use the default colour management shared path if empty. overwrite_existing -- Specifies if the export should overwrite an existing OCIO config with the same name located in the same destination_folder. export_as_locked -- Specifies if the exported OCIO config should be locked (the 'LockedPolicy' parameter inside the settings.cfg sidecar file). generate_ocioz -- Specifies if an OCIOZ archive should be created alongside the exported OCIO config. set_context_variable(...) \u2014 set_context_variable( (PyProject)arg1, (str)name, (str)value) -> None : set_context_variable( (PyProject)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable. get_context_variables(...) \u2014 get_context_variables( (PyProject)arg1) -> dict : get_context_variables( (PyProject)arg1) -> dict : Get the context variables in a dictionary. reset_context_variables(...) \u2014 reset_context_variables( (PyProject)arg1) -> None : reset_context_variables( (PyProject)arg1) -> None : Reset the context variables to their initial state from the ocio config.","title":"Class: PyProject"},{"location":"api/classes/PyProject/#class-pyproject","text":"Module : flame Object representing a Project.","title":"Class: PyProject"},{"location":"api/classes/PyProject/#methods","text":"","title":"Methods"},{"location":"api/classes/PyProject/#properties","text":"name(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str nickname(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str description(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str project_name(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str workspaces_count(...) \u2014 None( (flame.PyProject)arg1) -> int None( (flame.PyProject)arg1) -> int current_workspace(...) \u2014 None( (flame.PyProject)arg1) -> object None( (flame.PyProject)arg1) -> object shared_libraries(...) \u2014 None( (flame.PyProject)arg1) -> list None( (flame.PyProject)arg1) -> list project_folder(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str setups_folder(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str media_folder(...) \u2014 None( (flame.PyProject)arg1) -> str None( (flame.PyProject)arg1) -> str","title":"Properties"},{"location":"api/classes/PyProject/#built-in-methods","text":"create_shared_library(...) \u2014 create_shared_library( (PyProject)arg1, (str)name) -> object : create_shared_library( (PyProject)arg1, (str)name) -> object : Create a new Shared Library in the Project. refresh_shared_libraries(...) \u2014 refresh_shared_libraries( (PyProject)arg1) -> bool : refresh_shared_libraries( (PyProject)arg1) -> bool : Refresh the Shared Libraries list in the Media Panel. reload_ocio_config(...) \u2014 reload_ocio_config( (PyProject)arg1 [, (bool)reset_colour_policy=False]) -> bool : reload_ocio_config( (PyProject)arg1 [, (bool)reset_colour_policy=False]) -> bool : Reload the OCIO config file. Keyword argument: reset_colour_policy -- Delete the project's custom colour spaces, roles, and rules (false by default). export_ocio_config(...) \u2014 export_ocio_config( (PyProject)arg1, (str)config_name [, (str)destination_folder='' [, (bool)overwrite_existing=False [, (bool)export_as_locked=False [, (bool)generate_ocioz=False]]]]) -> bool : export_ocio_config( (PyProject)arg1, (str)config_name [, (str)destination_folder='' [, (bool)overwrite_existing=False [, (bool)export_as_locked=False [, (bool)generate_ocioz=False]]]]) -> bool : Export the OCIO config file. Keyword arguments: config_name -- Specifies the name that will be written inside the exported OCIO config and used as the parent folder name where the config will be exported. It should not contain the '.ocio' extension. Mandatory. destination_folder -- Specifies the absolute destination folder for the exported OCIO config. It will use the default colour management shared path if empty. overwrite_existing -- Specifies if the export should overwrite an existing OCIO config with the same name located in the same destination_folder. export_as_locked -- Specifies if the exported OCIO config should be locked (the 'LockedPolicy' parameter inside the settings.cfg sidecar file). generate_ocioz -- Specifies if an OCIOZ archive should be created alongside the exported OCIO config. set_context_variable(...) \u2014 set_context_variable( (PyProject)arg1, (str)name, (str)value) -> None : set_context_variable( (PyProject)arg1, (str)name, (str)value) -> None : Set the value for the specified context variable. get_context_variables(...) \u2014 get_context_variables( (PyProject)arg1) -> dict : get_context_variables( (PyProject)arg1) -> dict : Get the context variables in a dictionary. reset_context_variables(...) \u2014 reset_context_variables( (PyProject)arg1) -> None : reset_context_variables( (PyProject)arg1) -> None : Reset the context variables to their initial state from the ocio config.","title":"Built-in methods"},{"location":"api/classes/PyProjectSelector/","text":"Class: PyProjectSelector Module : flame Object representing the Project manager. Methods Properties current_project(...) \u2014 None( (flame.PyProjectSelector)arg1) -> object None( (flame.PyProjectSelector)arg1) -> object","title":"Class: PyProjectSelector"},{"location":"api/classes/PyProjectSelector/#class-pyprojectselector","text":"Module : flame Object representing the Project manager.","title":"Class: PyProjectSelector"},{"location":"api/classes/PyProjectSelector/#methods","text":"","title":"Methods"},{"location":"api/classes/PyProjectSelector/#properties","text":"current_project(...) \u2014 None( (flame.PyProjectSelector)arg1) -> object None( (flame.PyProjectSelector)arg1) -> object","title":"Properties"},{"location":"api/classes/PyReadFileNode/","text":"Class: PyReadFileNode Module : flame Class derived from PyNode. This class represents a ReadFile node.","title":"Class: PyReadFileNode"},{"location":"api/classes/PyReadFileNode/#class-pyreadfilenode","text":"Module : flame Class derived from PyNode. This class represents a ReadFile node.","title":"Class: PyReadFileNode"},{"location":"api/classes/PyReel/","text":"Class: PyReel Module : flame Object representing a Reel. Methods Properties children(...) \u2014 None( (flame.PyReel)arg1) -> list None( (flame.PyReel)arg1) -> list sequences(...) \u2014 None( (flame.PyReel)arg1) -> list None( (flame.PyReel)arg1) -> list clips(...) \u2014 None( (flame.PyReel)arg1) -> list None( (flame.PyReel)arg1) -> list type(...) \u2014 None( (flame.PyReel)arg1) -> object None( (flame.PyReel)arg1) -> object Built-in methods clear(...) \u2014 clear( (PyReel)arg1 [, (bool)confirm=True]) -> bool : clear( (PyReel)arg1 [, (bool)confirm=True]) -> bool : Clear the Reel content. create_sequence(...) \u2014 create_sequence( (PyReel)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : create_sequence( (PyReel)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by frame_rate . duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by frame_rate . If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all audio_tracks . False for mono tracks, True for stereo. save(...) \u2014 save( (PyReel)arg1) -> bool : save( (PyReel)arg1) -> bool : Save the Reel to the defined save destination.","title":"Class: PyReel"},{"location":"api/classes/PyReel/#class-pyreel","text":"Module : flame Object representing a Reel.","title":"Class: PyReel"},{"location":"api/classes/PyReel/#methods","text":"","title":"Methods"},{"location":"api/classes/PyReel/#properties","text":"children(...) \u2014 None( (flame.PyReel)arg1) -> list None( (flame.PyReel)arg1) -> list sequences(...) \u2014 None( (flame.PyReel)arg1) -> list None( (flame.PyReel)arg1) -> list clips(...) \u2014 None( (flame.PyReel)arg1) -> list None( (flame.PyReel)arg1) -> list type(...) \u2014 None( (flame.PyReel)arg1) -> object None( (flame.PyReel)arg1) -> object","title":"Properties"},{"location":"api/classes/PyReel/#built-in-methods","text":"clear(...) \u2014 clear( (PyReel)arg1 [, (bool)confirm=True]) -> bool : clear( (PyReel)arg1 [, (bool)confirm=True]) -> bool : Clear the Reel content. create_sequence(...) \u2014 create_sequence( (PyReel)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : create_sequence( (PyReel)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object : Create a Sequence in a PyReel, PyLibrary, PyFolder. Keywords arguments: video_tracks -- Number of video tracks. Integer between 1 and 8. video_stereo -- Stereoscopy. False for mono, True for stereo. width -- Integer between 24 and 16384. height -- Integer between 24 and 16384. ratio -- Frame aspect ratio. Float between 0.01 and 100. scan_mode -- Scan mode of the sequence. (F1, F2, P) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps) start_at -- Start timecode. The timecode format must be of the format specified by frame_rate . duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by frame_rate . If an integer, it represents a number of frames. audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16) audio_stereo -- Stereophony, apply to all audio_tracks . False for mono tracks, True for stereo. save(...) \u2014 save( (PyReel)arg1) -> bool : save( (PyReel)arg1) -> bool : Save the Reel to the defined save destination.","title":"Built-in methods"},{"location":"api/classes/PyReelGroup/","text":"Class: PyReelGroup Module : flame Object representing a Reel Group. Methods Properties children(...) \u2014 None( (flame.PyReelGroup)arg1) -> list None( (flame.PyReelGroup)arg1) -> list reels(...) \u2014 None( (flame.PyReelGroup)arg1) -> list None( (flame.PyReelGroup)arg1) -> list Built-in methods clear(...) \u2014 clear( (PyReelGroup)arg1 [, (bool)confirm=True]) -> bool : clear( (PyReelGroup)arg1 [, (bool)confirm=True]) -> bool : Clear the Reel Group content. create_reel(...) \u2014 create_reel( (PyReelGroup)arg1, (str)name [, (bool)sequence=False]) -> object : create_reel( (PyReelGroup)arg1, (str)name [, (bool)sequence=False]) -> object : Create a new Reel inside a Reel Group. save(...) \u2014 save( (PyReelGroup)arg1) -> bool : save( (PyReelGroup)arg1) -> bool : Save the Reel Group to the defined save destination.","title":"Class: PyReelGroup"},{"location":"api/classes/PyReelGroup/#class-pyreelgroup","text":"Module : flame Object representing a Reel Group.","title":"Class: PyReelGroup"},{"location":"api/classes/PyReelGroup/#methods","text":"","title":"Methods"},{"location":"api/classes/PyReelGroup/#properties","text":"children(...) \u2014 None( (flame.PyReelGroup)arg1) -> list None( (flame.PyReelGroup)arg1) -> list reels(...) \u2014 None( (flame.PyReelGroup)arg1) -> list None( (flame.PyReelGroup)arg1) -> list","title":"Properties"},{"location":"api/classes/PyReelGroup/#built-in-methods","text":"clear(...) \u2014 clear( (PyReelGroup)arg1 [, (bool)confirm=True]) -> bool : clear( (PyReelGroup)arg1 [, (bool)confirm=True]) -> bool : Clear the Reel Group content. create_reel(...) \u2014 create_reel( (PyReelGroup)arg1, (str)name [, (bool)sequence=False]) -> object : create_reel( (PyReelGroup)arg1, (str)name [, (bool)sequence=False]) -> object : Create a new Reel inside a Reel Group. save(...) \u2014 save( (PyReelGroup)arg1) -> bool : save( (PyReelGroup)arg1) -> bool : Save the Reel Group to the defined save destination.","title":"Built-in methods"},{"location":"api/classes/PyRenderNode/","text":"Class: PyRenderNode Module : flame Class derived from PyNode. This class represents a Render node. Methods Properties channels(...) \u2014 None( (flame.PyRenderNode)arg1) -> list None( (flame.PyRenderNode)arg1) -> list Built-in methods set_channel_name(...) \u2014 set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None : set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None : Rename a channel, using its index or front channel name as the index key. Keyword arguments: channel -- The channel to rename. Can be the channel index or the current name of the channel's front socket. name -- The new name of the channel. The type is either a string or a tuple. A Write File node always takes a string. A Render node takes a string or a tuple. In a Render node, a string only sets the name of the channel's front socket; the function creates the name of the matte socket by appending '_alpha' to 'name'. In the UI, the channel is flagged 'Sync'. A Write File node has only one socket per channel, and requires only a string to set a socket name. In a Render node, a tuple sets the names of the front and matte sockets. In the UI, the channel is not flagged 'Sync'. A Write File node does not accept a tuple. set_metadata_value(...) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None : set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. is_dynamic -- Set the Metadata value to be resolved dynamically if it contains tokens. set_metadata_discarded(...) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key. set_metadata_key(...) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value.","title":"Class: PyRenderNode"},{"location":"api/classes/PyRenderNode/#class-pyrendernode","text":"Module : flame Class derived from PyNode. This class represents a Render node.","title":"Class: PyRenderNode"},{"location":"api/classes/PyRenderNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyRenderNode/#properties","text":"channels(...) \u2014 None( (flame.PyRenderNode)arg1) -> list None( (flame.PyRenderNode)arg1) -> list","title":"Properties"},{"location":"api/classes/PyRenderNode/#built-in-methods","text":"set_channel_name(...) \u2014 set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None : set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None : Rename a channel, using its index or front channel name as the index key. Keyword arguments: channel -- The channel to rename. Can be the channel index or the current name of the channel's front socket. name -- The new name of the channel. The type is either a string or a tuple. A Write File node always takes a string. A Render node takes a string or a tuple. In a Render node, a string only sets the name of the channel's front socket; the function creates the name of the matte socket by appending '_alpha' to 'name'. In the UI, the channel is flagged 'Sync'. A Write File node has only one socket per channel, and requires only a string to set a socket name. In a Render node, a tuple sets the names of the front and matte sockets. In the UI, the channel is not flagged 'Sync'. A Write File node does not accept a tuple. set_metadata_value(...) \u2014 set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None : set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None : Set the metadata on the Node. Keyword arguments: socket_name -- The socket on which to set the metadata. The default output is used when not specified. key -- Metadata key to be set or added. value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value. is_dynamic -- Set the Metadata value to be resolved dynamically if it contains tokens. set_metadata_discarded(...) \u2014 set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None : Discard key from the Node's metadata output. Keyword arguments: socket_name -- The socket on which the discarded status of the metadata must be changed. key -- Metadata key to be discarded or restored. discarded -- True to discard the key from the node metadata output, False to restore the key. set_metadata_key(...) \u2014 set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None : Rename a metadata key on the Node. Keyword arguments: socket_name -- The socket on which to rename the key. The default output is used when not specified. key -- The current metadata key name to be renamed. name -- The new metadata key name. If None, the current key name will revert to its original value.","title":"Built-in methods"},{"location":"api/classes/PyResolution/","text":"Class: PyResolution Module : flame Object representing a resolution PyResolution() PyResolution(width, height, bit_depth, frame_ratio, scan_format) Methods Properties resolution(...) \u2014 None( (flame.PyResolution)arg1) -> str None( (flame.PyResolution)arg1) -> str width(...) \u2014 None( (flame.PyResolution)arg1) -> int None( (flame.PyResolution)arg1) -> int height(...) \u2014 None( (flame.PyResolution)arg1) -> int None( (flame.PyResolution)arg1) -> int frame_ratio(...) \u2014 None( (flame.PyResolution)arg1) -> float None( (flame.PyResolution)arg1) -> float scan_mode(...) \u2014 None( (flame.PyResolution)arg1) -> str None( (flame.PyResolution)arg1) -> str bit_depth(...) \u2014 None( (flame.PyResolution)arg1) -> int None( (flame.PyResolution)arg1) -> int","title":"Class: PyResolution"},{"location":"api/classes/PyResolution/#class-pyresolution","text":"Module : flame Object representing a resolution PyResolution() PyResolution(width, height, bit_depth, frame_ratio, scan_format)","title":"Class: PyResolution"},{"location":"api/classes/PyResolution/#methods","text":"","title":"Methods"},{"location":"api/classes/PyResolution/#properties","text":"resolution(...) \u2014 None( (flame.PyResolution)arg1) -> str None( (flame.PyResolution)arg1) -> str width(...) \u2014 None( (flame.PyResolution)arg1) -> int None( (flame.PyResolution)arg1) -> int height(...) \u2014 None( (flame.PyResolution)arg1) -> int None( (flame.PyResolution)arg1) -> int frame_ratio(...) \u2014 None( (flame.PyResolution)arg1) -> float None( (flame.PyResolution)arg1) -> float scan_mode(...) \u2014 None( (flame.PyResolution)arg1) -> str None( (flame.PyResolution)arg1) -> str bit_depth(...) \u2014 None( (flame.PyResolution)arg1) -> int None( (flame.PyResolution)arg1) -> int","title":"Properties"},{"location":"api/classes/PySearch/","text":"Class: PySearch Module : flame This class represents the search. Methods Properties use_weight(...) \u2014 None( (flame.PySearch)arg1) -> bool None( (flame.PySearch)arg1) -> bool Built-in methods set_tool_favorite(...) \u2014 set_tool_favorite( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : set_tool_favorite( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : Return the favorite status of a tool. set_tool_hidden(...) \u2014 set_tool_hidden( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : set_tool_hidden( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : Return the hidden status of a tool. set_tool_weight(...) \u2014 set_tool_weight( (PySearch)arg1, (str)arg2, (str)name, (int)type) -> None : set_tool_weight( (PySearch)arg1, (str)arg2, (str)name, (int)type) -> None : Return the tool weight. search_results(...) \u2014 search_results( (PySearch)arg1 [, (str)search_str=' ' [, (str)tab='Tools']]) -> list : search_results( (PySearch)arg1 [, (str)search_str=' ' [, (str)tab='Tools']]) -> list : Search results that match a string. activate_search_result(...) \u2014 activate_search_result( (PySearch)arg1, (str)name, (str)type [, (str)tab='Tools']) -> None : activate_search_result( (PySearch)arg1, (str)name, (str)type [, (str)tab='Tools']) -> None : Activate a search result.","title":"Class: PySearch"},{"location":"api/classes/PySearch/#class-pysearch","text":"Module : flame This class represents the search.","title":"Class: PySearch"},{"location":"api/classes/PySearch/#methods","text":"","title":"Methods"},{"location":"api/classes/PySearch/#properties","text":"use_weight(...) \u2014 None( (flame.PySearch)arg1) -> bool None( (flame.PySearch)arg1) -> bool","title":"Properties"},{"location":"api/classes/PySearch/#built-in-methods","text":"set_tool_favorite(...) \u2014 set_tool_favorite( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : set_tool_favorite( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : Return the favorite status of a tool. set_tool_hidden(...) \u2014 set_tool_hidden( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : set_tool_hidden( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None : Return the hidden status of a tool. set_tool_weight(...) \u2014 set_tool_weight( (PySearch)arg1, (str)arg2, (str)name, (int)type) -> None : set_tool_weight( (PySearch)arg1, (str)arg2, (str)name, (int)type) -> None : Return the tool weight. search_results(...) \u2014 search_results( (PySearch)arg1 [, (str)search_str=' ' [, (str)tab='Tools']]) -> list : search_results( (PySearch)arg1 [, (str)search_str=' ' [, (str)tab='Tools']]) -> list : Search results that match a string. activate_search_result(...) \u2014 activate_search_result( (PySearch)arg1, (str)name, (str)type [, (str)tab='Tools']) -> None : activate_search_result( (PySearch)arg1, (str)name, (str)type [, (str)tab='Tools']) -> None : Activate a search result.","title":"Built-in methods"},{"location":"api/classes/PySegment/","text":"Class: PySegment Module : flame Object representing a Segment. Methods Properties source_name(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_in(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object source_out(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object source_duration(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object source_width(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_height(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_bit_depth(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_ratio(...) \u2014 None( (flame.PySegment)arg1) -> float None( (flame.PySegment)arg1) -> float source_scan_mode(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_frame_rate(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_cached(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_has_history(...) \u2014 None( (flame.PySegment)arg1) -> bool None( (flame.PySegment)arg1) -> bool source_unlinked(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_sample_rate(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_audio_track(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_essence_uid(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_uid(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str original_source_uid(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_colour_primaries(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_transfer_characteristics(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_matrix_coefficients(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int tape_name(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str record_in(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object record_out(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object record_duration(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object start_frame(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int file_path(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str markers(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list effect_types(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list effects(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list groups(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list type(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str head(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object tail(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object rgb_channel(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str matte_channel(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str rgb_channels(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list matte_channels(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list version_uid(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str version_uids(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list matte_mode(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str container_clip(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object Built-in methods create_effect(...) \u2014 create_effect( (PySegment)arg1, (str)effect_type [, (str)after_effect_type='']) -> object : create_effect( (PySegment)arg1, (str)effect_type [, (str)after_effect_type='']) -> object : Add an effect of effect_type on the Segment. after_effect_type can be specified to insert the effect at a specific position. create_marker(...) \u2014 create_marker( (PySegment)arg1, (object)location) -> object : create_marker( (PySegment)arg1, (object)location) -> object : Create a Marker at the specified location on the Segment. create_connection(...) \u2014 create_connection( (PySegment)arg1) -> None : create_connection( (PySegment)arg1) -> None : Create a connected segment connection. remove_connection(...) \u2014 remove_connection( (PySegment)arg1) -> None : remove_connection( (PySegment)arg1) -> None : Remove the connected segment connection. sync_connected_segments(...) \u2014 sync_connected_segments( (PySegment)arg1) -> None : sync_connected_segments( (PySegment)arg1) -> None : Sync connected segments with the Timeline FXs of the current segment. connected_segments(...) \u2014 connected_segments( (PySegment)arg1 [, (str)scoping='all reels']) -> object : connected_segments( (PySegment)arg1 [, (str)scoping='all reels']) -> object : Return a list of the connected segments. Keywords argument: scoping -- Scopes of the sequences to query (all reels, sequences reels, current reel, current sequence). (Default:all reels) duplicate_source(...) \u2014 duplicate_source( (PySegment)arg1) -> None : duplicate_source( (PySegment)arg1) -> None : Insure that the segment's source is not shared anymore. shared_source_segments(...) \u2014 shared_source_segments( (PySegment)arg1) -> object : shared_source_segments( (PySegment)arg1) -> object : Return a list of the segments sharing this segment's source. copy_to_media_panel(...) \u2014 copy_to_media_panel( (PySegment)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : copy_to_media_panel( (PySegment)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject. trim_head(...) \u2014 trim_head( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : trim_head( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : Modify the amount of head of the PySegment. Keywords argument: offset -- Number of frames to add or remove from the head. ripple -- Enable to prevent gaps from appearing when performing a trim. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop) trim_tail(...) \u2014 trim_tail( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : trim_tail( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : Modify the amount of tail of the PySegment. Keywords argument: offset -- Number of frames to add or remove from the tail. ripple -- Enable to prevent gaps from appearing when performing a trim. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop) slip(...) \u2014 slip( (PySegment)arg1, (int)offset [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]) -> bool : slip( (PySegment)arg1, (int)offset [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]) -> bool : Slip the media of the PySegment. Keywords argument: offset -- Relative offset to slip the media. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop) slide_keyframes(...) \u2014 slide_keyframes( (PySegment)arg1, (int)offset [, (bool)sync=False]) -> bool : slide_keyframes( (PySegment)arg1, (int)offset [, (bool)sync=False]) -> bool : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. set_gap_colour(...) \u2014 set_gap_colour( (PySegment)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : set_gap_colour( (PySegment)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : Create a colour source segment for the duration of the gap, or set the colour of an existing colour source. set_gap_bars(...) \u2014 set_gap_bars( (PySegment)arg1 [, (str)type='smpte' [, (bool)full_luminance=False [, (float)softness=0.0]]]) -> object : set_gap_bars( (PySegment)arg1 [, (str)type='smpte' [, (bool)full_luminance=False [, (float)softness=0.0]]]) -> object : Create colour bars segment for the duration of the gap. Returns a new PySegment on success. Keywords argument: type -- smpte or pal. full_luminance -- bars created at 100 or 75 percent luminance. softness -- softness to apply between the bars. smart_replace(...) \u2014 smart_replace( (PySegment)arg1, (PyClip)source_clip) -> None : smart_replace( (PySegment)arg1, (PyClip)source_clip) -> None : Replace the PySegment by the source_clip segment, including the Timeline FX. smart_replace_media(...) \u2014 smart_replace_media( (PySegment)arg1, (PyClip)source_clip) -> None : smart_replace_media( (PySegment)arg1, (PyClip)source_clip) -> None : Replace the media of PySegment by the source_clip segment, leaving the PySegment Timeline FX untouched match(...) \u2014 match( (PySegment)arg1, (PyArchiveEntry)destination [, (bool)preserve_handle=False [, (bool)use_sequence_info=True [, (bool)include_nested_content=False [, (bool)include_timeline_fx=False]]]]) -> object : match( (PySegment)arg1, (PyArchiveEntry)destination [, (bool)preserve_handle=False [, (bool)use_sequence_info=True [, (bool)include_nested_content=False [, (bool)include_timeline_fx=False]]]]) -> object : Match out the media of the PySegment to the destination. Returns a PyClip or a list of PyClip (with the included_nested_content option). Keywords argument: destination -- The PyObject that acts as the destination. preserve_handle -- Prevent the unrolling of the media handles. use_sequence_info -- Copy sequence segment information to the new matched clip. include_nested_content -- Include all sources found inside a BFX or Matte Container. include_timeline_fx -- Copy the Timeline FX present on the original clip to the new matched clip. clear_colour(...) \u2014 clear_colour( (PySegment)arg1) -> None : clear_colour( (PySegment)arg1) -> None : Clear the colour of the Segment. set_rgb_channel(...) \u2014 set_rgb_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences']]]) -> bool : set_rgb_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences']]]) -> bool : Set the RGB channel of the source specified by channel_index or by channel_name Keywords argument: channel_name -- Name of the channel found in rgb_channels. channel_index -- Index of the channel found in rgb_channels. scope -- Scope of the changes ( Follow Preferences, No Sharing, Follow Source Sharing, Follow Connected Segments). set_matte_channel(...) \u2014 set_matte_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences' [, (str)matte_mode='Custom Matte']]]]) -> bool : set_matte_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences' [, (str)matte_mode='Custom Matte']]]]) -> bool : Set the Matte channel of the source specified by channel_index or by channel_name if the matte_mode is set to Custom Matte. Keywords argument: channel_name -- Name of the channel found in matte_channels. channel_index -- Index of the channel found in matte_channels. scope -- Scope of the changes ( Follow Preferences, No Sharing, Follow Source Sharing, Follow Connected Segments). matte_mode -- Matte origin (Follow RGB, No Matte, Custom Matte). set_version_uid(...) \u2014 set_version_uid( (PySegment)arg1, (str)version_uid [, (str)scope='Follow Source Sharing']) -> bool : set_version_uid( (PySegment)arg1, (str)version_uid [, (str)scope='Follow Source Sharing']) -> bool : Set the current version unique ID of the source. Keywords argument: version_uid -- version unique ID. scope -- Scope of the changes ( No Sharing, Follow Source Sharing, Follow Connected Segments). get_colour_space(...) \u2014 get_colour_space( (PySegment)arg1 [, (PyTime)time=None]) -> str : get_colour_space( (PySegment)arg1 [, (PyTime)time=None]) -> str : Return the colour space at the requested time. Use record_in when no time is supplied. create_unlinked_segment(...) \u2014 create_unlinked_segment( (PySegment)arg1 [, (str)source_name='' [, (str)tape_name='' [, (object)start_time=0 [, (object)source_duration=0 [, (object)head=0 [, (str)file_path='' [, (int)source_audio_track=1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='Same As Sequence' [, (str)frame_rate='Same As Sequence' [, (object)timewarp_speed=None]]]]]]]]]]]]]]) -> None : create_unlinked_segment( (PySegment)arg1 [, (str)source_name='' [, (str)tape_name='' [, (object)start_time=0 [, (object)source_duration=0 [, (object)head=0 [, (str)file_path='' [, (int)source_audio_track=1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='Same As Sequence' [, (str)frame_rate='Same As Sequence' [, (object)timewarp_speed=None]]]]]]]]]]]]]]) -> None : Replace the gap with an unlinked source media segment. Keywords argument: source_name -- Name of the source. tape_name -- Tape name of the source. start_time -- Start time of the source. Must be a PyTime or a frame number. source_duration -- Length of the source. Must be a PyTime, a number of frames, or \"Infinite\". head -- Amount of head media to set on the segment. file_path -- File path to the media. source_audio_track -- Audio track from the source. width -- Width of the video media. (0 to use the sequence width) height -- Height of the video media. (0 to use the sequence height) ratio -- Frame ratio of the video media. (0.0 to use the sequence ratio) bit_depth -- Bit depth of the video media. (0 to use the sequence bit depth) scan_mode -- Scan mode of the video media. (P, F1, F2, or Same As Sequence) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps, Same As Sequence) timewarp_speed -- When defined, a timewarp is applied to the segment with the percentage of timewarp_speed. For audio segments, the speed must be greater than zero. change_start_frame(...) \u2014 change_start_frame( (PySegment)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : change_start_frame( (PySegment)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : Modify the start frame of the segment. Keywords argument: start_frame -- New start frame of the segment. use_segment_connections -- Sync the start frame of connected segments. get_metadata(...) \u2014 get_metadata( (PySegment)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : get_metadata( (PySegment)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : Return the metadata of the segment. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. time -- Must be a PyTime. If not specified, the segment start time is used.","title":"Class: PySegment"},{"location":"api/classes/PySegment/#class-pysegment","text":"Module : flame Object representing a Segment.","title":"Class: PySegment"},{"location":"api/classes/PySegment/#methods","text":"","title":"Methods"},{"location":"api/classes/PySegment/#properties","text":"source_name(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_in(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object source_out(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object source_duration(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object source_width(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_height(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_bit_depth(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_ratio(...) \u2014 None( (flame.PySegment)arg1) -> float None( (flame.PySegment)arg1) -> float source_scan_mode(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_frame_rate(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_cached(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_has_history(...) \u2014 None( (flame.PySegment)arg1) -> bool None( (flame.PySegment)arg1) -> bool source_unlinked(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_sample_rate(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_audio_track(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_essence_uid(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_uid(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str original_source_uid(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str source_colour_primaries(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_transfer_characteristics(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int source_matrix_coefficients(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int tape_name(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str record_in(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object record_out(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object record_duration(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object start_frame(...) \u2014 None( (flame.PySegment)arg1) -> int None( (flame.PySegment)arg1) -> int file_path(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str markers(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list effect_types(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list effects(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list groups(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list type(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str head(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object tail(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object rgb_channel(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str matte_channel(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str rgb_channels(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list matte_channels(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list version_uid(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str version_uids(...) \u2014 None( (flame.PySegment)arg1) -> list None( (flame.PySegment)arg1) -> list matte_mode(...) \u2014 None( (flame.PySegment)arg1) -> str None( (flame.PySegment)arg1) -> str container_clip(...) \u2014 None( (flame.PySegment)arg1) -> object None( (flame.PySegment)arg1) -> object","title":"Properties"},{"location":"api/classes/PySegment/#built-in-methods","text":"create_effect(...) \u2014 create_effect( (PySegment)arg1, (str)effect_type [, (str)after_effect_type='']) -> object : create_effect( (PySegment)arg1, (str)effect_type [, (str)after_effect_type='']) -> object : Add an effect of effect_type on the Segment. after_effect_type can be specified to insert the effect at a specific position. create_marker(...) \u2014 create_marker( (PySegment)arg1, (object)location) -> object : create_marker( (PySegment)arg1, (object)location) -> object : Create a Marker at the specified location on the Segment. create_connection(...) \u2014 create_connection( (PySegment)arg1) -> None : create_connection( (PySegment)arg1) -> None : Create a connected segment connection. remove_connection(...) \u2014 remove_connection( (PySegment)arg1) -> None : remove_connection( (PySegment)arg1) -> None : Remove the connected segment connection. sync_connected_segments(...) \u2014 sync_connected_segments( (PySegment)arg1) -> None : sync_connected_segments( (PySegment)arg1) -> None : Sync connected segments with the Timeline FXs of the current segment. connected_segments(...) \u2014 connected_segments( (PySegment)arg1 [, (str)scoping='all reels']) -> object : connected_segments( (PySegment)arg1 [, (str)scoping='all reels']) -> object : Return a list of the connected segments. Keywords argument: scoping -- Scopes of the sequences to query (all reels, sequences reels, current reel, current sequence). (Default:all reels) duplicate_source(...) \u2014 duplicate_source( (PySegment)arg1) -> None : duplicate_source( (PySegment)arg1) -> None : Insure that the segment's source is not shared anymore. shared_source_segments(...) \u2014 shared_source_segments( (PySegment)arg1) -> object : shared_source_segments( (PySegment)arg1) -> object : Return a list of the segments sharing this segment's source. copy_to_media_panel(...) \u2014 copy_to_media_panel( (PySegment)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : copy_to_media_panel( (PySegment)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject. trim_head(...) \u2014 trim_head( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : trim_head( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : Modify the amount of head of the PySegment. Keywords argument: offset -- Number of frames to add or remove from the head. ripple -- Enable to prevent gaps from appearing when performing a trim. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop) trim_tail(...) \u2014 trim_tail( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : trim_tail( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool : Modify the amount of tail of the PySegment. Keywords argument: offset -- Number of frames to add or remove from the tail. ripple -- Enable to prevent gaps from appearing when performing a trim. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop) slip(...) \u2014 slip( (PySegment)arg1, (int)offset [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]) -> bool : slip( (PySegment)arg1, (int)offset [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]) -> bool : Slip the media of the PySegment. Keywords argument: offset -- Relative offset to slip the media. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop) slide_keyframes(...) \u2014 slide_keyframes( (PySegment)arg1, (int)offset [, (bool)sync=False]) -> bool : slide_keyframes( (PySegment)arg1, (int)offset [, (bool)sync=False]) -> bool : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. set_gap_colour(...) \u2014 set_gap_colour( (PySegment)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : set_gap_colour( (PySegment)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : Create a colour source segment for the duration of the gap, or set the colour of an existing colour source. set_gap_bars(...) \u2014 set_gap_bars( (PySegment)arg1 [, (str)type='smpte' [, (bool)full_luminance=False [, (float)softness=0.0]]]) -> object : set_gap_bars( (PySegment)arg1 [, (str)type='smpte' [, (bool)full_luminance=False [, (float)softness=0.0]]]) -> object : Create colour bars segment for the duration of the gap. Returns a new PySegment on success. Keywords argument: type -- smpte or pal. full_luminance -- bars created at 100 or 75 percent luminance. softness -- softness to apply between the bars. smart_replace(...) \u2014 smart_replace( (PySegment)arg1, (PyClip)source_clip) -> None : smart_replace( (PySegment)arg1, (PyClip)source_clip) -> None : Replace the PySegment by the source_clip segment, including the Timeline FX. smart_replace_media(...) \u2014 smart_replace_media( (PySegment)arg1, (PyClip)source_clip) -> None : smart_replace_media( (PySegment)arg1, (PyClip)source_clip) -> None : Replace the media of PySegment by the source_clip segment, leaving the PySegment Timeline FX untouched match(...) \u2014 match( (PySegment)arg1, (PyArchiveEntry)destination [, (bool)preserve_handle=False [, (bool)use_sequence_info=True [, (bool)include_nested_content=False [, (bool)include_timeline_fx=False]]]]) -> object : match( (PySegment)arg1, (PyArchiveEntry)destination [, (bool)preserve_handle=False [, (bool)use_sequence_info=True [, (bool)include_nested_content=False [, (bool)include_timeline_fx=False]]]]) -> object : Match out the media of the PySegment to the destination. Returns a PyClip or a list of PyClip (with the included_nested_content option). Keywords argument: destination -- The PyObject that acts as the destination. preserve_handle -- Prevent the unrolling of the media handles. use_sequence_info -- Copy sequence segment information to the new matched clip. include_nested_content -- Include all sources found inside a BFX or Matte Container. include_timeline_fx -- Copy the Timeline FX present on the original clip to the new matched clip. clear_colour(...) \u2014 clear_colour( (PySegment)arg1) -> None : clear_colour( (PySegment)arg1) -> None : Clear the colour of the Segment. set_rgb_channel(...) \u2014 set_rgb_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences']]]) -> bool : set_rgb_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences']]]) -> bool : Set the RGB channel of the source specified by channel_index or by channel_name Keywords argument: channel_name -- Name of the channel found in rgb_channels. channel_index -- Index of the channel found in rgb_channels. scope -- Scope of the changes ( Follow Preferences, No Sharing, Follow Source Sharing, Follow Connected Segments). set_matte_channel(...) \u2014 set_matte_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences' [, (str)matte_mode='Custom Matte']]]]) -> bool : set_matte_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences' [, (str)matte_mode='Custom Matte']]]]) -> bool : Set the Matte channel of the source specified by channel_index or by channel_name if the matte_mode is set to Custom Matte. Keywords argument: channel_name -- Name of the channel found in matte_channels. channel_index -- Index of the channel found in matte_channels. scope -- Scope of the changes ( Follow Preferences, No Sharing, Follow Source Sharing, Follow Connected Segments). matte_mode -- Matte origin (Follow RGB, No Matte, Custom Matte). set_version_uid(...) \u2014 set_version_uid( (PySegment)arg1, (str)version_uid [, (str)scope='Follow Source Sharing']) -> bool : set_version_uid( (PySegment)arg1, (str)version_uid [, (str)scope='Follow Source Sharing']) -> bool : Set the current version unique ID of the source. Keywords argument: version_uid -- version unique ID. scope -- Scope of the changes ( No Sharing, Follow Source Sharing, Follow Connected Segments). get_colour_space(...) \u2014 get_colour_space( (PySegment)arg1 [, (PyTime)time=None]) -> str : get_colour_space( (PySegment)arg1 [, (PyTime)time=None]) -> str : Return the colour space at the requested time. Use record_in when no time is supplied. create_unlinked_segment(...) \u2014 create_unlinked_segment( (PySegment)arg1 [, (str)source_name='' [, (str)tape_name='' [, (object)start_time=0 [, (object)source_duration=0 [, (object)head=0 [, (str)file_path='' [, (int)source_audio_track=1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='Same As Sequence' [, (str)frame_rate='Same As Sequence' [, (object)timewarp_speed=None]]]]]]]]]]]]]]) -> None : create_unlinked_segment( (PySegment)arg1 [, (str)source_name='' [, (str)tape_name='' [, (object)start_time=0 [, (object)source_duration=0 [, (object)head=0 [, (str)file_path='' [, (int)source_audio_track=1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='Same As Sequence' [, (str)frame_rate='Same As Sequence' [, (object)timewarp_speed=None]]]]]]]]]]]]]]) -> None : Replace the gap with an unlinked source media segment. Keywords argument: source_name -- Name of the source. tape_name -- Tape name of the source. start_time -- Start time of the source. Must be a PyTime or a frame number. source_duration -- Length of the source. Must be a PyTime, a number of frames, or \"Infinite\". head -- Amount of head media to set on the segment. file_path -- File path to the media. source_audio_track -- Audio track from the source. width -- Width of the video media. (0 to use the sequence width) height -- Height of the video media. (0 to use the sequence height) ratio -- Frame ratio of the video media. (0.0 to use the sequence ratio) bit_depth -- Bit depth of the video media. (0 to use the sequence bit depth) scan_mode -- Scan mode of the video media. (P, F1, F2, or Same As Sequence) frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps, Same As Sequence) timewarp_speed -- When defined, a timewarp is applied to the segment with the percentage of timewarp_speed. For audio segments, the speed must be greater than zero. change_start_frame(...) \u2014 change_start_frame( (PySegment)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : change_start_frame( (PySegment)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None : Modify the start frame of the segment. Keywords argument: start_frame -- New start frame of the segment. use_segment_connections -- Sync the start frame of connected segments. get_metadata(...) \u2014 get_metadata( (PySegment)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : get_metadata( (PySegment)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object : Return the metadata of the segment. Keywords argument: key -- Key of the requested metadata. All metadata is returned when not specified. time -- Must be a PyTime. If not specified, the segment start time is used.","title":"Built-in methods"},{"location":"api/classes/PySequence/","text":"Class: PySequence Module : flame Object representing a Sequence. Methods Properties groups(...) \u2014 None( (flame.PySequence)arg1) -> list None( (flame.PySequence)arg1) -> list Built-in methods open(...) \u2014 open( (PySequence)arg1) -> bool : open( (PySequence)arg1) -> bool : Open the Sequence. create_container(...) \u2014 create_container( (PySequence)arg1) -> object : create_container( (PySequence)arg1) -> object : Create a container with the selected segments or between the in and out marks. create_version(...) \u2014 create_version( (PySequence)arg1 [, (bool)stereo=False]) -> object : create_version( (PySequence)arg1 [, (bool)stereo=False]) -> object : Add a Version to the Sequence. create_audio(...) \u2014 create_audio( (PySequence)arg1 [, (bool)stereo=False]) -> object : create_audio( (PySequence)arg1 [, (bool)stereo=False]) -> object : Add an Audio Track to the Sequence. create_subtitle(...) \u2014 create_subtitle( (PySequence)arg1) -> object : create_subtitle( (PySequence)arg1) -> object : Add a Subtitle Track to the Sequence. import_subtitles_file(...) \u2014 import_subtitles_file( (PySequence)arg1, (str)file_name [, (object)file_type=None [, (bool)align_first_event_to_clip_start=False [, (object)convert_from_frame_rate=None]]]) -> object : import_subtitles_file( (PySequence)arg1, (str)file_name [, (object)file_type=None [, (bool)align_first_event_to_clip_start=False [, (object)convert_from_frame_rate=None]]]) -> object : Import a subtitles file into a new Subtitles Track. Return the new PySubtitleTrack. Keyword arguments: file_name -- The path and name of the file to import. file_type -- The type of subtitle if it is not the file extension (srt or txt). align_first_event_to_clip_start -- Force the first event to be aligned with the clip start. convert_from_frame_rate -- frame rate of the imported file (for txt files only). create_group(...) \u2014 create_group( (PySequence)arg1, (str)name) -> object : create_group( (PySequence)arg1, (str)name) -> object : Creates a new PySequenceGroup. The group name must be supplied as argument. insert(...) \u2014 insert( (PySequence)arg1, (PyClip)source_clip [, (PyTime)insert_time=None [, (PyTrack)destination_track=None]]) -> bool : insert( (PySequence)arg1, (PyClip)source_clip [, (PyTime)insert_time=None [, (PyTrack)destination_track=None]]) -> bool : Creates a new PySequenceGroup. The group name must be supplied as argument. overwrite(...) \u2014 overwrite( (PySequence)arg1, (PyClip)source_clip [, (PyTime)overwrite_time=None [, (PyTrack)destination_track=None]]) -> bool : overwrite( (PySequence)arg1, (PyClip)source_clip [, (PyTime)overwrite_time=None [, (PyTrack)destination_track=None]]) -> bool : Creates a new PySequenceGroup. The group name must be supplied as argument. copy_selection_to_media_panel(...) \u2014 copy_selection_to_media_panel( (PySequence)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : copy_selection_to_media_panel( (PySequence)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip by copying the currently selected segments. Return the new PyClip. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace). extract_selection_to_media_panel(...) \u2014 extract_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : extract_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : Extract the selection from the sequence. Return the new PyClip created from the selection when a destination is supplied. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace). lift_selection_to_media_panel(...) \u2014 lift_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : lift_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : Lift the selection from the sequence. Return the new PyClip created from the selection when a destination is supplied. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace).","title":"Class: PySequence"},{"location":"api/classes/PySequence/#class-pysequence","text":"Module : flame Object representing a Sequence.","title":"Class: PySequence"},{"location":"api/classes/PySequence/#methods","text":"","title":"Methods"},{"location":"api/classes/PySequence/#properties","text":"groups(...) \u2014 None( (flame.PySequence)arg1) -> list None( (flame.PySequence)arg1) -> list","title":"Properties"},{"location":"api/classes/PySequence/#built-in-methods","text":"open(...) \u2014 open( (PySequence)arg1) -> bool : open( (PySequence)arg1) -> bool : Open the Sequence. create_container(...) \u2014 create_container( (PySequence)arg1) -> object : create_container( (PySequence)arg1) -> object : Create a container with the selected segments or between the in and out marks. create_version(...) \u2014 create_version( (PySequence)arg1 [, (bool)stereo=False]) -> object : create_version( (PySequence)arg1 [, (bool)stereo=False]) -> object : Add a Version to the Sequence. create_audio(...) \u2014 create_audio( (PySequence)arg1 [, (bool)stereo=False]) -> object : create_audio( (PySequence)arg1 [, (bool)stereo=False]) -> object : Add an Audio Track to the Sequence. create_subtitle(...) \u2014 create_subtitle( (PySequence)arg1) -> object : create_subtitle( (PySequence)arg1) -> object : Add a Subtitle Track to the Sequence. import_subtitles_file(...) \u2014 import_subtitles_file( (PySequence)arg1, (str)file_name [, (object)file_type=None [, (bool)align_first_event_to_clip_start=False [, (object)convert_from_frame_rate=None]]]) -> object : import_subtitles_file( (PySequence)arg1, (str)file_name [, (object)file_type=None [, (bool)align_first_event_to_clip_start=False [, (object)convert_from_frame_rate=None]]]) -> object : Import a subtitles file into a new Subtitles Track. Return the new PySubtitleTrack. Keyword arguments: file_name -- The path and name of the file to import. file_type -- The type of subtitle if it is not the file extension (srt or txt). align_first_event_to_clip_start -- Force the first event to be aligned with the clip start. convert_from_frame_rate -- frame rate of the imported file (for txt files only). create_group(...) \u2014 create_group( (PySequence)arg1, (str)name) -> object : create_group( (PySequence)arg1, (str)name) -> object : Creates a new PySequenceGroup. The group name must be supplied as argument. insert(...) \u2014 insert( (PySequence)arg1, (PyClip)source_clip [, (PyTime)insert_time=None [, (PyTrack)destination_track=None]]) -> bool : insert( (PySequence)arg1, (PyClip)source_clip [, (PyTime)insert_time=None [, (PyTrack)destination_track=None]]) -> bool : Creates a new PySequenceGroup. The group name must be supplied as argument. overwrite(...) \u2014 overwrite( (PySequence)arg1, (PyClip)source_clip [, (PyTime)overwrite_time=None [, (PyTrack)destination_track=None]]) -> bool : overwrite( (PySequence)arg1, (PyClip)source_clip [, (PyTime)overwrite_time=None [, (PyTrack)destination_track=None]]) -> bool : Creates a new PySequenceGroup. The group name must be supplied as argument. copy_selection_to_media_panel(...) \u2014 copy_selection_to_media_panel( (PySequence)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : copy_selection_to_media_panel( (PySequence)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip by copying the currently selected segments. Return the new PyClip. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace). extract_selection_to_media_panel(...) \u2014 extract_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : extract_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : Extract the selection from the sequence. Return the new PyClip created from the selection when a destination is supplied. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace). lift_selection_to_media_panel(...) \u2014 lift_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : lift_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object : Lift the selection from the sequence. Return the new PyClip created from the selection when a destination is supplied. Keyword arguments: destination -- The PyObject that acts as the destination. duplicate_action -- Action to take when an object with the same name already exists (add or replace).","title":"Built-in methods"},{"location":"api/classes/PySequenceGroup/","text":"Class: PySequenceGroup Module : flame Object representing a Group in a Sequence. Methods Properties segments(...) \u2014 None( (flame.PySequenceGroup)arg1) -> list None( (flame.PySequenceGroup)arg1) -> list Built-in methods add(...) \u2014 add( (PySequenceGroup)arg1, (object)segments) -> None : add( (PySequenceGroup)arg1, (object)segments) -> None : Adds a PySegment or list of PySegments to the Group. remove(...) \u2014 remove( (PySequenceGroup)arg1, (object)segments) -> None : remove( (PySequenceGroup)arg1, (object)segments) -> None : Remove a PySegment or list of PySegments from the Group.","title":"Class: PySequenceGroup"},{"location":"api/classes/PySequenceGroup/#class-pysequencegroup","text":"Module : flame Object representing a Group in a Sequence.","title":"Class: PySequenceGroup"},{"location":"api/classes/PySequenceGroup/#methods","text":"","title":"Methods"},{"location":"api/classes/PySequenceGroup/#properties","text":"segments(...) \u2014 None( (flame.PySequenceGroup)arg1) -> list None( (flame.PySequenceGroup)arg1) -> list","title":"Properties"},{"location":"api/classes/PySequenceGroup/#built-in-methods","text":"add(...) \u2014 add( (PySequenceGroup)arg1, (object)segments) -> None : add( (PySequenceGroup)arg1, (object)segments) -> None : Adds a PySegment or list of PySegments to the Group. remove(...) \u2014 remove( (PySequenceGroup)arg1, (object)segments) -> None : remove( (PySequenceGroup)arg1, (object)segments) -> None : Remove a PySegment or list of PySegments from the Group.","title":"Built-in methods"},{"location":"api/classes/PySubtitleTrack/","text":"Class: PySubtitleTrack Module : flame Object representing a Subtitle Track. Methods Built-in methods export_as_srt_file(...) \u2014 export_as_srt_file( (PySubtitleTrack)arg1, (str)file_name [, (bool)character_based_attributes=True [, (bool)export_colours=False [, (str)exclude_colour='' [, (bool)use_original_colours=False [, (bool)use_original_alignment=False [, (bool)export_alignments=False [, (str)alignment_type='an' [, (str)exclude_alignment='' [, (str)start_timecode='Same as Clip']]]]]]]]]) -> None : export_as_srt_file( (PySubtitleTrack)arg1, (str)file_name [, (bool)character_based_attributes=True [, (bool)export_colours=False [, (str)exclude_colour='' [, (bool)use_original_colours=False [, (bool)use_original_alignment=False [, (bool)export_alignments=False [, (str)alignment_type='an' [, (str)exclude_alignment='' [, (str)start_timecode='Same as Clip']]]]]]]]]) -> None : Export the Subtitles Track as a SubRip (srt) file.Keyword arguments: file_name -- The path and name of the file to write. character_based_attributes -- Export the bold, italic, and underline attributes. export_colours -- Export colours. exclude_colour -- Specify a colour, in hexadecimal or CSS colour name, to ignore. use_original_colours -- Reuse hexadecimal or CSS colour names from the imported file. use_original_alignment -- Reuse alignment tokens from the imported file . export_alignments -- Export alignments. alignment_type -- Set to a or an alignment style tokens. exclude_alignment -- Specify an alignment to ignore. start_timecode -- Specify the timecode mode, Same as Clip or, Relative to Clip Start.","title":"Class: PySubtitleTrack"},{"location":"api/classes/PySubtitleTrack/#class-pysubtitletrack","text":"Module : flame Object representing a Subtitle Track.","title":"Class: PySubtitleTrack"},{"location":"api/classes/PySubtitleTrack/#methods","text":"","title":"Methods"},{"location":"api/classes/PySubtitleTrack/#built-in-methods","text":"export_as_srt_file(...) \u2014 export_as_srt_file( (PySubtitleTrack)arg1, (str)file_name [, (bool)character_based_attributes=True [, (bool)export_colours=False [, (str)exclude_colour='' [, (bool)use_original_colours=False [, (bool)use_original_alignment=False [, (bool)export_alignments=False [, (str)alignment_type='an' [, (str)exclude_alignment='' [, (str)start_timecode='Same as Clip']]]]]]]]]) -> None : export_as_srt_file( (PySubtitleTrack)arg1, (str)file_name [, (bool)character_based_attributes=True [, (bool)export_colours=False [, (str)exclude_colour='' [, (bool)use_original_colours=False [, (bool)use_original_alignment=False [, (bool)export_alignments=False [, (str)alignment_type='an' [, (str)exclude_alignment='' [, (str)start_timecode='Same as Clip']]]]]]]]]) -> None : Export the Subtitles Track as a SubRip (srt) file.Keyword arguments: file_name -- The path and name of the file to write. character_based_attributes -- Export the bold, italic, and underline attributes. export_colours -- Export colours. exclude_colour -- Specify a colour, in hexadecimal or CSS colour name, to ignore. use_original_colours -- Reuse hexadecimal or CSS colour names from the imported file. use_original_alignment -- Reuse alignment tokens from the imported file . export_alignments -- Export alignments. alignment_type -- Set to a or an alignment style tokens. exclude_alignment -- Specify an alignment to ignore. start_timecode -- Specify the timecode mode, Same as Clip or, Relative to Clip Start.","title":"Built-in methods"},{"location":"api/classes/PyTime/","text":"Class: PyTime Module : flame Object representing a time unit PyTime(timecode, frame_rate) PyTime(relative_frame) PyTime(absolute_frame, frame_rate) Methods Properties frame(...) \u2014 None( (flame.PyTime)arg1) -> int None( (flame.PyTime)arg1) -> int relative_frame(...) \u2014 None( (flame.PyTime)arg1) -> int None( (flame.PyTime)arg1) -> int timecode(...) \u2014 None( (flame.PyTime)arg1) -> str None( (flame.PyTime)arg1) -> str frame_rate(...) \u2014 None( (flame.PyTime)arg1) -> object None( (flame.PyTime)arg1) -> object","title":"Class: PyTime"},{"location":"api/classes/PyTime/#class-pytime","text":"Module : flame Object representing a time unit PyTime(timecode, frame_rate) PyTime(relative_frame) PyTime(absolute_frame, frame_rate)","title":"Class: PyTime"},{"location":"api/classes/PyTime/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTime/#properties","text":"frame(...) \u2014 None( (flame.PyTime)arg1) -> int None( (flame.PyTime)arg1) -> int relative_frame(...) \u2014 None( (flame.PyTime)arg1) -> int None( (flame.PyTime)arg1) -> int timecode(...) \u2014 None( (flame.PyTime)arg1) -> str None( (flame.PyTime)arg1) -> str frame_rate(...) \u2014 None( (flame.PyTime)arg1) -> object None( (flame.PyTime)arg1) -> object","title":"Properties"},{"location":"api/classes/PyTimeline/","text":"Class: PyTimeline Module : flame This class represents the Timeline. Methods Properties clip(...) \u2014 None( (flame.PyTimeline)arg1) -> object None( (flame.PyTimeline)arg1) -> object current_segment(...) \u2014 None( (flame.PyTimeline)arg1) -> object None( (flame.PyTimeline)arg1) -> object current_marker(...) \u2014 None( (flame.PyTimeline)arg1) -> object None( (flame.PyTimeline)arg1) -> object current_effect(...) \u2014 None( (flame.PyTimeline)arg1) -> object None( (flame.PyTimeline)arg1) -> object current_transition(...) \u2014 None( (flame.PyTimeline)arg1) -> object None( (flame.PyTimeline)arg1) -> object type(...) \u2014 None( (flame.PyTimeline)arg1) -> str None( (flame.PyTimeline)arg1) -> str","title":"Class: PyTimeline"},{"location":"api/classes/PyTimeline/#class-pytimeline","text":"Module : flame This class represents the Timeline.","title":"Class: PyTimeline"},{"location":"api/classes/PyTimeline/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTimeline/#properties","text":"clip(...) \u2014 None( (flame.PyTimeline)arg1) -> object None( (flame.PyTimeline)arg1) -> object current_segment(...) \u2014 None( (flame.PyTimeline)arg1) -> object None( (flame.PyTimeline)arg1) -> object current_marker(...) \u2014 None( (flame.PyTimeline)arg1) -> object None( (flame.PyTimeline)arg1) -> object current_effect(...) \u2014 None( (flame.PyTimeline)arg1) -> object None( (flame.PyTimeline)arg1) -> object current_transition(...) \u2014 None( (flame.PyTimeline)arg1) -> object None( (flame.PyTimeline)arg1) -> object type(...) \u2014 None( (flame.PyTimeline)arg1) -> str None( (flame.PyTimeline)arg1) -> str","title":"Properties"},{"location":"api/classes/PyTimelineFX/","text":"Class: PyTimelineFX Module : flame Object representing a Timeline FX. Methods Properties type(...) \u2014 None( (flame.PyTimelineFX)arg1) -> object None( (flame.PyTimelineFX)arg1) -> object has_maps_cache_media(...) \u2014 None( (flame.PyTimelineFX)arg1) -> bool None( (flame.PyTimelineFX)arg1) -> bool Built-in methods load_setup(...) \u2014 load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. save_setup(...) \u2014 save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. flush_maps_cache_media(...) \u2014 flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.) clear_maps_cache_media(...) \u2014 clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media. sync_connected_segments(...) \u2014 sync_connected_segments( (PyTimelineFX)arg1) -> None : sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments. slide_keyframes(...) \u2014 slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. output_channel_as_metadata_key(...) \u2014 output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"Class: PyTimelineFX"},{"location":"api/classes/PyTimelineFX/#class-pytimelinefx","text":"Module : flame Object representing a Timeline FX.","title":"Class: PyTimelineFX"},{"location":"api/classes/PyTimelineFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTimelineFX/#properties","text":"type(...) \u2014 None( (flame.PyTimelineFX)arg1) -> object None( (flame.PyTimelineFX)arg1) -> object has_maps_cache_media(...) \u2014 None( (flame.PyTimelineFX)arg1) -> bool None( (flame.PyTimelineFX)arg1) -> bool","title":"Properties"},{"location":"api/classes/PyTimelineFX/#built-in-methods","text":"load_setup(...) \u2014 load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Load a Node setup. A path and a file name must be defined as arguments. save_setup(...) \u2014 save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool : Save a Node setup. A path and a file name must be defined as arguments. flush_maps_cache_media(...) \u2014 flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : flush_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.) clear_maps_cache_media(...) \u2014 clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : clear_maps_cache_media( (PyTimelineFX)arg1) -> bool : Clear the Timeline FX Maps and ML cached media. sync_connected_segments(...) \u2014 sync_connected_segments( (PyTimelineFX)arg1) -> None : sync_connected_segments( (PyTimelineFX)arg1) -> None : Push the Timeline FX to connected segments. slide_keyframes(...) \u2014 slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None : Slide the keyframes the PySegment. Keywords argument: offset -- Relative offset to slide the keyframes. sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment. output_channel_as_metadata_key(...) \u2014 output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None : Enable/Disable the output as metadata of a channel. Keyword arguments: channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted. enable -- True to output metadata, False to stop outputting.","title":"Built-in methods"},{"location":"api/classes/PyTimewarpNode/","text":"Class: PyTimewarpNode Module : flame Object representing a Timewarp node. Methods Built-in methods get_speed(...) \u2014 get_speed( (PyTimewarpNode)arg1, (float)frame) -> float : get_speed( (PyTimewarpNode)arg1, (float)frame) -> float : Return the speed attribute at the requested frame. set_speed(...) \u2014 set_speed( (PyTimewarpNode)arg1, (float)frame, (float)new_speed) -> None : set_speed( (PyTimewarpNode)arg1, (float)frame, (float)new_speed) -> None : Set the speed at the requested frame. set_timing(...) \u2014 set_timing( (PyTimewarpNode)arg1, (float)frame, (float)new_timing) -> None : set_timing( (PyTimewarpNode)arg1, (float)frame, (float)new_timing) -> None : Set the timing at the requested frame. get_timing(...) \u2014 get_timing( (PyTimewarpNode)arg1, (float)frame) -> float : get_timing( (PyTimewarpNode)arg1, (float)frame) -> float : Return the timing value at the requested frame. get_duration_timing(...) \u2014 get_duration_timing( (PyTimewarpNode)arg1, (float)frame) -> float : get_duration_timing( (PyTimewarpNode)arg1, (float)frame) -> float : Return the timing value for the current frame while in the duration mode. get_speed_timing(...) \u2014 get_speed_timing( (PyTimewarpNode)arg1, (float)frame) -> float : get_speed_timing( (PyTimewarpNode)arg1, (float)frame) -> float : The timing value for the current frame while in the speed mode.","title":"Class: PyTimewarpNode"},{"location":"api/classes/PyTimewarpNode/#class-pytimewarpnode","text":"Module : flame Object representing a Timewarp node.","title":"Class: PyTimewarpNode"},{"location":"api/classes/PyTimewarpNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTimewarpNode/#built-in-methods","text":"get_speed(...) \u2014 get_speed( (PyTimewarpNode)arg1, (float)frame) -> float : get_speed( (PyTimewarpNode)arg1, (float)frame) -> float : Return the speed attribute at the requested frame. set_speed(...) \u2014 set_speed( (PyTimewarpNode)arg1, (float)frame, (float)new_speed) -> None : set_speed( (PyTimewarpNode)arg1, (float)frame, (float)new_speed) -> None : Set the speed at the requested frame. set_timing(...) \u2014 set_timing( (PyTimewarpNode)arg1, (float)frame, (float)new_timing) -> None : set_timing( (PyTimewarpNode)arg1, (float)frame, (float)new_timing) -> None : Set the timing at the requested frame. get_timing(...) \u2014 get_timing( (PyTimewarpNode)arg1, (float)frame) -> float : get_timing( (PyTimewarpNode)arg1, (float)frame) -> float : Return the timing value at the requested frame. get_duration_timing(...) \u2014 get_duration_timing( (PyTimewarpNode)arg1, (float)frame) -> float : get_duration_timing( (PyTimewarpNode)arg1, (float)frame) -> float : Return the timing value for the current frame while in the duration mode. get_speed_timing(...) \u2014 get_speed_timing( (PyTimewarpNode)arg1, (float)frame) -> float : get_speed_timing( (PyTimewarpNode)arg1, (float)frame) -> float : The timing value for the current frame while in the speed mode.","title":"Built-in methods"},{"location":"api/classes/PyTimewarpTimelineFX/","text":"Class: PyTimewarpTimelineFX Module : flame Object representing a Timewarp node. Methods Built-in methods get_speed(...) \u2014 get_speed( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_speed( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the speed attribute at the requested frame. set_speed(...) \u2014 set_speed( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_speed) -> None : set_speed( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_speed) -> None : Set the speed at the requested frame. set_timing(...) \u2014 set_timing( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_timing) -> None : set_timing( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_timing) -> None : Set the timing at the requested frame. get_timing(...) \u2014 get_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the timing value at the requested frame. get_duration_timing(...) \u2014 get_duration_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_duration_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the timing value for the current frame while in the duration mode. get_speed_timing(...) \u2014 get_speed_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_speed_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : The timing value for the current frame while in the speed mode.","title":"Class: PyTimewarpTimelineFX"},{"location":"api/classes/PyTimewarpTimelineFX/#class-pytimewarptimelinefx","text":"Module : flame Object representing a Timewarp node.","title":"Class: PyTimewarpTimelineFX"},{"location":"api/classes/PyTimewarpTimelineFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTimewarpTimelineFX/#built-in-methods","text":"get_speed(...) \u2014 get_speed( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_speed( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the speed attribute at the requested frame. set_speed(...) \u2014 set_speed( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_speed) -> None : set_speed( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_speed) -> None : Set the speed at the requested frame. set_timing(...) \u2014 set_timing( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_timing) -> None : set_timing( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_timing) -> None : Set the timing at the requested frame. get_timing(...) \u2014 get_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the timing value at the requested frame. get_duration_timing(...) \u2014 get_duration_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_duration_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : Return the timing value for the current frame while in the duration mode. get_speed_timing(...) \u2014 get_speed_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : get_speed_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float : The timing value for the current frame while in the speed mode.","title":"Built-in methods"},{"location":"api/classes/PyTrack/","text":"Class: PyTrack Module : flame Object representing a Track. Methods Properties segments(...) \u2014 None( (flame.PyTrack)arg1) -> list None( (flame.PyTrack)arg1) -> list transitions(...) \u2014 None( (flame.PyTrack)arg1) -> list None( (flame.PyTrack)arg1) -> list Built-in methods copy_to_media_panel(...) \u2014 copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject. cut(...) \u2014 cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None : cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None : Cut the Track. insert_transition(...) \u2014 insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object : insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object : Insert a Transition on the Track. Returns the new PyTransition if successful. Keywords argument: record_time -- Time at which the Transition is inserted. type -- Type of the new Transition. duration -- Duration of the new Transition in frames. alignment -- Alignment of the new Transition. in_offset -- Number of frames on left side of the cut in custom alignment. sync -- Perform the operation on all Tracks part of the sync group.","title":"Class: PyTrack"},{"location":"api/classes/PyTrack/#class-pytrack","text":"Module : flame Object representing a Track.","title":"Class: PyTrack"},{"location":"api/classes/PyTrack/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTrack/#properties","text":"segments(...) \u2014 None( (flame.PyTrack)arg1) -> list None( (flame.PyTrack)arg1) -> list transitions(...) \u2014 None( (flame.PyTrack)arg1) -> list None( (flame.PyTrack)arg1) -> list","title":"Properties"},{"location":"api/classes/PyTrack/#built-in-methods","text":"copy_to_media_panel(...) \u2014 copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject. cut(...) \u2014 cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None : cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None : Cut the Track. insert_transition(...) \u2014 insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object : insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object : Insert a Transition on the Track. Returns the new PyTransition if successful. Keywords argument: record_time -- Time at which the Transition is inserted. type -- Type of the new Transition. duration -- Duration of the new Transition in frames. alignment -- Alignment of the new Transition. in_offset -- Number of frames on left side of the cut in custom alignment. sync -- Perform the operation on all Tracks part of the sync group.","title":"Built-in methods"},{"location":"api/classes/PyTransition/","text":"Class: PyTransition Module : flame Object representing a Transition. Methods Properties type(...) \u2014 None( (flame.PyTransition)arg1) -> str None( (flame.PyTransition)arg1) -> str record_time(...) \u2014 None( (flame.PyTransition)arg1) -> object None( (flame.PyTransition)arg1) -> object in_offset(...) \u2014 None( (flame.PyTransition)arg1) -> int None( (flame.PyTransition)arg1) -> int Built-in methods set_transition(...) \u2014 set_transition( (PyTransition)arg1, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0]]]) -> object : set_transition( (PyTransition)arg1, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0]]]) -> object : Replace the Transition with another type of Transition. Returns the new PyTransition if successful. Keywords argument: type -- Type of the new Transition. duration -- Duration of the new Transition in frames. alignment -- Alignment of the new Transition. in_offset -- Number of frames on left side of the cut in custom alignment. slide(...) \u2014 slide( (PyTransition)arg1, (int)offset [, (bool)sync=False]) -> bool : slide( (PyTransition)arg1, (int)offset [, (bool)sync=False]) -> bool : Slide the Transition. Keywords argument: offset -- Amount of frames to slide the Transition with. sync -- Enable to perform the same operation on transitions that belong to the same sync group as the current PyTransition. set_dissolve_to_from_colour(...) \u2014 set_dissolve_to_from_colour( (PyTransition)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : set_dissolve_to_from_colour( (PyTransition)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : Make a dissolve transition dissolve to/from a colour. set_fade_to_from_silence(...) \u2014 set_fade_to_from_silence( (PyTransition)arg1) -> None : set_fade_to_from_silence( (PyTransition)arg1) -> None : Make a fade dip to/from silence.","title":"Class: PyTransition"},{"location":"api/classes/PyTransition/#class-pytransition","text":"Module : flame Object representing a Transition.","title":"Class: PyTransition"},{"location":"api/classes/PyTransition/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTransition/#properties","text":"type(...) \u2014 None( (flame.PyTransition)arg1) -> str None( (flame.PyTransition)arg1) -> str record_time(...) \u2014 None( (flame.PyTransition)arg1) -> object None( (flame.PyTransition)arg1) -> object in_offset(...) \u2014 None( (flame.PyTransition)arg1) -> int None( (flame.PyTransition)arg1) -> int","title":"Properties"},{"location":"api/classes/PyTransition/#built-in-methods","text":"set_transition(...) \u2014 set_transition( (PyTransition)arg1, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0]]]) -> object : set_transition( (PyTransition)arg1, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0]]]) -> object : Replace the Transition with another type of Transition. Returns the new PyTransition if successful. Keywords argument: type -- Type of the new Transition. duration -- Duration of the new Transition in frames. alignment -- Alignment of the new Transition. in_offset -- Number of frames on left side of the cut in custom alignment. slide(...) \u2014 slide( (PyTransition)arg1, (int)offset [, (bool)sync=False]) -> bool : slide( (PyTransition)arg1, (int)offset [, (bool)sync=False]) -> bool : Slide the Transition. Keywords argument: offset -- Amount of frames to slide the Transition with. sync -- Enable to perform the same operation on transitions that belong to the same sync group as the current PyTransition. set_dissolve_to_from_colour(...) \u2014 set_dissolve_to_from_colour( (PyTransition)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : set_dissolve_to_from_colour( (PyTransition)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None : Make a dissolve transition dissolve to/from a colour. set_fade_to_from_silence(...) \u2014 set_fade_to_from_silence( (PyTransition)arg1) -> None : set_fade_to_from_silence( (PyTransition)arg1) -> None : Make a fade dip to/from silence.","title":"Built-in methods"},{"location":"api/classes/PyTypeFX/","text":"Class: PyTypeFX Module : flame Object representing a Type Timeline FX. Methods Properties layers(...) \u2014 None( (flame.PyTypeFX)arg1) -> list None( (flame.PyTypeFX)arg1) -> list Built-in methods add_layer(...) \u2014 add_layer( (PyTypeFX)arg1 [, (str)layer_type='Centre']) -> object : add_layer( (PyTypeFX)arg1 [, (str)layer_type='Centre']) -> object : Create a new layer. Keyword argument: layer_type -- Must be one of Left, Centre(default), Right, Roll, or Crawl. append_type_setup(...) \u2014 append_type_setup( (PyTypeFX)arg1, (str)file_name) -> bool : append_type_setup( (PyTypeFX)arg1, (str)file_name) -> bool : Append a setup to the current Type setup.","title":"Class: PyTypeFX"},{"location":"api/classes/PyTypeFX/#class-pytypefx","text":"Module : flame Object representing a Type Timeline FX.","title":"Class: PyTypeFX"},{"location":"api/classes/PyTypeFX/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTypeFX/#properties","text":"layers(...) \u2014 None( (flame.PyTypeFX)arg1) -> list None( (flame.PyTypeFX)arg1) -> list","title":"Properties"},{"location":"api/classes/PyTypeFX/#built-in-methods","text":"add_layer(...) \u2014 add_layer( (PyTypeFX)arg1 [, (str)layer_type='Centre']) -> object : add_layer( (PyTypeFX)arg1 [, (str)layer_type='Centre']) -> object : Create a new layer. Keyword argument: layer_type -- Must be one of Left, Centre(default), Right, Roll, or Crawl. append_type_setup(...) \u2014 append_type_setup( (PyTypeFX)arg1, (str)file_name) -> bool : append_type_setup( (PyTypeFX)arg1, (str)file_name) -> bool : Append a setup to the current Type setup.","title":"Built-in methods"},{"location":"api/classes/PyTypeLayer/","text":"Class: PyTypeLayer Module : flame Object representing a Type Layer. Methods Properties type(...) \u2014 None( (flame.PyTypeLayer)arg1) -> object None( (flame.PyTypeLayer)arg1) -> object","title":"Class: PyTypeLayer"},{"location":"api/classes/PyTypeLayer/#class-pytypelayer","text":"Module : flame Object representing a Type Layer.","title":"Class: PyTypeLayer"},{"location":"api/classes/PyTypeLayer/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTypeLayer/#properties","text":"type(...) \u2014 None( (flame.PyTypeLayer)arg1) -> object None( (flame.PyTypeLayer)arg1) -> object","title":"Properties"},{"location":"api/classes/PyTypeNode/","text":"Class: PyTypeNode Module : flame Object representing a Type node. Methods Properties layers(...) \u2014 None( (flame.PyTypeNode)arg1) -> list None( (flame.PyTypeNode)arg1) -> list Built-in methods add_layer(...) \u2014 add_layer( (PyTypeNode)arg1 [, (str)layer_type='Centre']) -> object : add_layer( (PyTypeNode)arg1 [, (str)layer_type='Centre']) -> object : Create a new layer. Keyword argument: layer_type -- Must be one of Left, Centre(default), Right, Roll, or Crawl. append_type_setup(...) \u2014 append_type_setup( (PyTypeNode)arg1, (str)file_name) -> bool : append_type_setup( (PyTypeNode)arg1, (str)file_name) -> bool : Append a setup to the current Type setup.","title":"Class: PyTypeNode"},{"location":"api/classes/PyTypeNode/#class-pytypenode","text":"Module : flame Object representing a Type node.","title":"Class: PyTypeNode"},{"location":"api/classes/PyTypeNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyTypeNode/#properties","text":"layers(...) \u2014 None( (flame.PyTypeNode)arg1) -> list None( (flame.PyTypeNode)arg1) -> list","title":"Properties"},{"location":"api/classes/PyTypeNode/#built-in-methods","text":"add_layer(...) \u2014 add_layer( (PyTypeNode)arg1 [, (str)layer_type='Centre']) -> object : add_layer( (PyTypeNode)arg1 [, (str)layer_type='Centre']) -> object : Create a new layer. Keyword argument: layer_type -- Must be one of Left, Centre(default), Right, Roll, or Crawl. append_type_setup(...) \u2014 append_type_setup( (PyTypeNode)arg1, (str)file_name) -> bool : append_type_setup( (PyTypeNode)arg1, (str)file_name) -> bool : Append a setup to the current Type setup.","title":"Built-in methods"},{"location":"api/classes/PyUser/","text":"Class: PyUser Module : flame Object representing a User. Methods Properties name(...) \u2014 None( (flame.PyUser)arg1) -> str None( (flame.PyUser)arg1) -> str nickname(...) \u2014 None( (flame.PyUser)arg1) -> str None( (flame.PyUser)arg1) -> str shortcuts_profile(...) \u2014 None( (flame.PyUser)arg1) -> str None( (flame.PyUser)arg1) -> str","title":"Class: PyUser"},{"location":"api/classes/PyUser/#class-pyuser","text":"Module : flame Object representing a User.","title":"Class: PyUser"},{"location":"api/classes/PyUser/#methods","text":"","title":"Methods"},{"location":"api/classes/PyUser/#properties","text":"name(...) \u2014 None( (flame.PyUser)arg1) -> str None( (flame.PyUser)arg1) -> str nickname(...) \u2014 None( (flame.PyUser)arg1) -> str None( (flame.PyUser)arg1) -> str shortcuts_profile(...) \u2014 None( (flame.PyUser)arg1) -> str None( (flame.PyUser)arg1) -> str","title":"Properties"},{"location":"api/classes/PyUsers/","text":"Class: PyUsers Module : flame Object representing the User manager. Methods Properties current_user(...) \u2014 None( (flame.PyUsers)arg1) -> object None( (flame.PyUsers)arg1) -> object","title":"Class: PyUsers"},{"location":"api/classes/PyUsers/#class-pyusers","text":"Module : flame Object representing the User manager.","title":"Class: PyUsers"},{"location":"api/classes/PyUsers/#methods","text":"","title":"Methods"},{"location":"api/classes/PyUsers/#properties","text":"current_user(...) \u2014 None( (flame.PyUsers)arg1) -> object None( (flame.PyUsers)arg1) -> object","title":"Properties"},{"location":"api/classes/PyVersion/","text":"Class: PyVersion Module : flame Object representing a Version. Methods Properties tracks(...) \u2014 None( (flame.PyVersion)arg1) -> list None( (flame.PyVersion)arg1) -> list stereo(...) \u2014 None( (flame.PyVersion)arg1) -> bool None( (flame.PyVersion)arg1) -> bool Built-in methods copy_to_media_panel(...) \u2014 copy_to_media_panel( (PyVersion)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : copy_to_media_panel( (PyVersion)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject. create_track(...) \u2014 create_track( (PyVersion)arg1 [, (int)track_index=-1 [, (bool)hdr=False]]) -> object : create_track( (PyVersion)arg1 [, (int)track_index=-1 [, (bool)hdr=False]]) -> object : Add a track to the Version.Keywords arguments: track_index -- Index to insert the new track at, -1 to append at the top. hdr -- Set to True to create an HDR track. import_DolbyVision_xml(...) \u2014 import_DolbyVision_xml( (PyVersion)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)track_index=-1]]) -> object : import_DolbyVision_xml( (PyVersion)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)track_index=-1]]) -> object : Add a track to the Version.Keywords arguments: track_index -- Index to insert the new track at, -1 to append at the top. hdr -- Set to True to create an HDR track.","title":"Class: PyVersion"},{"location":"api/classes/PyVersion/#class-pyversion","text":"Module : flame Object representing a Version.","title":"Class: PyVersion"},{"location":"api/classes/PyVersion/#methods","text":"","title":"Methods"},{"location":"api/classes/PyVersion/#properties","text":"tracks(...) \u2014 None( (flame.PyVersion)arg1) -> list None( (flame.PyVersion)arg1) -> list stereo(...) \u2014 None( (flame.PyVersion)arg1) -> bool None( (flame.PyVersion)arg1) -> bool","title":"Properties"},{"location":"api/classes/PyVersion/#built-in-methods","text":"copy_to_media_panel(...) \u2014 copy_to_media_panel( (PyVersion)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : copy_to_media_panel( (PyVersion)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object : Create a new clip with a copy of the PyObject. create_track(...) \u2014 create_track( (PyVersion)arg1 [, (int)track_index=-1 [, (bool)hdr=False]]) -> object : create_track( (PyVersion)arg1 [, (int)track_index=-1 [, (bool)hdr=False]]) -> object : Add a track to the Version.Keywords arguments: track_index -- Index to insert the new track at, -1 to append at the top. hdr -- Set to True to create an HDR track. import_DolbyVision_xml(...) \u2014 import_DolbyVision_xml( (PyVersion)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)track_index=-1]]) -> object : import_DolbyVision_xml( (PyVersion)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)track_index=-1]]) -> object : Add a track to the Version.Keywords arguments: track_index -- Index to insert the new track at, -1 to append at the top. hdr -- Set to True to create an HDR track.","title":"Built-in methods"},{"location":"api/classes/PyWorkspace/","text":"Class: PyWorkspace Module : flame Object representing a Workspace. Methods Properties desktop(...) \u2014 None( (flame.PyWorkspace)arg1) -> object None( (flame.PyWorkspace)arg1) -> object libraries(...) \u2014 None( (flame.PyWorkspace)arg1) -> list None( (flame.PyWorkspace)arg1) -> list Built-in methods create_library(...) \u2014 create_library( (PyWorkspace)arg1, (str)name) -> object : create_library( (PyWorkspace)arg1, (str)name) -> object : Create a new Library in a Workspace. replace_desktop(...) \u2014 replace_desktop( (PyWorkspace)arg1, (PyDesktop)desktop) -> bool : replace_desktop( (PyWorkspace)arg1, (PyDesktop)desktop) -> bool : Replace the Workspace active Desktop with another one. set_desktop_reels(...) \u2014 set_desktop_reels( (PyWorkspace)arg1 [, (object)group=None]) -> bool : set_desktop_reels( (PyWorkspace)arg1 [, (object)group=None]) -> bool : Set the Desktop Reels view mode. set_freeform(...) \u2014 set_freeform( (PyWorkspace)arg1 [, (object)reel=None]) -> bool : set_freeform( (PyWorkspace)arg1 [, (object)reel=None]) -> bool : Set the Freeform view mode.","title":"Class: PyWorkspace"},{"location":"api/classes/PyWorkspace/#class-pyworkspace","text":"Module : flame Object representing a Workspace.","title":"Class: PyWorkspace"},{"location":"api/classes/PyWorkspace/#methods","text":"","title":"Methods"},{"location":"api/classes/PyWorkspace/#properties","text":"desktop(...) \u2014 None( (flame.PyWorkspace)arg1) -> object None( (flame.PyWorkspace)arg1) -> object libraries(...) \u2014 None( (flame.PyWorkspace)arg1) -> list None( (flame.PyWorkspace)arg1) -> list","title":"Properties"},{"location":"api/classes/PyWorkspace/#built-in-methods","text":"create_library(...) \u2014 create_library( (PyWorkspace)arg1, (str)name) -> object : create_library( (PyWorkspace)arg1, (str)name) -> object : Create a new Library in a Workspace. replace_desktop(...) \u2014 replace_desktop( (PyWorkspace)arg1, (PyDesktop)desktop) -> bool : replace_desktop( (PyWorkspace)arg1, (PyDesktop)desktop) -> bool : Replace the Workspace active Desktop with another one. set_desktop_reels(...) \u2014 set_desktop_reels( (PyWorkspace)arg1 [, (object)group=None]) -> bool : set_desktop_reels( (PyWorkspace)arg1 [, (object)group=None]) -> bool : Set the Desktop Reels view mode. set_freeform(...) \u2014 set_freeform( (PyWorkspace)arg1 [, (object)reel=None]) -> bool : set_freeform( (PyWorkspace)arg1 [, (object)reel=None]) -> bool : Set the Freeform view mode.","title":"Built-in methods"},{"location":"api/classes/PyWriteFileNode/","text":"Class: PyWriteFileNode Module : flame Class derived from PyRenderNode. This class represents a WriteFile node. Methods Built-in methods get_resolved_media_path(...) \u2014 get_resolved_media_path( (PyWriteFileNode)arg1 [, (bool)show_extension=True [, (bool)translate_path=True [, (object)frame=None]]]) -> object : get_resolved_media_path( (PyWriteFileNode)arg1 [, (bool)show_extension=True [, (bool)translate_path=True [, (object)frame=None]]]) -> object : Return the resolved media path. Keyword arguments: show_extension -- Set True to display the extension. translate_path -- Set True to apply the Media Location Path Translation. frame -- Pass a frame number, between range_start and range_end, to get the path for that frame.","title":"Class: PyWriteFileNode"},{"location":"api/classes/PyWriteFileNode/#class-pywritefilenode","text":"Module : flame Class derived from PyRenderNode. This class represents a WriteFile node.","title":"Class: PyWriteFileNode"},{"location":"api/classes/PyWriteFileNode/#methods","text":"","title":"Methods"},{"location":"api/classes/PyWriteFileNode/#built-in-methods","text":"get_resolved_media_path(...) \u2014 get_resolved_media_path( (PyWriteFileNode)arg1 [, (bool)show_extension=True [, (bool)translate_path=True [, (object)frame=None]]]) -> object : get_resolved_media_path( (PyWriteFileNode)arg1 [, (bool)show_extension=True [, (bool)translate_path=True [, (object)frame=None]]]) -> object : Return the resolved media path. Keyword arguments: show_extension -- Set True to display the extension. translate_path -- Set True to apply the Media Location Path Translation. frame -- Pass a frame number, between range_start and range_end, to get the path for that frame.","title":"Built-in methods"},{"location":"api/constants/","text":"Constants batch browser clear_graphics_memory clear_unreferenced_cache delete duplicate duplicate_many execute_command execute_shortcut exit find_by_name find_by_uid find_by_wiretap_node_id flush_graphics_memory get_current_tab get_home_directory get_init_cfg_path get_version get_version_major get_version_minor get_version_patch get_version_stamp go_to import_clips media_panel mediahub messages project projects schedule_idle_event set_current_tab set_render_option timeline users","title":"Constants"},{"location":"api/constants/#constants","text":"batch browser clear_graphics_memory clear_unreferenced_cache delete duplicate duplicate_many execute_command execute_shortcut exit find_by_name find_by_uid find_by_wiretap_node_id flush_graphics_memory get_current_tab get_home_directory get_init_cfg_path get_version get_version_major get_version_minor get_version_patch get_version_stamp go_to import_clips media_panel mediahub messages project projects schedule_idle_event set_current_tab set_render_option timeline users","title":"Constants"},{"location":"api/constants/batch/","text":"Constant: batch Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: batch"},{"location":"api/constants/batch/#constant-batch","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: batch"},{"location":"api/constants/browser/","text":"Constant: browser Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: browser"},{"location":"api/constants/browser/#constant-browser","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: browser"},{"location":"api/constants/clear_graphics_memory/","text":"Constant: clear_graphics_memory Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: clear_graphics_memory"},{"location":"api/constants/clear_graphics_memory/#constant-clear_graphics_memory","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: clear_graphics_memory"},{"location":"api/constants/clear_unreferenced_cache/","text":"Constant: clear_unreferenced_cache Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: clear_unreferenced_cache"},{"location":"api/constants/clear_unreferenced_cache/#constant-clear_unreferenced_cache","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: clear_unreferenced_cache"},{"location":"api/constants/delete/","text":"Constant: delete Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: delete"},{"location":"api/constants/delete/#constant-delete","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: delete"},{"location":"api/constants/duplicate/","text":"Constant: duplicate Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: duplicate"},{"location":"api/constants/duplicate/#constant-duplicate","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: duplicate"},{"location":"api/constants/duplicate_many/","text":"Constant: duplicate_many Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: duplicate_many"},{"location":"api/constants/duplicate_many/#constant-duplicate_many","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: duplicate_many"},{"location":"api/constants/execute_command/","text":"Constant: execute_command Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: execute_command"},{"location":"api/constants/execute_command/#constant-execute_command","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: execute_command"},{"location":"api/constants/execute_shortcut/","text":"Constant: execute_shortcut Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: execute_shortcut"},{"location":"api/constants/execute_shortcut/#constant-execute_shortcut","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: execute_shortcut"},{"location":"api/constants/exit/","text":"Constant: exit Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: exit"},{"location":"api/constants/exit/#constant-exit","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: exit"},{"location":"api/constants/find_by_name/","text":"Constant: find_by_name Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: find_by_name"},{"location":"api/constants/find_by_name/#constant-find_by_name","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: find_by_name"},{"location":"api/constants/find_by_uid/","text":"Constant: find_by_uid Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: find_by_uid"},{"location":"api/constants/find_by_uid/#constant-find_by_uid","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: find_by_uid"},{"location":"api/constants/find_by_wiretap_node_id/","text":"Constant: find_by_wiretap_node_id Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: find_by_wiretap_node_id"},{"location":"api/constants/find_by_wiretap_node_id/#constant-find_by_wiretap_node_id","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: find_by_wiretap_node_id"},{"location":"api/constants/flush_graphics_memory/","text":"Constant: flush_graphics_memory Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: flush_graphics_memory"},{"location":"api/constants/flush_graphics_memory/#constant-flush_graphics_memory","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: flush_graphics_memory"},{"location":"api/constants/get_current_tab/","text":"Constant: get_current_tab Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_current_tab"},{"location":"api/constants/get_current_tab/#constant-get_current_tab","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_current_tab"},{"location":"api/constants/get_home_directory/","text":"Constant: get_home_directory Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_home_directory"},{"location":"api/constants/get_home_directory/#constant-get_home_directory","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_home_directory"},{"location":"api/constants/get_init_cfg_path/","text":"Constant: get_init_cfg_path Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_init_cfg_path"},{"location":"api/constants/get_init_cfg_path/#constant-get_init_cfg_path","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_init_cfg_path"},{"location":"api/constants/get_version/","text":"Constant: get_version Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_version"},{"location":"api/constants/get_version/#constant-get_version","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_version"},{"location":"api/constants/get_version_major/","text":"Constant: get_version_major Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_version_major"},{"location":"api/constants/get_version_major/#constant-get_version_major","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_version_major"},{"location":"api/constants/get_version_minor/","text":"Constant: get_version_minor Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_version_minor"},{"location":"api/constants/get_version_minor/#constant-get_version_minor","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_version_minor"},{"location":"api/constants/get_version_patch/","text":"Constant: get_version_patch Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_version_patch"},{"location":"api/constants/get_version_patch/#constant-get_version_patch","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_version_patch"},{"location":"api/constants/get_version_stamp/","text":"Constant: get_version_stamp Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_version_stamp"},{"location":"api/constants/get_version_stamp/#constant-get_version_stamp","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: get_version_stamp"},{"location":"api/constants/go_to/","text":"Constant: go_to Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: go_to"},{"location":"api/constants/go_to/#constant-go_to","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: go_to"},{"location":"api/constants/import_clips/","text":"Constant: import_clips Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: import_clips"},{"location":"api/constants/import_clips/#constant-import_clips","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: import_clips"},{"location":"api/constants/media_panel/","text":"Constant: media_panel Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: media_panel"},{"location":"api/constants/media_panel/#constant-media_panel","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: media_panel"},{"location":"api/constants/mediahub/","text":"Constant: mediahub Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: mediahub"},{"location":"api/constants/mediahub/#constant-mediahub","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: mediahub"},{"location":"api/constants/messages/","text":"Constant: messages Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: messages"},{"location":"api/constants/messages/#constant-messages","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: messages"},{"location":"api/constants/project/","text":"Constant: project Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: project"},{"location":"api/constants/project/#constant-project","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: project"},{"location":"api/constants/projects/","text":"Constant: projects Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: projects"},{"location":"api/constants/projects/#constant-projects","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: projects"},{"location":"api/constants/schedule_idle_event/","text":"Constant: schedule_idle_event Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: schedule_idle_event"},{"location":"api/constants/schedule_idle_event/#constant-schedule_idle_event","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: schedule_idle_event"},{"location":"api/constants/set_current_tab/","text":"Constant: set_current_tab Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: set_current_tab"},{"location":"api/constants/set_current_tab/#constant-set_current_tab","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: set_current_tab"},{"location":"api/constants/set_render_option/","text":"Constant: set_render_option Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: set_render_option"},{"location":"api/constants/set_render_option/#constant-set_render_option","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: set_render_option"},{"location":"api/constants/timeline/","text":"Constant: timeline Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: timeline"},{"location":"api/constants/timeline/#constant-timeline","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: timeline"},{"location":"api/constants/users/","text":"Constant: users Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: users"},{"location":"api/constants/users/#constant-users","text":"Module : flame Documentation for constants is collected from runtime introspection when available.","title":"Constant: users"},{"location":"api/functions/","text":"Functions","title":"Functions"},{"location":"api/functions/#functions","text":"","title":"Functions"},{"location":"api/functions/clear_graphics_memory/","text":"Function: clear_graphics_memory Module : flame Signature : clear_graphics_memory(...) clear_graphics_memory() -> None : Free as much graphics memory as possible. Note that clearing the undo buffer beforehand can increase the amount of releasable graphics memory.","title":"Function: clear_graphics_memory"},{"location":"api/functions/clear_graphics_memory/#function-clear_graphics_memory","text":"Module : flame Signature : clear_graphics_memory(...) clear_graphics_memory() -> None : Free as much graphics memory as possible. Note that clearing the undo buffer beforehand can increase the amount of releasable graphics memory.","title":"Function: clear_graphics_memory"},{"location":"api/functions/clear_unreferenced_cache/","text":"Function: clear_unreferenced_cache Module : flame Signature : clear_unreferenced_cache(...) clear_unreferenced_cache([ (bool)all_projects=False]) -> None : Clear cached media that is no longer referenced by any clip in eitherthe current project or any other project. all_projects -- If True, will also clear unreferenced cached media from all other accessible projects. Default is False, which will only clear unreferenced cached media from the current project.","title":"Function: clear_unreferenced_cache"},{"location":"api/functions/clear_unreferenced_cache/#function-clear_unreferenced_cache","text":"Module : flame Signature : clear_unreferenced_cache(...) clear_unreferenced_cache([ (bool)all_projects=False]) -> None : Clear cached media that is no longer referenced by any clip in eitherthe current project or any other project. all_projects -- If True, will also clear unreferenced cached media from all other accessible projects. Default is False, which will only clear unreferenced cached media from the current project.","title":"Function: clear_unreferenced_cache"},{"location":"api/functions/delete/","text":"Function: delete Module : flame Signature : delete(...) delete( (PyFlameObject)object [, (bool)confirm=True]) -> bool : Delete the target object.","title":"Function: delete"},{"location":"api/functions/delete/#function-delete","text":"Module : flame Signature : delete(...) delete( (PyFlameObject)object [, (bool)confirm=True]) -> bool : Delete the target object.","title":"Function: delete"},{"location":"api/functions/duplicate/","text":"Function: duplicate Module : flame Signature : duplicate(...) duplicate( (PyFlameObject)object [, (bool)keep_node_connections=False]) -> object : Duplicate the target object.","title":"Function: duplicate"},{"location":"api/functions/duplicate/#function-duplicate","text":"Module : flame Signature : duplicate(...) duplicate( (PyFlameObject)object [, (bool)keep_node_connections=False]) -> object : Duplicate the target object.","title":"Function: duplicate"},{"location":"api/functions/duplicate_many/","text":"Function: duplicate_many Module : flame Signature : duplicate_many(...) duplicate_many( (list)object_list [, (bool)keep_node_connections=False]) -> list : Duplicate the target objects.","title":"Function: duplicate_many"},{"location":"api/functions/duplicate_many/#function-duplicate_many","text":"Module : flame Signature : duplicate_many(...) duplicate_many( (list)object_list [, (bool)keep_node_connections=False]) -> list : Duplicate the target objects.","title":"Function: duplicate_many"},{"location":"api/functions/execute_command/","text":"Function: execute_command Module : flame Signature : execute_command(...) execute_command( (str)command [, (bool)blocking=True [, (bool)shell=False [, (bool)capture_stdout=False [, (bool)capture_stderr=False]]]]) -> tuple : Execute command line through the Autodesk Flame Multi-Purpose Daemon. This way of starting new processes is better since any native python subprocess command (os.system, subprocess, Popen, etc) will call fork() which will duplicate the process memory before calling exec(). This can be costly especially for a process like Flame. command -- Command line to execute. blocking -- If True, will not return until the command line has completed. shell -- Should the command be executed in a sh shell. WARNING Using shell=True can be a security hazard. capture_stdout -- If True, stdout of the command will be captured and returned instead of forwarded to the application stdout. Requires blocking=True capture_stderr -- If True, stdout of the command will be captured and returned instead of forwarded to the application stderr. Requires blocking=True Note: Environment variables will not be forwarded to the executed command.","title":"Function: execute_command"},{"location":"api/functions/execute_command/#function-execute_command","text":"Module : flame Signature : execute_command(...) execute_command( (str)command [, (bool)blocking=True [, (bool)shell=False [, (bool)capture_stdout=False [, (bool)capture_stderr=False]]]]) -> tuple : Execute command line through the Autodesk Flame Multi-Purpose Daemon. This way of starting new processes is better since any native python subprocess command (os.system, subprocess, Popen, etc) will call fork() which will duplicate the process memory before calling exec(). This can be costly especially for a process like Flame. command -- Command line to execute. blocking -- If True, will not return until the command line has completed. shell -- Should the command be executed in a sh shell. WARNING Using shell=True can be a security hazard. capture_stdout -- If True, stdout of the command will be captured and returned instead of forwarded to the application stdout. Requires blocking=True capture_stderr -- If True, stdout of the command will be captured and returned instead of forwarded to the application stderr. Requires blocking=True Note: Environment variables will not be forwarded to the executed command.","title":"Function: execute_command"},{"location":"api/functions/execute_shortcut/","text":"Function: execute_shortcut Module : flame Signature : execute_shortcut(...) execute_shortcut( (str)description [, (bool)update_list=True]) -> bool : Execute the Flame shortcut. description -- The description in the Keyboard Shortcut editor.","title":"Function: execute_shortcut"},{"location":"api/functions/execute_shortcut/#function-execute_shortcut","text":"Module : flame Signature : execute_shortcut(...) execute_shortcut( (str)description [, (bool)update_list=True]) -> bool : Execute the Flame shortcut. description -- The description in the Keyboard Shortcut editor.","title":"Function: execute_shortcut"},{"location":"api/functions/exit/","text":"Function: exit Module : flame Signature : exit(...) exit() -> None : Exit the application.","title":"Function: exit"},{"location":"api/functions/exit/#function-exit","text":"Module : flame Signature : exit(...) exit() -> None : Exit the application.","title":"Function: exit"},{"location":"api/functions/find_by_name/","text":"Function: find_by_name Module : flame Signature : find_by_name(...) find_by_name( (str)name [, (object)parent=None]) -> list : Find a Flame object in the Media Panel by name.","title":"Function: find_by_name"},{"location":"api/functions/find_by_name/#function-find_by_name","text":"Module : flame Signature : find_by_name(...) find_by_name( (str)name [, (object)parent=None]) -> list : Find a Flame object in the Media Panel by name.","title":"Function: find_by_name"},{"location":"api/functions/find_by_uid/","text":"Function: find_by_uid Module : flame Signature : find_by_uid(...) find_by_uid( (str)uid) -> object : Find a Flame object in the Media Panel by UID.","title":"Function: find_by_uid"},{"location":"api/functions/find_by_uid/#function-find_by_uid","text":"Module : flame Signature : find_by_uid(...) find_by_uid( (str)uid) -> object : Find a Flame object in the Media Panel by UID.","title":"Function: find_by_uid"},{"location":"api/functions/find_by_wiretap_node_id/","text":"Function: find_by_wiretap_node_id Module : flame Signature : find_by_wiretap_node_id(...) find_by_wiretap_node_id( (str)node_id) -> object : Find a Flame object in the Media Panel by Wiretap Node ID.","title":"Function: find_by_wiretap_node_id"},{"location":"api/functions/find_by_wiretap_node_id/#function-find_by_wiretap_node_id","text":"Module : flame Signature : find_by_wiretap_node_id(...) find_by_wiretap_node_id( (str)node_id) -> object : Find a Flame object in the Media Panel by Wiretap Node ID.","title":"Function: find_by_wiretap_node_id"},{"location":"api/functions/flush_graphics_memory/","text":"Function: flush_graphics_memory Module : flame Signature : flush_graphics_memory(...) flush_graphics_memory() -> None : Free as much graphics memory as possible. Note that clearing the undo buffer beforehand can increase the amount of releasable graphics memory. (Deprecated: use clear_graphics_memory instead)","title":"Function: flush_graphics_memory"},{"location":"api/functions/flush_graphics_memory/#function-flush_graphics_memory","text":"Module : flame Signature : flush_graphics_memory(...) flush_graphics_memory() -> None : Free as much graphics memory as possible. Note that clearing the undo buffer beforehand can increase the amount of releasable graphics memory. (Deprecated: use clear_graphics_memory instead)","title":"Function: flush_graphics_memory"},{"location":"api/functions/get_current_tab/","text":"Function: get_current_tab Module : flame Signature : get_current_tab(...) get_current_tab() -> str : Get the current tab name.","title":"Function: get_current_tab"},{"location":"api/functions/get_current_tab/#function-get_current_tab","text":"Module : flame Signature : get_current_tab(...) get_current_tab() -> str : Get the current tab name.","title":"Function: get_current_tab"},{"location":"api/functions/get_home_directory/","text":"Function: get_home_directory Module : flame Signature : get_home_directory(...) get_home_directory() -> str : Get the application home directory.","title":"Function: get_home_directory"},{"location":"api/functions/get_home_directory/#function-get_home_directory","text":"Module : flame Signature : get_home_directory(...) get_home_directory() -> str : Get the application home directory.","title":"Function: get_home_directory"},{"location":"api/functions/get_init_cfg_path/","text":"Function: get_init_cfg_path Module : flame Signature : get_init_cfg_path(...) get_init_cfg_path() -> str : Get the application init configuration file.","title":"Function: get_init_cfg_path"},{"location":"api/functions/get_init_cfg_path/#function-get_init_cfg_path","text":"Module : flame Signature : get_init_cfg_path(...) get_init_cfg_path() -> str : Get the application init configuration file.","title":"Function: get_init_cfg_path"},{"location":"api/functions/get_version/","text":"Function: get_version Module : flame Signature : get_version(...) get_version() -> str : Get the application version.","title":"Function: get_version"},{"location":"api/functions/get_version/#function-get_version","text":"Module : flame Signature : get_version(...) get_version() -> str : Get the application version.","title":"Function: get_version"},{"location":"api/functions/get_version_major/","text":"Function: get_version_major Module : flame Signature : get_version_major(...) get_version_major() -> str : Get the application major version.","title":"Function: get_version_major"},{"location":"api/functions/get_version_major/#function-get_version_major","text":"Module : flame Signature : get_version_major(...) get_version_major() -> str : Get the application major version.","title":"Function: get_version_major"},{"location":"api/functions/get_version_minor/","text":"Function: get_version_minor Module : flame Signature : get_version_minor(...) get_version_minor() -> str : Get the application minor version.","title":"Function: get_version_minor"},{"location":"api/functions/get_version_minor/#function-get_version_minor","text":"Module : flame Signature : get_version_minor(...) get_version_minor() -> str : Get the application minor version.","title":"Function: get_version_minor"},{"location":"api/functions/get_version_patch/","text":"Function: get_version_patch Module : flame Signature : get_version_patch(...) get_version_patch() -> str : Get the application patch version.","title":"Function: get_version_patch"},{"location":"api/functions/get_version_patch/#function-get_version_patch","text":"Module : flame Signature : get_version_patch(...) get_version_patch() -> str : Get the application patch version.","title":"Function: get_version_patch"},{"location":"api/functions/get_version_stamp/","text":"Function: get_version_stamp Module : flame Signature : get_version_stamp(...) get_version_stamp() -> str : Get the application version stamp.","title":"Function: get_version_stamp"},{"location":"api/functions/get_version_stamp/#function-get_version_stamp","text":"Module : flame Signature : get_version_stamp(...) get_version_stamp() -> str : Get the application version stamp.","title":"Function: get_version_stamp"},{"location":"api/functions/go_to/","text":"Function: go_to Module : flame Signature : go_to(...) go_to( (str)tab) -> bool : Deprecated / use set_current_tab() instead.","title":"Function: go_to"},{"location":"api/functions/go_to/#function-go_to","text":"Module : flame Signature : go_to(...) go_to( (str)tab) -> bool : Deprecated / use set_current_tab() instead.","title":"Function: go_to"},{"location":"api/functions/import_clips/","text":"Function: import_clips Module : flame Signature : import_clips(...) import_clips( (object)path [, (object)destination=None]) -> list : Import one or many clips from a path. Keyword arguments: path -- The path to the media can be: - A path to a single media file. - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). - A folder containing media files. - A pattern to media files (ie \"/dir/{name}_v{version}.{frame}.{extension}\"). - A list of paths. destination -- Flame object containing a clip like a reel or a folder object.","title":"Function: import_clips"},{"location":"api/functions/import_clips/#function-import_clips","text":"Module : flame Signature : import_clips(...) import_clips( (object)path [, (object)destination=None]) -> list : Import one or many clips from a path. Keyword arguments: path -- The path to the media can be: - A path to a single media file. - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\"). - A folder containing media files. - A pattern to media files (ie \"/dir/{name}_v{version}.{frame}.{extension}\"). - A list of paths. destination -- Flame object containing a clip like a reel or a folder object.","title":"Function: import_clips"},{"location":"api/functions/schedule_idle_event/","text":"Function: schedule_idle_event Module : flame Signature : schedule_idle_event(...) schedule_idle_event( (object)function [, (int)delay=0]) -> None : Register a function callback that will be called eventually when the application is idle. The function must not block and be quick since it will be executed in the main application thread. Keyword arguments: function -- Callable object to be called. delay -- Minimum time (in seconds) to wait before calling function.","title":"Function: schedule_idle_event"},{"location":"api/functions/schedule_idle_event/#function-schedule_idle_event","text":"Module : flame Signature : schedule_idle_event(...) schedule_idle_event( (object)function [, (int)delay=0]) -> None : Register a function callback that will be called eventually when the application is idle. The function must not block and be quick since it will be executed in the main application thread. Keyword arguments: function -- Callable object to be called. delay -- Minimum time (in seconds) to wait before calling function.","title":"Function: schedule_idle_event"},{"location":"api/functions/set_current_tab/","text":"Function: set_current_tab Module : flame Signature : set_current_tab(...) set_current_tab( (str)arg1) -> bool : Set the given tab as the active environment. Keyword arguments: tab -- The tab to set active (MediaHub, Conform, Timeline, Effects, Batch, Tools)","title":"Function: set_current_tab"},{"location":"api/functions/set_current_tab/#function-set_current_tab","text":"Module : flame Signature : set_current_tab(...) set_current_tab( (str)arg1) -> bool : Set the given tab as the active environment. Keyword arguments: tab -- The tab to set active (MediaHub, Conform, Timeline, Effects, Batch, Tools)","title":"Function: set_current_tab"},{"location":"api/functions/set_render_option/","text":"Function: set_render_option Module : flame Signature : set_render_option(...) set_render_option( (str)render_option [, (str)render_context='']) -> bool : Set the default render option. Keyword arguments: render_option -- Defines the rendering method used. (Foreground) render_context -- Defines the rendering context. (Timeline, Conform, Effects, BFX, Batch). None for all of them.","title":"Function: set_render_option"},{"location":"api/functions/set_render_option/#function-set_render_option","text":"Module : flame Signature : set_render_option(...) set_render_option( (str)render_option [, (str)render_context='']) -> bool : Set the default render option. Keyword arguments: render_option -- Defines the rendering method used. (Foreground) render_context -- Defines the rendering context. (Timeline, Conform, Effects, BFX, Batch). None for all of them.","title":"Function: set_render_option"}]}