{
  "clear_graphics_memory": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "clear_graphics_memory() -> None :\n    Free as much graphics memory as possible.  Note that clearing the undo buffer beforehand can increase the amount of releasable graphics memory.\n    ",
    "page": "functions/clear_graphics_memory.md"
  },
  "clear_unreferenced_cache": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "clear_unreferenced_cache([  (bool)all_projects=False]) -> None :\n    Clear cached media that is no longer referenced by any clip in eitherthe current project or any other project.\n    \n    all_projects -- If True, will also clear unreferenced cached media from all other accessible projects.\n                    Default is False, which will only clear unreferenced cached media from the current project.\n    ",
    "page": "functions/clear_unreferenced_cache.md"
  },
  "delete": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "delete( (PyFlameObject)object [, (bool)confirm=True]) -> bool :\n    Delete the target object.",
    "page": "functions/delete.md"
  },
  "duplicate": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "duplicate( (PyFlameObject)object [, (bool)keep_node_connections=False]) -> object :\n    Duplicate the target object.",
    "page": "functions/duplicate.md"
  },
  "duplicate_many": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "duplicate_many( (list)object_list [, (bool)keep_node_connections=False]) -> list :\n    Duplicate the target objects.",
    "page": "functions/duplicate_many.md"
  },
  "execute_command": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "execute_command( (str)command [, (bool)blocking=True [, (bool)shell=False [, (bool)capture_stdout=False [, (bool)capture_stderr=False]]]]) -> tuple :\n    Execute command line through the Autodesk Flame Multi-Purpose Daemon.\n    This way of starting new processes is better since any native python\n    subprocess command (os.system, subprocess, Popen, etc) will call fork()\n    which will duplicate the process memory before calling exec().\n    This can be costly especially for a process like Flame.\n    \n    command -- Command line to execute.\n    blocking -- If True, will not return until the command line has completed.\n    shell -- Should the command be executed in a sh shell.\n             WARNING Using shell=True can be a security hazard.\n    capture_stdout -- If True, stdout of the command will be captured and\n                      returned instead of forwarded to the application stdout.\n                      Requires blocking=True\n    capture_stderr -- If True, stdout of the command will be captured and\n                      returned instead of forwarded to the application stderr.\n                      Requires blocking=True\n    \n    Note: Environment variables will not be forwarded to the executed command.",
    "page": "functions/execute_command.md"
  },
  "execute_shortcut": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "execute_shortcut( (str)description [, (bool)update_list=True]) -> bool :\n    Execute the Flame shortcut.\n    description  -- The description in the Keyboard Shortcut editor.",
    "page": "functions/execute_shortcut.md"
  },
  "exit": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "exit() -> None :\n    Exit the application.",
    "page": "functions/exit.md"
  },
  "find_by_name": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "find_by_name( (str)name [, (object)parent=None]) -> list :\n    Find a Flame object in the Media Panel by name.",
    "page": "functions/find_by_name.md"
  },
  "find_by_uid": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "find_by_uid( (str)uid) -> object :\n    Find a Flame object in the Media Panel by UID.",
    "page": "functions/find_by_uid.md"
  },
  "find_by_wiretap_node_id": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "find_by_wiretap_node_id( (str)node_id) -> object :\n    Find a Flame object in the Media Panel by Wiretap Node ID.",
    "page": "functions/find_by_wiretap_node_id.md"
  },
  "flush_graphics_memory": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "flush_graphics_memory() -> None :\n    Free as much graphics memory as possible.  Note that clearing the undo buffer beforehand can increase the amount of releasable graphics memory.\n    (Deprecated: use clear_graphics_memory instead)\n    ",
    "page": "functions/flush_graphics_memory.md"
  },
  "get_current_tab": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "get_current_tab() -> str :\n    Get the current tab name.",
    "page": "functions/get_current_tab.md"
  },
  "get_home_directory": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "get_home_directory() -> str :\n    Get the application home directory.",
    "page": "functions/get_home_directory.md"
  },
  "get_init_cfg_path": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "get_init_cfg_path() -> str :\n    Get the application init configuration file.",
    "page": "functions/get_init_cfg_path.md"
  },
  "get_version": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "get_version() -> str :\n    Get the application version.",
    "page": "functions/get_version.md"
  },
  "get_version_major": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "get_version_major() -> str :\n    Get the application major version.",
    "page": "functions/get_version_major.md"
  },
  "get_version_minor": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "get_version_minor() -> str :\n    Get the application minor version.",
    "page": "functions/get_version_minor.md"
  },
  "get_version_patch": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "get_version_patch() -> str :\n    Get the application patch version.",
    "page": "functions/get_version_patch.md"
  },
  "get_version_stamp": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "get_version_stamp() -> str :\n    Get the application version stamp.",
    "page": "functions/get_version_stamp.md"
  },
  "go_to": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "go_to( (str)tab) -> bool :\n    Deprecated / use set_current_tab() instead.",
    "page": "functions/go_to.md"
  },
  "import_clips": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "import_clips( (object)path [, (object)destination=None]) -> list :\n    Import one or many clips from a path.\n    Keyword arguments:\n    path -- The path to the media can be:\n     - A path to a single media file.\n     - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\").\n     - A folder containing media files.\n     - A pattern to media files (ie \"/dir/{name}_v{version}.{frame}.{extension}\").\n     - A list of paths.\n    destination -- Flame object containing a clip like a reel or a folder object.",
    "page": "functions/import_clips.md"
  },
  "schedule_idle_event": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "schedule_idle_event( (object)function [, (int)delay=0]) -> None :\n    Register a function callback that will be called eventually when the application is idle. The function must not block and be quick since it will be executed in the main application thread.\n    Keyword arguments:\n    function -- Callable object to be called.\n    delay -- Minimum time (in seconds) to wait before calling function.\n    ",
    "page": "functions/schedule_idle_event.md"
  },
  "set_current_tab": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "set_current_tab( (str)arg1) -> bool :\n    Set the given tab as the active environment.\n    Keyword arguments:\n    tab -- The tab to set active (MediaHub, Conform, Timeline, Effects, Batch, Tools)",
    "page": "functions/set_current_tab.md"
  },
  "set_render_option": {
    "module": "flame",
    "type": "function",
    "signature": "(...)",
    "doc": "set_render_option( (str)render_option [, (str)render_context='']) -> bool :\n    Set the default render option.\n    Keyword arguments:\n    render_option -- Defines the rendering method used. (Foreground)\n    render_context -- Defines the rendering context. (Timeline, Conform, Effects, BFX, Batch). None for all of them.\n    ",
    "page": "functions/set_render_option.md"
  },
  "PyActionFamilyNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyNode. Represents an Action Family node object.",
    "page": "classes/PyActionFamilyNode.md"
  },
  "PyActionFamilyNode.node_types": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyActionFamilyNode)arg1) -> list"
  },
  "PyActionFamilyNode.nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyActionFamilyNode)arg1) -> list"
  },
  "PyActionFamilyNode.cursor_position": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyActionFamilyNode)arg1) -> tuple"
  },
  "PyActionFamilyNode.all_tabs": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyActionFamilyNode)arg1) -> list"
  },
  "PyActionFamilyNode.left_tabs": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyActionFamilyNode)arg1) -> list"
  },
  "PyActionFamilyNode.right_tabs": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyActionFamilyNode)arg1) -> list"
  },
  "PyActionFamilyNode.create_node": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_node( (PyActionFamilyNode)arg1, (str)node_type [, (str)file_path='' [, (bool)is_udim=False [, (int)tile_resolution=0 [, (str)input_colour_space='']]]]) -> object :\n    Add an Action/Image/GMaskTracer object node to the Action/Image/GMaskTracer schematic.\n    Keyword argument:\n    file_path -- Required by nodes that load an asset, such as Matchbox.\n    input_colour_space -- Optional for nodes that load external media, such as IBL."
  },
  "PyActionFamilyNode.organize": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "organize( (PyActionFamilyNode)arg1) -> bool :\n    Clean up the Action/Image/GMaskTracer schematic."
  },
  "PyActionFamilyNode.get_node": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_node( (PyActionFamilyNode)arg1, (str)node_name) -> object :\n    Get a node by node name. Doesn't select it in the UI."
  },
  "PyActionFamilyNode.connect_nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "connect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool :\n    Connect two nodes in the Action/Image/GMaskTracer schematic.\n    Keyword argument:\n    type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)"
  },
  "PyActionFamilyNode.disconnect_nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "disconnect_nodes( (PyActionFamilyNode)arg1, (PyFlameObject)parent_node, (PyFlameObject)child_node [, (str)link_type='Default']) -> bool :\n    Disconnect two nodes in the Action/Image/GMaskTracer schematic.\n    Keyword argument:\n    type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)"
  },
  "PyActionFamilyNode.media_layers": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyActionFamilyNode)arg1) -> list"
  },
  "PyActionFamilyNode.clear_schematic": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_schematic( (PyActionFamilyNode)arg1) -> bool :\n    Clear the Action/Image/GMaskTracer schematic of all nodes."
  },
  "PyActionFamilyNode.encompass_nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "encompass_nodes( (PyActionFamilyNode)arg1, (list)node_list) -> object :\n    Create a compass including the node list given as argument\n    Keyword argument:\n    node_list -- a list of nodes (either string or node objects)\n    output_type -- the created compass node"
  },
  "PyActionNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyActionFamilyNode. Represents an Action node object.",
    "page": "classes/PyActionNode.md"
  },
  "PyActionNode.media_nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyActionNode)arg1) -> list"
  },
  "PyActionNode.add_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "add_media( (PyActionFamilyNode)arg1) -> object :\n    Add a Media layer to the Batch Action node.\n    Also instantiates a matching Surface node (and Axis) in the Action node schematic."
  },
  "PyActionNode.import_fbx": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list :\n    Import an FBX file into the Action schematic using the Action Objects mode.\n    Keyword argument:\n    file_path -- Path to the FBX file. Mandatory.\n    input_colour_space -- Colour space name used as input for textures. Optional."
  },
  "PyActionNode.export_fbx": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool :\n    Export Action nodes to an FBX file.\n    Keyword argument:\n    file_path -- Path to the output FBX file. Mandatory."
  },
  "PyActionNode.read_fbx": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object :\n    Import an FBX file into the Action schematic using the Read File mode.\n    Keyword argument:\n    file_path -- Path to the FBX file. Mandatory.\n    input_colour_space -- Colour space name used as input for textures. Optional."
  },
  "PyActionNode.import_abc": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list :\n    Import an Alembic (ABC) file into the Action schematic using the Action Objects mode.\n    Keyword argument:\n    file_path -- Path to the ABC file. Mandatory."
  },
  "PyActionNode.read_abc": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object :\n    Import an Alembic (ABC) file into the Action schematic using the Read File mode.\n    Keyword argument:\n    file_path -- Path to the ABC file. Mandatory."
  },
  "PyActionNode.import_psd": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list :\n    Import a PSD file into the Action schematic.\n    Keyword arguments:\n    file_path -- Path to the PSD file. Mandatory.\n    input_colour_space -- The colour space used as input. Optional."
  },
  "PyActionNode.enable_output": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool :\n    Enable the render output_type for the Action node.\n    Keyword argument:\n    output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectoars Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)"
  },
  "PyActionNode.disable_output": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool :\n    Disable the render output_type for the Action node.\n    Keyword argument:\n    output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectors Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)"
  },
  "PyActionNode.output_types": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyActionNode)arg1) -> list"
  },
  "PyArchiveEntry": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyFlameObject. Base class for any object displayed in the Media Panel.",
    "page": "classes/PyArchiveEntry.md"
  },
  "PyArchiveEntry.get_wiretap_storage_id": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_wiretap_storage_id( (PyArchiveEntry)arg1) -> str :\n    Return the Wiretap server's storage ID for the Flame object, but only if the object is in the Media Panel."
  },
  "PyArchiveEntry.get_wiretap_node_id": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_wiretap_node_id( (PyArchiveEntry)arg1) -> str :\n    Return the Wiretap Node ID of the Flame object, but only if the object is in the Media Panel."
  },
  "PyArchiveEntry.commit": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "commit( (PyArchiveEntry)arg1) -> None :\n    Commit to disk the Media Panel object or its closest container possible."
  },
  "PyArchiveEntry.clear_colour": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_colour( (PyArchiveEntry)arg1) -> None :\n    Clear the colour of an object in the Media Panel."
  },
  "PyAttribute": {
    "module": "flame",
    "type": "class",
    "doc": "",
    "page": "classes/PyAttribute.md"
  },
  "PyAttribute.values": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyAttribute)arg1) -> object"
  },
  "PyAttribute.set_value": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_value( (PyAttribute)arg1, (object)arg2) -> bool :\n    Set the value of an attribute."
  },
  "PyAttribute.get_value": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_value( (PyAttribute)arg1) -> object :\n    Get the value of an attribute."
  },
  "PyAudioTrack": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing an Audio Track.",
    "page": "classes/PyAudioTrack.md"
  },
  "PyAudioTrack.channels": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyAudioTrack)arg1) -> list"
  },
  "PyAudioTrack.stereo": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyAudioTrack)arg1) -> bool"
  },
  "PyAudioTrack.copy_to_media_panel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "copy_to_media_panel( (PyAudioTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object :\n    Create a new clip with a copy of the PyObject.\n    "
  },
  "PyBatch": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyFlameObject. This class represents a Batch Group.",
    "page": "classes/PyBatch.md"
  },
  "PyBatch.nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatch)arg1) -> list"
  },
  "PyBatch.node_types": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatch)arg1) -> list"
  },
  "PyBatch.reels": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatch)arg1) -> list"
  },
  "PyBatch.shelf_reels": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatch)arg1) -> list"
  },
  "PyBatch.batch_iterations": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatch)arg1) -> list"
  },
  "PyBatch.current_iteration": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatch)arg1) -> object"
  },
  "PyBatch.contexts": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatch)arg1) -> dict"
  },
  "PyBatch.cursor_position": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatch)arg1) -> tuple"
  },
  "PyBatch.opened": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatch)arg1) -> bool"
  },
  "PyBatch.current_iteration_number": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatch)arg1) -> int"
  },
  "PyBatch.get_node": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_node( (PyBatch)arg1, (str)node_name) -> object :\n    Return a Batch node object with a name matching the parameter. Every node in a Batch schematic has a unique name: no duplicates allowed.\n    Keyword argument:\n    node_name -- Node name."
  },
  "PyBatch.create_node": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_node( (PyBatch)arg1, (str)node_type [, (str)file_path='']) -> object :\n    Create a Batch node object in the Batch schematic.\n     Keyword argument:\n    node_type -- Must be a value from the PyBatch.node_types or the name of a node in the User, Project, or Shared bin."
  },
  "PyBatch.connect_nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "connect_nodes( (PyBatch)arg1, (PyNode)output_node, (str)output_socket_name='Default', (PyNode)input_node [, (str)input_socket_name='Default']) -> bool :\n    Connect two nodes in the Batch schematic.\n    Keyword arguments:\n    output_node -- The Batch node object, the origin of the connection.\n    output_socket_name -- The name of the output socket where the connector starts; use *Default* to use the first output socket, usually *Result*.\n    input_node -- The child Batch node object, the target of the connection.\n    input_socket_name -- The name of the input socket where the connector ends; use *Default* to use the first input socket, usually *Front*. Using *Default* on an Action node connects to the Background socket. To connect to an Action media node, use <ActionNode>.media_nodes[]."
  },
  "PyBatch.disconnect_node": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "disconnect_node( (PyBatch)arg1, (PyNode)node [, (str)input_socket_name='']) -> bool :\n    Disconnect the input links of a given node, given an input socket.\n    Keyword arguments:\n    node -- The Batch node object, the origin of the connection.\n    input_socket_name -- The name of the input socket to disconnect."
  },
  "PyBatch.mimic_link": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "mimic_link( (PyBatch)arg1, (PyNode)leader_node, (PyNode)follower_node) -> bool :\n    Create a Mimic Link between two Batch nodes. They must be of the same node_type.\n    Keyword arguments:\n    leader_node -- The node being mimicked.\n    follower_node -- The node doing the mimicking."
  },
  "PyBatch.clear_context": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_context( (PyBatch)arg1, (int)index) -> bool :\n    Clear a specific Context view in the Batch Group."
  },
  "PyBatch.clear_all_contexts": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_all_contexts( (PyBatch)arg1) -> bool :\n    Clear all registered Context views in the Batch Group."
  },
  "PyBatch.organize": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "organize( (PyBatch)arg1) -> bool :\n    Clean up the nodes layout in the Batch schematic."
  },
  "PyBatch.frame_selected": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "frame_selected( (PyBatch)arg1) -> bool :\n    Set the Batch schematic view to frame the nodes selected in the Batch schematic."
  },
  "PyBatch.frame_all": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "frame_all( (PyBatch)arg1) -> bool :\n    Set the Batch schematic view to frame all the nodes in the Batch schematic."
  },
  "PyBatch.import_clip": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_clip( (PyBatch)arg1, (str)file_path, (str)reel_name) -> object :\n    Import a clip using the Import node, and create a Clip node.\n    Keyword arguments:\n    file_path -- The path to the media can be:\n     - A path to a single media file.\n     - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\").\n     - A pattern to media files (ie \"/dir/name_v{version}.{frame}.{extension}\").reel_name -- The name of the destination Schematic Reel."
  },
  "PyBatch.import_clips": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_clips( (PyBatch)arg1, (object)file_paths, (str)reel_name) -> object :\n    Import clips using the Import node, and then create Clip nodes in the Schematic Reel.\n    Keyword arguments:\n    file_paths -- A path, or a list of paths, to the media that can be:\n     - A path to a single media file.\n     - A path to a sequence of media files (ie \"/dir/clip.[100-2000].dpx\").\n     - A pattern to media files (ie \"/dir/name_v{version}.{frame}.{extension}\").reel_name -- The name of the destination Schematic Reel."
  },
  "PyBatch.save_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "save_setup( (PyBatch)arg1, (str)setup_path) -> bool :\n    Save the Batch Group setup to disk. Includes media paths for clip node object, but not the media files themselves.\n    Keyword argument:\n    setup_path -- The filepath includes the filename. File extension must be .batch."
  },
  "PyBatch.append_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "append_setup( (PyBatch)arg1, (str)setup_path [, (bool)confirm=True]) -> bool :\n    Append a Batch setup file to the existing Batch setup.\n    Keywords arguments:\n    setup_path -- A path and a filename must be defined as arguments.\n    confirm -- Set to True (default) to display a dialogue box in case of "
  },
  "PyBatch.set_viewport_layout": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_viewport_layout( (PyBatch)arg1, (object)num_views) -> bool :\n    Set the viewport layout for Batch.\n    Keyword argument:\n    num_views -- The layout used. (1-Up, 2-Up, 3-Up, 3-Up Split Top, 3-Up Split Left, 3-Up Split Right, 3-Up Split Bottom, 4-Up Split, 4-Up)"
  },
  "PyBatch.create_batch_group": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_batch_group( (PyBatch)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object :\n    Create a new Batch Group object in the Desktop catalogue.\n    Keyword arguments:\n    name -- Name of the Batch Group.\n    nb_reels -- Number of reels created. *reels* overrides *nb_reels*.\n    nb_shelf_reels -- Number of shelf reels. The first shelf reel created is named Batch Renders. *shelf_reels* ovverides *nb_shelf_reels*.\n    reels -- A list of reel names. Overrides *nb_reels*.\n    shelf_reels -- A list of shelf reel names. Overrides *nb_shelf_reels*.\n    start_frame -- The Batch Group's start frame. No timecodes, only a frame value.\n    duration -- The number of frames. Sets the Duration field in the Batch UI. Will be set to the first clip duration when not specified."
  },
  "PyBatch.encompass_nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "encompass_nodes( (PyBatch)arg1, (list)nodes) -> object :\n    Create a Compass around a list of nodes in the Batch schematic.\n     Keyword argument:\n    nodes -- List of strings of node names."
  },
  "PyBatch.select_nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "select_nodes( (PyBatch)arg1, (object)nodes) -> bool :\n    Select nodes.\n    Keyword argument:\n    nodes -- A list of the names of Batch node objects."
  },
  "PyBatch.open": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "open( (PyBatch)arg1) -> bool :\n    Open the Batch Group and display it in the Batch view."
  },
  "PyBatch.close": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "close( (PyBatch)arg1) -> bool :\n    Close the Batch Group. You cannot close the Batch Group currently selected.\n    Closing a Batch Group frees up the application it occupies when open. The size of the used memory is significant if in Batch Group schematic hosts many Action nodes with textures or 3D geoms."
  },
  "PyBatch.clear": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear( (PyBatch)arg1 [, (bool)confirm=True]) -> bool :\n    Clear the Batch Group."
  },
  "PyBatch.save": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "save( (PyBatch)arg1) -> object :\n    Save the Batch Group to the location defined by PyDesktop.destination."
  },
  "PyBatch.append_to_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "append_to_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool :\n    Append a Batch Iteration object to the Batch Group's setup."
  },
  "PyBatch.append_to_batch": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "append_to_batch( (PyBatch)arg1, (PyBatchIteration)batch_iteration) -> bool :\n    Append a Batch Iteration object to the current Batch Group. A duplicate Batch Iteration object is renamed to the next available *vDD*. Batch Iteration objects are displayed in the Iterations folder. Iterations folder is a UI construction, not accessible directly."
  },
  "PyBatch.open_as_batch_group": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "open_as_batch_group( (PyBatch)arg1 [, (bool)confirm=True]) -> bool :\n    Open a Batch Group as a new Batch Group, adding it to PyDesktop.batch_groups. Can only be called from a Library."
  },
  "PyBatch.replace_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "replace_setup( (PyBatch)arg1, (PyBatchIteration)batch_iteration [, (bool)confirm=True]) -> bool :\n    Replace the Batch Group setup with the specified Batch Iteration. Cannot be called on the Batch Group currently selected and displayed in the Batch view."
  },
  "PyBatch.create_reel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_reel( (PyBatch)arg1, (str)name) -> object :\n    Create a new Schematic Reel in the Batch Gtroup."
  },
  "PyBatch.create_shelf_reel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_shelf_reel( (PyBatch)arg1, (str)name) -> object :\n    Create a new Shelf Reel in the Batch Group."
  },
  "PyBatch.clear_colour": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_colour( (PyBatch)arg1) -> None :\n    Clear the colour of an object in the Media Panel."
  },
  "PyBatch.go_to": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "go_to( (PyBatch)arg1) -> bool :\n    Display and set the Batch tab as the active environment."
  },
  "PyBatch.load_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "load_setup( (PyBatch)arg1, (str)setup_path) -> bool :\n    Load a Batch setup from disk and replace the current Batch Group's setup.\n     Keyword argument:\n    setup_path -- Filepath + Batch Setup filename."
  },
  "PyBatch.clear_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_setup( (PyBatch)arg1) -> bool :\n    Clear the Batch Group's setup."
  },
  "PyBatch.iterate": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "iterate( (PyBatch)arg1 [, (int)index=-1]) -> object :\n    Iterate the current Batch Setup, creating a new iteration named BatchSetupName_X, where X is the Batch Iteration's index, and starts at 001.\n     Keyword argument:\n    index -- Specifies the iteration's index. If none is specified, the iteration is assigned the next available index (max index + 1). If the index matches that of an existing Batch Iteration, its overwrites the iteration without warning."
  },
  "PyBatch.save_current_iteration": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "save_current_iteration( (PyBatch)arg1) -> object :\n    Save the current Batch Group setup to the location defined by PyDesktop.destination."
  },
  "PyBatch.render": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "render( (PyBatch)arg1 [, (str)render_option='Foreground' [, (bool)generate_proxies=False [, (bool)include_history=False]]]) -> bool :\n    Trigger the rendering of the Batch Group setup. Every active Render and Write File nodes render. If specified render_option is not supported by the workstation, returns an error.\n    Keyword arguments:\n    render_option -- Defines the rendering method used. (Foreground, Background Reactor, Burn)\n    generate_proxies -- Set to True to render at proxy resolution. (Default: False)\n    include_history -- Set to True to create History with the rendering. (Default:False)"
  },
  "PyBatchIteration": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyArchiveEntry. This class represents a Batch Iteration.",
    "page": "classes/PyBatchIteration.md"
  },
  "PyBatchIteration.iteration_number": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBatchIteration)arg1) -> int"
  },
  "PyBatchIteration.open_as_batch_group": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "open_as_batch_group( (PyBatchIteration)arg1 [, (bool)confirm=True]) -> bool :\n    Open a Batch Iteration as a new Batch Group, adding it to PyDesktop.batch_groups. Can only be called from a Library."
  },
  "PyBrowser": {
    "module": "flame",
    "type": "class",
    "doc": "This class represents the file browser.",
    "page": "classes/PyBrowser.md"
  },
  "PyBrowser.show": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "show( (PyBrowser)arg1, (str)default_path [, (object)extension='' [, (bool)select_directory=False [, (bool)multi_selection=False [, (object)include_resolution=False [, (str)title='Load']]]]]) -> None :\n    Show the file browser.Keyword arguments:\n    default_path -- Set the path.\n    extension -- Set the extension filter. Can be a single extension or a list of extensions.Leave empty to see all files.\n    select_directory -- Only show directories.\n    multi_selection -- Allow the user to select multiple files.\n    include_resolution -- Display the resolution controls. Possible values are False, True, or \"Full\". The Full mode includes the new adaptive and scaling presets modes.\n    title -- Set the window title.\n    "
  },
  "PyBrowser.selection": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> object"
  },
  "PyBrowser.sequence_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> bool"
  },
  "PyBrowser.width": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> object"
  },
  "PyBrowser.height": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> object"
  },
  "PyBrowser.scaling_presets_value": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> object"
  },
  "PyBrowser.bit_depth": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> object"
  },
  "PyBrowser.frame_ratio": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> object"
  },
  "PyBrowser.scan_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> str"
  },
  "PyBrowser.colour_space": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> str"
  },
  "PyBrowser.resize_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> str"
  },
  "PyBrowser.resize_filter": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> str"
  },
  "PyBrowser.resolution": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyBrowser)arg1) -> str"
  },
  "PyClip": {
    "module": "flame",
    "type": "class",
    "doc": "CLass derived from PyArchiveEntry. This class represents a Clip.",
    "page": "classes/PyClip.md"
  },
  "PyClip.frame_rate": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> object"
  },
  "PyClip.duration": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> object"
  },
  "PyClip.versions": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> list"
  },
  "PyClip.audio_tracks": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> list"
  },
  "PyClip.markers": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> list"
  },
  "PyClip.subtitles": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> list"
  },
  "PyClip.width": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> int"
  },
  "PyClip.height": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> int"
  },
  "PyClip.bit_depth": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> int"
  },
  "PyClip.ratio": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> float"
  },
  "PyClip.scan_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> str"
  },
  "PyClip.colour_primaries": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> int"
  },
  "PyClip.transfer_characteristics": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> int"
  },
  "PyClip.matrix_coefficients": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> int"
  },
  "PyClip.proxy_resolution": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> object"
  },
  "PyClip.has_deliverables": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> bool"
  },
  "PyClip.has_history": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> bool"
  },
  "PyClip.unlinked": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> str"
  },
  "PyClip.creation_date": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> str"
  },
  "PyClip.archive_date": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> str"
  },
  "PyClip.archive_error": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> str"
  },
  "PyClip.essence_uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> str"
  },
  "PyClip.source_uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> str"
  },
  "PyClip.original_source_uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> str"
  },
  "PyClip.sample_rate": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> str"
  },
  "PyClip.cached": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> str"
  },
  "PyClip.start_frame": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClip)arg1) -> int"
  },
  "PyClip.open_as_sequence": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "open_as_sequence( (PyClip)arg1) -> object :\n    Open the Clip as a Sequence. Mutates the PyClip object into a PySequence object."
  },
  "PyClip.open_container": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "open_container( (PyClip)arg1) -> bool :\n    Open the container timeline if the Clip is inside a container."
  },
  "PyClip.close_container": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "close_container( (PyClip)arg1) -> None :\n    Close the container timeline if the Clip is inside a container."
  },
  "PyClip.reformat": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "reformat( (PyClip)arg1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='' [, (str)frame_rate='' [, (str)resize_mode='Letterbox']]]]]]]) -> None :\n    Reformat the Clip to the specified format.\n    Keywords arguments:\n    width -- Integer between 24 and 16384.\n    height -- Integer between 24 and 16384.\n    ratio -- Frame aspect ratio. Float between 0.01 and 100.\n    bit_depth -- Bit depth. (8, 10, 12, 16 or 32)\n    scan_mode -- Scan mode of the sequence. (F1, F2, P)\n    frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps)\n    resize_mode -- Resize mode. (Letterbox, Crop Edges, Fill, Centre)"
  },
  "PyClip.create_marker": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_marker( (PyClip)arg1, (object)location) -> object :\n    Add a Marker to the Clip.Keyword argument:\n    location -- The frame where the marker gets created."
  },
  "PyClip.change_dominance": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "change_dominance( (PyClip)arg1, (str)scan_mode) -> None :\n    Change the Clip's dominance. Changes only the clip's metadata.\n    Keyword argument:\n    scan_mode -- Field dominance. (P, F1, F2)"
  },
  "PyClip.cache_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool :\n    Cache the Clip's linked media.\n    Keyword argument:\n    mode -- Determine the version to cache (currently selected or all versions). All Versions is only useful with to multi-version clips (Current, All Versions)"
  },
  "PyClip.flush_cache_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "flush_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool :\n    Clear the Clip's media cache.\n    Keyword argument:\n    mode -- Determine the version's cache to clear. (Current, All Versions, All But Current)(Deprecated: use 'clear_cache_media' instead.)\n    "
  },
  "PyClip.clear_cache_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_cache_media( (PyClip)arg1 [, (str)mode='current']) -> bool :\n    Clear the Clip's media cache.\n    Keyword argument:\n    mode -- Determine the version's cache to clear. (Current, All Versions, All But Current)"
  },
  "PyClip.render": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "render( (PyClip)arg1 [, (str)render_mode='All' [, (str)render_option='Foreground' [, (str)render_quality='Full Resolution' [, (str)effect_type='' [, (str)effect_caching_mode='Current' [, (bool)include_handles=False]]]]]]) -> bool :\n    Trigger a render of the Clip\n    The following attributes can be defined: render_mode, render_option, render_quality, effect_type, effect_caching_mode and include_handles."
  },
  "PyClip.flush_renders": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "flush_renders( (PyClip)arg1) -> None :\n    Clear the Clip's Timeline FX renders.(Deprecated: use 'clear_renders' instead.)\n    "
  },
  "PyClip.clear_renders": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_renders( (PyClip)arg1) -> None :\n    Clear the Clip's Timeline FX renders."
  },
  "PyClip.is_rendered": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "is_rendered( (PyClip)arg1 [, (bool)top_only=False [, (str)render_quality='Full Resolution']]) -> bool :\n    Return if a Clip is rendered.\n    The following attributes can be defined: top_only, render_quality."
  },
  "PyClip.save": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "save( (PyClip)arg1) -> bool :\n    Save the Clip to the defined save destination."
  },
  "PyClip.cut": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "cut( (PyClip)arg1, (PyTime)cut_time) -> None :\n    Cut all tracks of the Clip."
  },
  "PyClip.get_colour_space": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_colour_space( (PyClip)arg1 [, (PyTime)time=None]) -> str :\n    Return the colour space at the requested time. Use current_time when no time is supplied."
  },
  "PyClip.change_start_frame": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "change_start_frame( (PyClip)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None :\n    Modify the start frame of a source Clip.\n    Keywords argument:\n    start_frame -- New start frame of the clip.\n    use_segment_connections -- Sync the start frame of connected segments.\n    "
  },
  "PyClip.get_metadata": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_metadata( (PyClip)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object :\n    Return the metadata of the clip.\n    Keywords argument:\n    key -- Key of the requested metadata. All metadata is returned when not specified.\n    time -- Must be a PyTime. If not specified, the current clip time is used."
  },
  "PyClipNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyNode. This class represents a Clip node.",
    "page": "classes/PyClipNode.md"
  },
  "PyClipNode.clip": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClipNode)arg1) -> object"
  },
  "PyClipNode.version_uids": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClipNode)arg1) -> list"
  },
  "PyClipNode.version_uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyClipNode)arg1) -> object"
  },
  "PyClipNode.set_version_uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_version_uid( (PyClipNode)arg1, (str)version_uid) -> bool :\n    Set the clip node's current version unique ID.\n    Keywords argument:\n    version_uid -- version unique ID."
  },
  "PyClipNode.set_metadata_value": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None :\n    Set the metadata on the Node.\n    Keyword arguments:\n    socket_name -- The socket on which to set the metadata. The default output is used when not specified.\n    key -- Metadata key to be set or added.\n    value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value.\n    "
  },
  "PyClipNode.set_metadata_discarded": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None :\n    Discard key from the Node's metadata output.\n    Keyword arguments:\n    socket_name -- The socket on which the discarded status of the metadata must be changed.\n    key -- Metadata key to be discarded or restored.\n    discarded -- True to discard the key from the node metadata output, False to restore the key.\n    "
  },
  "PyClipNode.set_metadata_key": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None :\n    Rename a metadata key on the Node.\n    Keyword arguments:\n    socket_name -- The socket on which to rename the key. The default output is used when not specified.\n    key -- The current metadata key name to be renamed.\n    name -- The new metadata key name. If None, the current key name will revert to its original value.\n    "
  },
  "PyClrMgmtNode": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Colour Mgmt node.",
    "page": "classes/PyClrMgmtNode.md"
  },
  "PyClrMgmtNode.set_context_variable": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_context_variable( (PyClrMgmtNode)arg1, (str)name, (str)value) -> None :\n    Set the value for the specified context variable."
  },
  "PyClrMgmtNode.get_context_variables": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_context_variables( (PyClrMgmtNode)arg1) -> dict :\n    Get the context variables in a dictionary."
  },
  "PyClrMgmtNode.reset_context_variables": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "reset_context_variables( (PyClrMgmtNode)arg1) -> None :\n    Reset the context variables to their initial state from the ocio config."
  },
  "PyClrMgmtNode.import_transform": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_transform( (PyClrMgmtNode)arg1, (str)file_path) -> None :\n    Import a transform from a file."
  },
  "PyCoCameraAnalysis": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyCoNode. This class represents the camera analysis node in the Action schematic.",
    "page": "classes/PyCoCameraAnalysis.md"
  },
  "PyCoCameraAnalysis.resetAnalysis": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "resetAnalysis( (PyCoCameraAnalysis)arg1) -> bool :\n    Reset the current analysis."
  },
  "PyCoCameraAnalysis.analyseRange": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "analyseRange( (PyCoCameraAnalysis)arg1, (object)arg2, (object)start) -> bool :\n    Run the analysis for the given frame range using the first frame as a reference if none has been already set."
  },
  "PyCoCompass": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyCoNode. This class represents the compass node in the Action schematic.",
    "page": "classes/PyCoCompass.md"
  },
  "PyCoCompass.nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyCoCompass)arg1) -> list"
  },
  "PyCoNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyFlameObject. This class represents an Action node in the Action schematic.",
    "page": "classes/PyCoNode.md"
  },
  "PyCoNode.assign_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "assign_media( (PyCoNode)arg1, (object)media_name) -> bool :\n    Assign a media layer to the node.\n    Keyword argument\n    media_name -- The index of the media layer from Actions' *media_layers*; or the name of the media layer."
  },
  "PyCoNode.cache_range": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "cache_range( (PyCoNode)arg1, (object)arg2, (object)start) -> bool :\n    Cache the selected Map Analysis over the specified range.\n    Keyword arguments\n    start -- The first frame of the range. An integer.\n    end -- The last frame of the range. An integer."
  },
  "PyCoNode.add_reference": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "add_reference( (PyCoNode)arg1, (object)frame) -> bool :\n    Add a Motion Warp map's reference frame at specified index.\n    Keyword argument\n    frame -- The reference frame's index. An integer."
  },
  "PyCoNode.parents": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "parents( (PyCoNode)arg1 [, (str)link_type='Default']) -> list :\n    Return a list of PyCoNode objects that are the parents of the action node.\n    Keyword argument:\n    link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)"
  },
  "PyCoNode.children": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "children( (PyCoNode)arg1 [, (str)link_type='Default']) -> list :\n    Return a list of PyCoNode objects that are the children of the action node.\n    Keyword argument:\n    link_type -- The type of link used to connect the nodes (default, look at, gmask, gmask exclusive, light, light exclusive, mimic)"
  },
  "PyCoNode.type": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyCoNode)arg1) -> str"
  },
  "PyColourMgtTimelineFX": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Colour Mgmt Timeline FX.",
    "page": "classes/PyColourMgtTimelineFX.md"
  },
  "PyColourMgtTimelineFX.set_context_variable": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_context_variable( (PyColourMgtTimelineFX)arg1, (str)name, (str)value) -> None :\n    Set the value for the specified context variable."
  },
  "PyColourMgtTimelineFX.get_context_variables": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_context_variables( (PyColourMgtTimelineFX)arg1) -> dict :\n    Get the context variables in a dictionary."
  },
  "PyColourMgtTimelineFX.import_transform": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_transform( (PyColourMgtTimelineFX)arg1, (str)file_path) -> None :\n    Import a transform from a file."
  },
  "PyColourMgtTimelineFX.reset_context_variables": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "reset_context_variables( (PyColourMgtTimelineFX)arg1) -> None :\n    Reset the context variables to their initial state from the ocio config."
  },
  "PyCompassNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyNode. This class represents a Compass node.",
    "page": "classes/PyCompassNode.md"
  },
  "PyCompassNode.nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyCompassNode)arg1) -> list"
  },
  "PyDesktop": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyArchiveEntry. This class represents a Desktop.",
    "page": "classes/PyDesktop.md"
  },
  "PyDesktop.children": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyDesktop)arg1) -> list"
  },
  "PyDesktop.batch_groups": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyDesktop)arg1) -> list"
  },
  "PyDesktop.reel_groups": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyDesktop)arg1) -> list"
  },
  "PyDesktop.create_reel_group": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_reel_group( (PyDesktop)arg1, (str)name) -> object :\n    Create a new Reel Group object in the Desktop catalogue."
  },
  "PyDesktop.save": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "save( (PyDesktop)arg1) -> bool :\n    Save the Desktop to the location defined by the *destination* attribute."
  },
  "PyDesktop.create_batch_group": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_batch_group( (PyDesktop)arg1, (str)name [, (object)nb_reels=None [, (object)nb_shelf_reels=None [, (list)reels=[] [, (list)shelf_reels=[] [, (int)start_frame=1 [, (object)duration=None]]]]]]) -> object :\n    Create a new Batch Group object in the Desktop catalogue.\n    Keyword arguments:\n    name -- Name of the Batch Group.\n    nb_reels -- Number of reels created. *reels* overrides *nb_reels*.\n    nb_shelf_reels -- Number of shelf reels. The first shelf reel created is named Batch Renders. *shelf_reels* ovverides *nb_shelf_reels*.\n    reels -- A list of reel names. Overrides *nb_reels*.\n    shelf_reels -- A list of shelf reel names. Overrides *nb_shelf_reels*.\n    start_frame -- The Batch Group's start frame. No timecodes, only a frame value.\n    duration -- The number of frames. Sets the Duration field in the Batch UI. Will be set to the first clip duration when not specified."
  },
  "PyDesktop.clear": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear( (PyDesktop)arg1) -> bool :\n    Clear the Desktop."
  },
  "PyExporter": {
    "module": "flame",
    "type": "class",
    "doc": "Object holding export settings.",
    "page": "classes/PyExporter.md"
  },
  "PyExporter.use_top_video_track": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.export_between_marks": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.foreground": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.include_subtitles": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.export_subtitles_as_files": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.export_all_subtitles": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.warn_on_unlinked": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.warn_on_unrendered": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.warn_on_pending_render": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.warn_on_no_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.warn_on_mixed_colour_space": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.warn_on_reimport_unsupported": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.keep_timeline_fx_renders": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyExporter)arg1) -> bool"
  },
  "PyExporter.get_presets_base_dir": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_presets_base_dir( (PyExporter.PresetVisibility)preset_visibility) -> str :\n    Get a presets base directory."
  },
  "PyExporter.get_presets_dir": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_presets_dir( (PyExporter.PresetVisibility)preset_visibility, (PyExporter.PresetType)preset_type) -> str :\n    Get a presets directory."
  },
  "PyExporter.export": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "export( (PyExporter)arg1, (object)sources, (str)preset_path, (str)output_directory [, (PyExporter.BackgroundJobSettings)background_job_settings=None [, (object)hooks=None [, (object)hooks_user_data=None]]]) -> None :\n    Perform export.\n    Keyword arguments:\n    sources -- Flame clip object, a Flame container object or a list of either first. If a container is passed, a multi-export will be done and structure will be respected as much as possible.\n    preset_path -- Absolute path to the export preset to use.\n    output_directory -- Absolute path to the output directory root.\n    background_job_settings -- Settings of background job(s) created if any.\n    hooks -- Export python hooks override. If passed, regular export python hooks implemented in exportHooks.py will be bypassed for this export and methods in the passed object with matching name will be called.\n        Instance of object passed should implement the following signature:\n    \n            class PythonHookOverride(object):\n                def preExport(self, info, userData, *args, **kwargs)\n                    pass\n    \n                def postExport(self, info, userData, *args, **kwargs):\n                    pass\n    \n                def preExportSequence(self, info, userData, *args, **kwargs):\n                    pass\n    \n                def postExportSequence(self, info, userData, *args, **kwargs):\n                    pass\n    \n                def preExportAsset(self, info, userData, *args, **kwargs):\n                    pass\n    \n                def postExportAsset(self, info, userData, *args, **kwargs):\n                    pass\n    \n                def exportOverwriteFile(self, path, *args, **kwargs):\n                    return \"ask\" # or \"overwrite\"\n    \n    hooks_user_data -- User data object passed to the export python hooks. This object can be modified by the PythonHookOverride methods but cannot be re-assigned"
  },
  "PyExporter.BackgroundJobSettings": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "Object holding background export job settings. These settings refer to the Backburner job, server and manager."
  },
  "PyExporter.PresetType": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating-point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4"
  },
  "PyExporter.Image_Sequence": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyExporter.Audio": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyExporter.Movie": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyExporter.Sequence_Publish": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyExporter.Distribution_Package": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyExporter.PresetVisibility": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "int([x]) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating-point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4"
  },
  "PyExporter.User": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyExporter.Project": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyExporter.Shared": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyExporter.Autodesk": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyExporter.Flow_Production_Tracking": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyExporter.Shotgun": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": ""
  },
  "PyFlameObject": {
    "module": "flame",
    "type": "class",
    "doc": "The basic type of all accessible Flame objects from the python API.",
    "page": "classes/PyFlameObject.md"
  },
  "PyFlameObject.attributes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFlameObject)arg1) -> list"
  },
  "PyFlameObject.parent": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFlameObject)arg1) -> object"
  },
  "PyFolder": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyArchiveEntry. This class represents a Folder.",
    "page": "classes/PyFolder.md"
  },
  "PyFolder.children": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFolder)arg1) -> list"
  },
  "PyFolder.folders": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFolder)arg1) -> list"
  },
  "PyFolder.batch_iterations": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFolder)arg1) -> list"
  },
  "PyFolder.desktops": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFolder)arg1) -> list"
  },
  "PyFolder.reel_groups": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFolder)arg1) -> list"
  },
  "PyFolder.reels": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFolder)arg1) -> list"
  },
  "PyFolder.sequences": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFolder)arg1) -> list"
  },
  "PyFolder.clips": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFolder)arg1) -> list"
  },
  "PyFolder.batch_groups": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyFolder)arg1) -> list"
  },
  "PyFolder.clear": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear( (PyFolder)arg1 [, (bool)confirm=True]) -> bool :\n    Clear the contents of the Folder object."
  },
  "PyFolder.create_reel_group": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_reel_group( (PyFolder)arg1, (str)name) -> object :\n    Create a new Reel Group object inside the Folder."
  },
  "PyFolder.create_reel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_reel( (PyFolder)arg1, (str)name) -> object :\n    Create a new Reel object inside the Folder."
  },
  "PyFolder.create_folder": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_folder( (PyFolder)arg1, (str)name) -> object :\n    Create a new Folder object inside the Folder."
  },
  "PyFolder.create_sequence": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_sequence( (PyFolder)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object :\n    Create a Sequence in a PyReel, PyLibrary, PyFolder.\n    Keywords arguments:\n    video_tracks -- Number of video tracks. Integer between 1 and 8.\n    video_stereo -- Stereoscopy. False for mono, True for stereo.\n    width -- Integer between 24 and 16384.\n    height -- Integer between 24 and 16384.\n    ratio -- Frame aspect ratio. Float between 0.01 and 100.\n    scan_mode -- Scan mode of the sequence. (F1, F2, P)\n    frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps)\n    start_at -- Start timecode. The timecode format must be of the format specified by *frame_rate*.\n    duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by *frame_rate*. If an integer, it represents a number of frames.\n    audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16)\n    audio_stereo -- Stereophony, apply to all *audio_tracks*. False for mono tracks, True for stereo."
  },
  "PyGMaskTracerNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyActionFamilyNode. Represents a GMask Tracer node object.",
    "page": "classes/PyGMaskTracerNode.md"
  },
  "PyGMaskTracerNode.import_fbx": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)create_media=True [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]]) -> list :\n    Import an FBX file into the GMask Tracer schematic using the GMask Tracer Objects mode.\n    Keyword argument:\n    file_path -- Path to the FBX file. Mandatory.\n    input_colour_space -- Colour space name used as input for textures. Optional."
  },
  "PyGMaskTracerNode.export_fbx": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "export_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)only_selected_nodes=False [, (float)pixel_to_units=0.10000000149011612 [, (str)frame_rate='23.976 fps' [, (bool)bake_animation=False [, (bool)export_axes=True [, (bool)export_point_locators=False [, (bool)combine_material=True [, (bool)duplicate_material=False]]]]]]]]) -> bool :\n    Export GMask Tracer nodes to an FBX file.\n    Keyword argument:\n    file_path -- Path to the output FBX file. Mandatory."
  },
  "PyGMaskTracerNode.read_fbx": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "read_fbx( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (bool)keep_frame_rate=True [, (bool)bake_animation=False [, (bool)object_properties=True [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)is_udim=False [, (bool)relink_material=True [, (str)input_colour_space='']]]]]]]]]]]]]) -> object :\n    Import an FBX file into the GMask Tracer schematic using the Read File mode.\n    Keyword argument:\n    file_path -- Path to the FBX file. Mandatory.\n    input_colour_space -- Colour space name used as input for textures. Optional."
  },
  "PyGMaskTracerNode.import_abc": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> list :\n    Import an Alembic (ABC) file into the GMask Tracer schematic using the GMask Tracer Objects mode.\n    Keyword argument:\n    file_path -- Path to the ABC file. Mandatory."
  },
  "PyGMaskTracerNode.read_abc": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "read_abc( (PyActionFamilyNode)arg1, (str)file_path [, (bool)lights=True [, (bool)cameras=True [, (bool)models=True [, (bool)normals=True [, (bool)mesh_animations=True [, (str)frame_rate='23.976 fps' [, (bool)auto_fit=False [, (float)unit_to_pixels=10.0 [, (bool)consolidate_geometry=True [, (bool)create_object_group=False]]]]]]]]]]) -> object :\n    Import an Alembic (ABC) file into the GMask Tracer schematic using the Read File mode.\n    Keyword argument:\n    file_path -- Path to the ABC file. Mandatory."
  },
  "PyGMaskTracerNode.import_psd": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_psd( (PyActionFamilyNode)arg1, (str)file_path [, (str)input_colour_space='']) -> list :\n    Import a PSD file into the GMask Tracer schematic.\n    Keyword arguments:\n    file_path -- Path to the PSD file. Mandatory.\n    input_colour_space -- The colour space used as input. Optional."
  },
  "PyGMaskTracerNode.enable_output": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "enable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool :\n    Enable the render output_type for the GMask Tracer node.\n    Keyword argument:\n    output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectoars Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)"
  },
  "PyGMaskTracerNode.disable_output": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "disable_output( (PyActionFamilyNode)arg1, (str)output_type) -> bool :\n    Disable the render output_type for the GMask Tracer node.\n    Keyword argument:\n    output_type -- The output to enable. (Comp, Matte, 3D Motion, Albedo, AO, Background, Emissive, GMask, Lens Flare, Motion Vectors, Normals, Object ID, Occluder, Position, Projectors Matte, Reflection, Roughness, Shadow, Specular, UV, Z-Depth HQ, Z-Depth)"
  },
  "PyGMaskTracerNode.output_types": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyGMaskTracerNode)arg1) -> list"
  },
  "PyHDRNode": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a HDR node.",
    "page": "classes/PyHDRNode.md"
  },
  "PyHDRNode.analysis_status": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyHDRNode)arg1) -> object"
  },
  "PyHDRNode.analyze": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "analyze( (PyHDRNode)arg1 [, (str)analyze_mode='Current Shot']) -> None :\n    Perform HDR analysis."
  },
  "PyHDRNode.keep_analysis": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "keep_analysis( (PyHDRNode)arg1) -> None :\n    Remove the dirty flag from the HDR analysis."
  },
  "PyHDRNode.reset_analysis": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "reset_analysis( (PyHDRNode)arg1) -> None :\n    Reset the current HDR analysis."
  },
  "PyHDRNode.interpolate_trims": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "interpolate_trims( (PyHDRNode)arg1) -> None :\n    Interpolate the current HDR trims."
  },
  "PyHDRNode.reset_trims": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "reset_trims( (PyHDRNode)arg1) -> None :\n    Reset the current HDR trims."
  },
  "PyHDRNode.export_DolbyVision_xml": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "export_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)comment='']) -> None :\n    Export the current HDR to a Dolby Vision XML file."
  },
  "PyHDRNode.import_DolbyVision_xml": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_DolbyVision_xml( (PyHDRNode)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None :\n    Import the current HDR from a Dolby Vision XML file."
  },
  "PyHDRNode.mastering_display_ids": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyHDRNode)arg1) -> list"
  },
  "PyHDRNode.target_display_ids": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyHDRNode)arg1) -> list"
  },
  "PyHDRNode.mastering_display_info": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyHDRNode)arg1) -> object"
  },
  "PyHDRNode.target_display_info": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyHDRNode)arg1) -> object"
  },
  "PyHDRNode.has_trim": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "has_trim( (PyHDRNode)arg1, (int)target_display_id) -> bool :\n    Returns True if the given Target Display ID has trims."
  },
  "PyHDRNode.l2_from_l8": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "l2_from_l8( (PyHDRNode)arg1) -> object :\n    Dictionary containing the L2 values based on L8 values. Not valid in Dolby Vision 2.9."
  },
  "PyHDRTimelineFX": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a HDR Timeline FX.",
    "page": "classes/PyHDRTimelineFX.md"
  },
  "PyHDRTimelineFX.analysis_status": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyHDRTimelineFX)arg1) -> object"
  },
  "PyHDRTimelineFX.analyze": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "analyze( (PyHDRTimelineFX)arg1 [, (str)analyze_mode='Current Shot']) -> None :\n    Perform HDR analysis."
  },
  "PyHDRTimelineFX.keep_analysis": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "keep_analysis( (PyHDRTimelineFX)arg1) -> None :\n    Remove the dirty flag from the HDR analysis."
  },
  "PyHDRTimelineFX.reset_analysis": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "reset_analysis( (PyHDRTimelineFX)arg1) -> None :\n    Reset the current HDR analysis."
  },
  "PyHDRTimelineFX.interpolate_trims": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "interpolate_trims( (PyHDRTimelineFX)arg1, (str)arg2) -> None :\n    Interpolate the current HDR trims."
  },
  "PyHDRTimelineFX.reset_trims": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "reset_trims( (PyHDRTimelineFX)arg1) -> None :\n    Reset the current HDR trims."
  },
  "PyHDRTimelineFX.export_DolbyVision_xml": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "export_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (bool)shot_only=False [, (str)comment='']]) -> None :\n    Export the current HDR to a Dolby Vision XML file."
  },
  "PyHDRTimelineFX.import_DolbyVision_xml": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_DolbyVision_xml( (PyHDRTimelineFX)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)shot_idx=0]]) -> None :\n    Import the current HDR from a Dolby Vision XML file."
  },
  "PyHDRTimelineFX.mastering_display_ids": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyHDRTimelineFX)arg1) -> list"
  },
  "PyHDRTimelineFX.target_display_ids": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyHDRTimelineFX)arg1) -> list"
  },
  "PyHDRTimelineFX.mastering_display_info": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyHDRTimelineFX)arg1) -> object"
  },
  "PyHDRTimelineFX.target_display_info": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyHDRTimelineFX)arg1) -> object"
  },
  "PyHDRTimelineFX.has_trim": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "has_trim( (PyHDRTimelineFX)arg1, (int)target_display_id) -> bool :\n    Returns True if the given Target Display ID has trims."
  },
  "PyHDRTimelineFX.l2_from_l8": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "l2_from_l8( (PyHDRTimelineFX)arg1) -> object :\n    Dictionary containing the L2 values based on L8 values. Not valid in Dolby Vision 2.9."
  },
  "PyImageNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyActionFamilyNode. Represents an Image node object.",
    "page": "classes/PyImageNode.md"
  },
  "PyImageNode.media_nodes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyImageNode)arg1) -> list"
  },
  "PyImageNode.add_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "add_media( (PyActionFamilyNode)arg1) -> object :\n    Add a Media layer to the Batch Image node."
  },
  "PyLensDistortionNode": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Lens Distortion node.",
    "page": "classes/PyLensDistortionNode.md"
  },
  "PyLensDistortionNode.import_lens_distortion": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_lens_distortion( (PyLensDistortionNode)arg1, (str)filename) -> None :\n    Import the Lens Distortion file."
  },
  "PyLensDistortionNode.calculate": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "calculate( (PyLensDistortionNode)arg1) -> None :\n    Calculate the amount of distorsion based on the position of vertices."
  },
  "PyLibrary": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyArchiveEntry. This class represents a Library.",
    "page": "classes/PyLibrary.md"
  },
  "PyLibrary.children": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyLibrary)arg1) -> list"
  },
  "PyLibrary.folders": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyLibrary)arg1) -> list"
  },
  "PyLibrary.batch_iterations": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyLibrary)arg1) -> list"
  },
  "PyLibrary.desktops": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyLibrary)arg1) -> list"
  },
  "PyLibrary.reel_groups": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyLibrary)arg1) -> list"
  },
  "PyLibrary.reels": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyLibrary)arg1) -> list"
  },
  "PyLibrary.sequences": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyLibrary)arg1) -> list"
  },
  "PyLibrary.clips": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyLibrary)arg1) -> list"
  },
  "PyLibrary.batch_groups": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyLibrary)arg1) -> list"
  },
  "PyLibrary.opened": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyLibrary)arg1) -> bool"
  },
  "PyLibrary.open": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "open( (PyLibrary)arg1) -> bool :\n    Open a Library and load it in the application memory. Until a Library is open, it cannot be accessed. Libraries are created open."
  },
  "PyLibrary.close": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "close( (PyLibrary)arg1) -> bool :\n    Close a Library to release it from the application memory."
  },
  "PyLibrary.clear": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear( (PyLibrary)arg1 [, (bool)confirm=True]) -> bool :\n    Clear the Library's contents."
  },
  "PyLibrary.acquire_exclusive_access": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "acquire_exclusive_access( (PyLibrary)arg1) -> bool :\n    Acquire exclusive access to the Shared Library. Shared Libraries are created locked. Only use with Shared Libraries."
  },
  "PyLibrary.release_exclusive_access": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "release_exclusive_access( (PyLibrary)arg1) -> bool :\n    Release exclusive access to the Shared Library. Only used for Shared Libraries. Only use with Shared Libraries."
  },
  "PyLibrary.create_reel_group": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_reel_group( (PyLibrary)arg1, (str)name) -> object :\n    Create a Reel Group inside a Library."
  },
  "PyLibrary.create_reel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_reel( (PyLibrary)arg1, (str)name) -> object :\n    Create a Reel inside a Library."
  },
  "PyLibrary.create_folder": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_folder( (PyLibrary)arg1, (str)name) -> object :\n    Create a Folder inside a Library."
  },
  "PyLibrary.create_sequence": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_sequence( (PyLibrary)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object :\n    Create a Sequence in a PyReel, PyLibrary, PyFolder.\n    Keywords arguments:\n    video_tracks -- Number of video tracks. Integer between 1 and 8.\n    video_stereo -- Stereoscopy. False for mono, True for stereo.\n    width -- Integer between 24 and 16384.\n    height -- Integer between 24 and 16384.\n    ratio -- Frame aspect ratio. Float between 0.01 and 100.\n    scan_mode -- Scan mode of the sequence. (F1, F2, P)\n    frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps)\n    start_at -- Start timecode. The timecode format must be of the format specified by *frame_rate*.\n    duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by *frame_rate*. If an integer, it represents a number of frames.\n    audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16)\n    audio_stereo -- Stereophony, apply to all *audio_tracks*. False for mono tracks, True for stereo."
  },
  "PyMarker": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Marker.",
    "page": "classes/PyMarker.md"
  },
  "PyMarker.has_annotations": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMarker)arg1) -> bool"
  },
  "PyMarker.clear_annotations": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_annotations( (PyMarker)arg1) -> None :\n    Clear all the annotations from the Marker."
  },
  "PyMarker.sync_connected_segments": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "sync_connected_segments( (PyMarker)arg1) -> None :\n    Push the Segment Marker to connected segments."
  },
  "PyMediaHub": {
    "module": "flame",
    "type": "class",
    "doc": "This class represents the MediaHub.",
    "page": "classes/PyMediaHub.md"
  },
  "PyMediaHub.files": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubFilesTab"
  },
  "PyMediaHub.archives": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHub)arg1) -> flame.PyMediaHubTab"
  },
  "PyMediaHubFilesEntry": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a clip in the MediaHub Files tabs",
    "page": "classes/PyMediaHubFilesEntry.md"
  },
  "PyMediaHubFilesEntry.path": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesEntry)arg1) -> str"
  },
  "PyMediaHubFilesFolder": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a folder in the MediaHub Files tabs",
    "page": "classes/PyMediaHubFilesFolder.md"
  },
  "PyMediaHubFilesFolder.path": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesFolder)arg1) -> str"
  },
  "PyMediaHubFilesTab": {
    "module": "flame",
    "type": "class",
    "doc": "This class represents the MediaHub Files tab.",
    "page": "classes/PyMediaHubFilesTab.md"
  },
  "PyMediaHubFilesTab.options": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTab)arg1) -> flame.PyMediaHubFilesTabOptions"
  },
  "PyMediaHubFilesTabOptions": {
    "module": "flame",
    "type": "class",
    "doc": "This class represents the MediaHub Files tab options.",
    "page": "classes/PyMediaHubFilesTabOptions.md"
  },
  "PyMediaHubFilesTabOptions.multi_channel_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> str"
  },
  "PyMediaHubFilesTabOptions.sequence_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool"
  },
  "PyMediaHubFilesTabOptions.cache_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool"
  },
  "PyMediaHubFilesTabOptions.proxies_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool"
  },
  "PyMediaHubFilesTabOptions.cache_and_proxies_all_versions": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool"
  },
  "PyMediaHubFilesTabOptions.resize_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> str"
  },
  "PyMediaHubFilesTabOptions.resize_filter": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> str"
  },
  "PyMediaHubFilesTabOptions.resolution": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> str"
  },
  "PyMediaHubFilesTabOptions.width": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> object"
  },
  "PyMediaHubFilesTabOptions.height": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> object"
  },
  "PyMediaHubFilesTabOptions.scaling_presets_value": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> object"
  },
  "PyMediaHubFilesTabOptions.frame_ratio": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> object"
  },
  "PyMediaHubFilesTabOptions.bit_depth": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> object"
  },
  "PyMediaHubFilesTabOptions.scan_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> str"
  },
  "PyMediaHubFilesTabOptions.pixel_ratio": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> object"
  },
  "PyMediaHubFilesTabOptions.colour_mgmt_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> str"
  },
  "PyMediaHubFilesTabOptions.colour_mgmt_view": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> str"
  },
  "PyMediaHubFilesTabOptions.tagged_colour_space": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> str"
  },
  "PyMediaHubFilesTabOptions.colour_mgmt_display": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> str"
  },
  "PyMediaHubFilesTabOptions.colour_mgmt_working_space": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> str"
  },
  "PyMediaHubFilesTabOptions.colour_mgmt_invert": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubFilesTabOptions)arg1) -> bool"
  },
  "PyMediaHubFilesTabOptions.import_transform": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_transform( (PyMediaHubFilesTabOptions)arg1, (str)file_path) -> None :\n    Import a transform from a file."
  },
  "PyMediaHubFilesTabOptions.set_tagged_colour_space": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_tagged_colour_space( (PyMediaHubFilesTabOptions)arg1, (str)colour_space) -> None :\n    Set the tagged colour space to use upon import."
  },
  "PyMediaHubProjectsEntry": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a clip in the MediaHub Projects tabs",
    "page": "classes/PyMediaHubProjectsEntry.md"
  },
  "PyMediaHubProjectsEntry.uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubProjectsEntry)arg1) -> str"
  },
  "PyMediaHubProjectsEntry.path": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubProjectsEntry)arg1) -> str"
  },
  "PyMediaHubProjectsFolder": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a folder in the MediaHub Projects tabs",
    "page": "classes/PyMediaHubProjectsFolder.md"
  },
  "PyMediaHubProjectsFolder.uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubProjectsFolder)arg1) -> str"
  },
  "PyMediaHubProjectsFolder.path": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaHubProjectsFolder)arg1) -> str"
  },
  "PyMediaHubTab": {
    "module": "flame",
    "type": "class",
    "doc": "This class represents a MediaHub tab.",
    "page": "classes/PyMediaHubTab.md"
  },
  "PyMediaHubTab.get_path": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_path( (PyMediaHubTab)arg1) -> str :\n    Return the MediaHub tab current path."
  },
  "PyMediaHubTab.set_path": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_path( (PyMediaHubTab)arg1, (str)arg2 [, (bool)allow_partial_success=False]) -> bool :\n    Set the MediaHub tab current path. If allow_partial_success is True, the path will be set to the last valid folder in the path."
  },
  "PyMediaPanel": {
    "module": "flame",
    "type": "class",
    "doc": "This class represents the media panel.",
    "page": "classes/PyMediaPanel.md"
  },
  "PyMediaPanel.selected_entries": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaPanel)arg1) -> object"
  },
  "PyMediaPanel.visible": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaPanel)arg1) -> bool"
  },
  "PyMediaPanel.full_height": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaPanel)arg1) -> bool"
  },
  "PyMediaPanel.full_width": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaPanel)arg1) -> bool"
  },
  "PyMediaPanel.dual": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMediaPanel)arg1) -> bool"
  },
  "PyMediaPanel.move": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "move( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object :\n    Move a PyObject or a list of PyObjects from the Media Panel to a destination inside the Media Panel.\n    Return a list of the moved PyObjects.\n    Keyword arguments:\n    source_entries -- The PyObject or list of PyObjects to move.\n    destination -- The PyObject that acts as destination.\n    duplicate_action -- Action to take when finding an object with the same name (add or replace).\n    "
  },
  "PyMediaPanel.copy": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "copy( (PyMediaPanel)arg1, (object)source_entries, (object)destination [, (str)duplicate_action='add']) -> object :\n    Copy a PyObject or a list of PyObjects from the Media Panel to a destination inside the Media Panel.Return a list of the copied PyObjects.Keyword arguments:\n    source_entries -- The PyObject or list of PyObjects to copy.\n    destination -- The PyObject that acts as destination.\n    duplicate_action -- Action to take when finding an object with the same name (add or replace).\n    "
  },
  "PyMessages": {
    "module": "flame",
    "type": "class",
    "doc": "Module handling message bar in application UI.",
    "page": "classes/PyMessages.md"
  },
  "PyMessages.show_in_console": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "show_in_console( (PyMessages)arg1, (str)message [, (str)type='info' [, (int)duration=-1]]) -> None :\n    Display an informative message in application message bar.\n    message -- Message string to display.\n    type -- Message type can be info, warning, or error.\n    duration -- An optional time in seconds to keep message on screen."
  },
  "PyMessages.clear_console": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_console( (PyMessages)arg1) -> None :\n    Remove currently displayed message in the message bar."
  },
  "PyMessages.show_in_dialog": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "show_in_dialog( (PyMessages)arg1, (str)title, (str)message, (str)type, (list)buttons [, (str)cancel_button='']) -> str :\n    Display a custom dialog with a selection of options.\n    Keywords argument:\n    title -- The title of the dialog.\n    message -- The message displayed in the centre of the dialog.\n    type -- The type of dialog. Can be error, info, question, or warning.\n    buttons -- The list of titles used to refer to the options\n    cancel_button -- The text displayed in the cancel option"
  },
  "PyMetadataNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyNode. This class represents a Metadata node.",
    "page": "classes/PyMetadataNode.md"
  },
  "PyMetadataNode.set_metadata_value": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None]]]) -> None :\n    Set the metadata on the Node.\n    Keyword arguments:\n    socket_name -- The socket on which to set the metadata. The default output is used when not specified.\n    key -- Metadata key to be set or added.\n    value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value.\n    "
  },
  "PyMetadataNode.set_metadata_discarded": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None :\n    Discard key from the Node's metadata output.\n    Keyword arguments:\n    socket_name -- The socket on which the discarded status of the metadata must be changed.\n    key -- Metadata key to be discarded or restored.\n    discarded -- True to discard the key from the node metadata output, False to restore the key.\n    "
  },
  "PyMetadataNode.set_metadata_key": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None :\n    Rename a metadata key on the Node.\n    Keyword arguments:\n    socket_name -- The socket on which to rename the key. The default output is used when not specified.\n    key -- The current metadata key name to be renamed.\n    name -- The new metadata key name. If None, the current key name will revert to its original value.\n    "
  },
  "PyMetadataNode.load_node_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "load_node_setup( (PyMetadataNode)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)replaced_keys=True [, (bool)update_tokens=True]]]]]) -> bool :\n    Load a Metadata Node setup.\n    Keywords argument:\n    file_name -- the path and file name of the setup.\n    edited_keys -- apply edited keys from the setup.\n    discarded_keys -- apply discarded keys from the setup.\n    added_keys -- apply added keys from the setup.\n    replaced_keys -- apply replaced keys from the setup."
  },
  "PyMetadataTimelineFX": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Metadata Timeline FX.",
    "page": "classes/PyMetadataTimelineFX.md"
  },
  "PyMetadataTimelineFX.get_metadata": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_metadata( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (int)frame=1]]) -> object :\n    Return the metadata of a Metadata Timeline FX.\n    Keywords argument:\n    key -- Key of the requested metadata. All metadata is returned when not specified.\n    frame -- Frame number. The first exposed frame being 1. If not specified, the current frame is used."
  },
  "PyMetadataTimelineFX.set_metadata_value": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_value( (PyMetadataTimelineFX)arg1, (str)key [, (object)value=None]) -> None :\n    Set the metadata on a Metadata Timeline FX.\n    Keywords argument:\n    key -- Metadata key to be set or added.\n    value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value.\n    "
  },
  "PyMetadataTimelineFX.set_metadata_discarded": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_discarded( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (bool)discarded=True]]) -> None :\n    Discard key from the metadata output of a Metadata Timeline FX.\n    Keywords argument:\n    key -- Metadata key to be discarded or restored.\n    discarded -- True to discard the key from the Metadata Timeline FX output, False to restore the key.\n    "
  },
  "PyMetadataTimelineFX.set_metadata_key": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_key( (PyMetadataTimelineFX)arg1 [, (str)key='' [, (object)name=None]]) -> None :\n    Rename a metadata key on a Metadata Timeline FX.\n    Keyword arguments:\n    key -- The current metadata key name to be renamed.\n    name -- The new metadata key name. If None, the current key name will revert to its original value.\n    "
  },
  "PyMetadataTimelineFX.load_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "load_setup( (PyMetadataTimelineFX)arg1, (str)file_name [, (bool)edited_keys=True [, (bool)discarded_keys=True [, (bool)added_keys=True [, (bool)update_tokens=True]]]]) -> bool :\n    Load a Metadata Timeline FX setup.\n    Keywords argument:\n    file_name -- the path and file name of the setup.\n    edited_keys -- apply edited keys from the setup.\n    discarded_keys -- apply discarded keys from the setup.\n    added_keys -- apply added keys from the setup."
  },
  "PyMetadataValue": {
    "module": "flame",
    "type": "class",
    "doc": "This class holds the metadata of a specific data type.",
    "page": "classes/PyMetadataValue.md"
  },
  "PyMetadataValue.get_value": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_value( (PyMetadataValue)arg1) -> object :\n    Get the metadata value."
  },
  "PyMetadataValue.set_value": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_value( (PyMetadataValue)arg1, (object)value) -> None :\n    Set the metadata value."
  },
  "PyMetadataValue.type": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyMetadataValue)arg1) -> str"
  },
  "PyMorphNode": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Morph node.",
    "page": "classes/PyMorphNode.md"
  },
  "PyMorphNode.set_mix_to_range": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_mix_to_range( (PyMorphNode)arg1) -> None :\n    Move the first and last keyframes of the mix curve to the range's first and last frame."
  },
  "PyNode": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Node.",
    "page": "classes/PyNode.md"
  },
  "PyNode.sockets": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyNode)arg1) -> dict"
  },
  "PyNode.input_sockets": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyNode)arg1) -> list"
  },
  "PyNode.output_sockets": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyNode)arg1) -> list"
  },
  "PyNode.load_node_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "load_node_setup( (PyNode)arg1, (str)file_name) -> bool :\n    Load a Node setup. A path and a file name must be defined as arguments."
  },
  "PyNode.save_node_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "save_node_setup( (PyNode)arg1, (str)file_name) -> bool :\n    Save a Node setup. A path and a file name must be defined as arguments."
  },
  "PyNode.delete": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "delete( (PyFlameObject)arg1 [, (bool)confirm=True]) -> bool :\n    Delete the node."
  },
  "PyNode.duplicate": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "duplicate( (PyNode)arg1 [, (bool)keep_node_connections=False]) -> object :\n    Duplicate the node."
  },
  "PyNode.set_context": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_context( (PyNode)arg1, (int)index [, (str)socket_name='Default']) -> bool :\n    Set a Context view on a Node socket. An index and a socket name must be defined as arguments."
  },
  "PyNode.clear_schematic_colour": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_schematic_colour( (PyNode)arg1) -> None :\n    Clear the schematic colour of the Node."
  },
  "PyNode.get_metadata": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_metadata( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)frame=None]]]) -> object :\n    Return the metadata of the Node.\n    Keyword arguments:\n    socket_name -- The socket from which to pull the metadata. The default output is used when not specified.\n    key -- key of the requested metadata. All metadata is returned when not specified.\n    frame -- frame of the requested metadata. The current frame is used when not specified."
  },
  "PyNode.cache_range": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "cache_range( (PyNode)arg1 [, (object)start=None [, (object)end=None]]) -> int :\n    Cache the Node result.\n    Keyword arguments:\n    start -- The first frame of the cache range. The current Batch start frame is used when not specified.\n    end -- The last frame of the cache range. The current Batch end frame is used when not specified."
  },
  "PyNode.output_channel_as_metadata_key": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "output_channel_as_metadata_key( (PyNode)arg1, (str)channel_name [, (bool)enable=True]) -> None :\n    Enable/Disable the output as metadata of a channel.\n    Keyword arguments:\n    channel_name -- The name of the channel to output in the metadata; the Node name can be omitted.\n    enable -- True to output metadata, False to stop outputting."
  },
  "PyOFXNode": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a OpenFX node.",
    "page": "classes/PyOFXNode.md"
  },
  "PyOFXNode.change_plugin": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "change_plugin( (PyOFXNode)arg1, (str)plugin_name) -> bool :\n    Change the active plugin for the openFX node"
  },
  "PyPaintNode": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Paint node.",
    "page": "classes/PyPaintNode.md"
  },
  "PyPaintNode.add_source": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "add_source( (PyPaintNode)arg1) -> object :\n    Add a Source layer to a Paint node."
  },
  "PyProject": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Project.",
    "page": "classes/PyProject.md"
  },
  "PyProject.name": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProject)arg1) -> str"
  },
  "PyProject.nickname": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProject)arg1) -> str"
  },
  "PyProject.description": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProject)arg1) -> str"
  },
  "PyProject.project_name": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProject)arg1) -> str"
  },
  "PyProject.workspaces_count": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProject)arg1) -> int"
  },
  "PyProject.current_workspace": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProject)arg1) -> object"
  },
  "PyProject.shared_libraries": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProject)arg1) -> list"
  },
  "PyProject.project_folder": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProject)arg1) -> str"
  },
  "PyProject.setups_folder": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProject)arg1) -> str"
  },
  "PyProject.media_folder": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProject)arg1) -> str"
  },
  "PyProject.create_shared_library": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_shared_library( (PyProject)arg1, (str)name) -> object :\n    Create a new Shared Library in the Project."
  },
  "PyProject.refresh_shared_libraries": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "refresh_shared_libraries( (PyProject)arg1) -> bool :\n    Refresh the Shared Libraries list in the Media Panel."
  },
  "PyProject.reload_ocio_config": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "reload_ocio_config( (PyProject)arg1 [, (bool)reset_colour_policy=False]) -> bool :\n    Reload the OCIO config file.\n    Keyword argument:\n    reset_colour_policy -- Delete the project's custom colour spaces, roles, and rules (false by default)."
  },
  "PyProject.export_ocio_config": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "export_ocio_config( (PyProject)arg1, (str)config_name [, (str)destination_folder='' [, (bool)overwrite_existing=False [, (bool)export_as_locked=False [, (bool)generate_ocioz=False]]]]) -> bool :\n    Export the OCIO config file.\n    Keyword arguments:\n    config_name -- Specifies the name that will be written inside the exported OCIO config and used as the parent folder name where the config will be exported. It should not contain the '.ocio' extension. Mandatory.\n    destination_folder -- Specifies the absolute destination folder for the exported OCIO config. It will use the default colour management shared path if empty.\n    overwrite_existing -- Specifies if the export should overwrite an existing OCIO config with the same name located in the same destination_folder.\n    export_as_locked -- Specifies if the exported OCIO config should be locked (the 'LockedPolicy' parameter inside the settings.cfg sidecar file).\n    generate_ocioz -- Specifies if an OCIOZ archive should be created alongside the exported OCIO config."
  },
  "PyProject.set_context_variable": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_context_variable( (PyProject)arg1, (str)name, (str)value) -> None :\n    Set the value for the specified context variable."
  },
  "PyProject.get_context_variables": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_context_variables( (PyProject)arg1) -> dict :\n    Get the context variables in a dictionary."
  },
  "PyProject.reset_context_variables": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "reset_context_variables( (PyProject)arg1) -> None :\n    Reset the context variables to their initial state from the ocio config."
  },
  "PyProjectSelector": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing the Project manager.",
    "page": "classes/PyProjectSelector.md"
  },
  "PyProjectSelector.current_project": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyProjectSelector)arg1) -> object"
  },
  "PyReadFileNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyNode. This class represents a ReadFile node.",
    "page": "classes/PyReadFileNode.md"
  },
  "PyReel": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Reel.",
    "page": "classes/PyReel.md"
  },
  "PyReel.children": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyReel)arg1) -> list"
  },
  "PyReel.sequences": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyReel)arg1) -> list"
  },
  "PyReel.clips": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyReel)arg1) -> list"
  },
  "PyReel.type": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyReel)arg1) -> object"
  },
  "PyReel.clear": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear( (PyReel)arg1 [, (bool)confirm=True]) -> bool :\n    Clear the Reel content."
  },
  "PyReel.create_sequence": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_sequence( (PyReel)arg1 [, (str)name='Untitled Sequence' [, (int)video_tracks=1 [, (bool)video_stereo=False [, (object)width=None [, (object)height=None [, (object)ratio=None [, (object)bit_depth=None [, (object)scan_mode=None [, (object)frame_rate=None [, (object)start_at=00:00:00+00 [, (object)duration=00:00:00+01 [, (int)audio_tracks=1 [, (bool)audio_stereo=True]]]]]]]]]]]]]) -> object :\n    Create a Sequence in a PyReel, PyLibrary, PyFolder.\n    Keywords arguments:\n    video_tracks -- Number of video tracks. Integer between 1 and 8.\n    video_stereo -- Stereoscopy. False for mono, True for stereo.\n    width -- Integer between 24 and 16384.\n    height -- Integer between 24 and 16384.\n    ratio -- Frame aspect ratio. Float between 0.01 and 100.\n    scan_mode -- Scan mode of the sequence. (F1, F2, P)\n    frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps)\n    start_at -- Start timecode. The timecode format must be of the format specified by *frame_rate*.\n    duration -- Can be an end timecode or an integer. If an end timecode, format must be of the format specified by *frame_rate*. If an integer, it represents a number of frames.\n    audio_tracks -- Number of audio tracks. (0, 1, 2, 4, 8, 12, 16)\n    audio_stereo -- Stereophony, apply to all *audio_tracks*. False for mono tracks, True for stereo."
  },
  "PyReel.save": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "save( (PyReel)arg1) -> bool :\n    Save the Reel to the defined save destination."
  },
  "PyReelGroup": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Reel Group.",
    "page": "classes/PyReelGroup.md"
  },
  "PyReelGroup.children": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyReelGroup)arg1) -> list"
  },
  "PyReelGroup.reels": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyReelGroup)arg1) -> list"
  },
  "PyReelGroup.clear": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear( (PyReelGroup)arg1 [, (bool)confirm=True]) -> bool :\n    Clear the Reel Group content."
  },
  "PyReelGroup.create_reel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_reel( (PyReelGroup)arg1, (str)name [, (bool)sequence=False]) -> object :\n    Create a new Reel inside a Reel Group."
  },
  "PyReelGroup.save": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "save( (PyReelGroup)arg1) -> bool :\n    Save the Reel Group to the defined save destination."
  },
  "PyRenderNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyNode. This class represents a Render node.",
    "page": "classes/PyRenderNode.md"
  },
  "PyRenderNode.channels": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyRenderNode)arg1) -> list"
  },
  "PyRenderNode.set_channel_name": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_channel_name( (PyRenderNode)arg1, (object)channel, (object)name) -> None :\n    Rename a channel, using its index or front channel name as the index key.\n    Keyword arguments:\n    channel -- The channel to rename. Can be the channel index or the current name of the channel's front socket.\n    name -- The new name of the channel. The type is either a string or a tuple. A Write File node always takes a string. A Render node takes a string or a tuple.\n    In a Render node, a string only sets the name of the channel's front socket; the function creates the name of the matte socket by appending '_alpha' to 'name'. In the UI, the channel is flagged 'Sync'. A Write File node has only one socket per channel, and requires only a string to set a socket name.\n    In a Render node, a tuple sets the names of the front and matte sockets. In the UI, the channel is not flagged 'Sync'. A Write File node does not accept a tuple."
  },
  "PyRenderNode.set_metadata_value": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_value( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)value=None [, (bool)is_dynamic=False]]]]) -> None :\n    Set the metadata on the Node.\n    Keyword arguments:\n    socket_name -- The socket on which to set the metadata. The default output is used when not specified.\n    key -- Metadata key to be set or added.\n    value -- Metadata value to be set or edited for the specified key. If None is specified, the current value will revert to the original value.\n    is_dynamic -- Set the Metadata value to be resolved dynamically if it contains tokens.\n    "
  },
  "PyRenderNode.set_metadata_discarded": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_discarded( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (bool)discarded=True]]]) -> None :\n    Discard key from the Node's metadata output.\n    Keyword arguments:\n    socket_name -- The socket on which the discarded status of the metadata must be changed.\n    key -- Metadata key to be discarded or restored.\n    discarded -- True to discard the key from the node metadata output, False to restore the key.\n    "
  },
  "PyRenderNode.set_metadata_key": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_metadata_key( (PyNode)arg1 [, (str)socket_name='Default' [, (str)key='' [, (object)name=None]]]) -> None :\n    Rename a metadata key on the Node.\n    Keyword arguments:\n    socket_name -- The socket on which to rename the key. The default output is used when not specified.\n    key -- The current metadata key name to be renamed.\n    name -- The new metadata key name. If None, the current key name will revert to its original value.\n    "
  },
  "PyResolution": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a resolution\n\nPyResolution()\nPyResolution(width, height, bit_depth, frame_ratio, scan_format)",
    "page": "classes/PyResolution.md"
  },
  "PyResolution.resolution": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyResolution)arg1) -> str"
  },
  "PyResolution.width": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyResolution)arg1) -> int"
  },
  "PyResolution.height": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyResolution)arg1) -> int"
  },
  "PyResolution.frame_ratio": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyResolution)arg1) -> float"
  },
  "PyResolution.scan_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyResolution)arg1) -> str"
  },
  "PyResolution.bit_depth": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyResolution)arg1) -> int"
  },
  "PySearch": {
    "module": "flame",
    "type": "class",
    "doc": "This class represents the search.",
    "page": "classes/PySearch.md"
  },
  "PySearch.use_weight": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySearch)arg1) -> bool"
  },
  "PySearch.set_tool_favorite": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_tool_favorite( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None :\n    Return the favorite status of a tool."
  },
  "PySearch.set_tool_hidden": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_tool_hidden( (PySearch)arg1, (str)arg2, (str)name, (bool)type) -> None :\n    Return the hidden status of a tool."
  },
  "PySearch.set_tool_weight": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_tool_weight( (PySearch)arg1, (str)arg2, (str)name, (int)type) -> None :\n    Return the tool weight."
  },
  "PySearch.search_results": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "search_results( (PySearch)arg1 [, (str)search_str='*' [, (str)tab='Tools']]) -> list :\n    Search results that match a string."
  },
  "PySearch.activate_search_result": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "activate_search_result( (PySearch)arg1, (str)name, (str)type [, (str)tab='Tools']) -> None :\n    Activate a search result."
  },
  "PySegment": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Segment.",
    "page": "classes/PySegment.md"
  },
  "PySegment.source_name": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.source_in": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> object"
  },
  "PySegment.source_out": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> object"
  },
  "PySegment.source_duration": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> object"
  },
  "PySegment.source_width": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> int"
  },
  "PySegment.source_height": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> int"
  },
  "PySegment.source_bit_depth": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> int"
  },
  "PySegment.source_ratio": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> float"
  },
  "PySegment.source_scan_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.source_frame_rate": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.source_cached": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.source_has_history": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> bool"
  },
  "PySegment.source_unlinked": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.source_sample_rate": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.source_audio_track": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> int"
  },
  "PySegment.source_essence_uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.source_uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.original_source_uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.source_colour_primaries": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> int"
  },
  "PySegment.source_transfer_characteristics": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> int"
  },
  "PySegment.source_matrix_coefficients": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> int"
  },
  "PySegment.tape_name": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.record_in": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> object"
  },
  "PySegment.record_out": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> object"
  },
  "PySegment.record_duration": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> object"
  },
  "PySegment.start_frame": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> int"
  },
  "PySegment.file_path": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.markers": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> list"
  },
  "PySegment.effect_types": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> list"
  },
  "PySegment.effects": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> list"
  },
  "PySegment.groups": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> list"
  },
  "PySegment.type": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.head": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> object"
  },
  "PySegment.tail": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> object"
  },
  "PySegment.rgb_channel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.matte_channel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.rgb_channels": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> list"
  },
  "PySegment.matte_channels": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> list"
  },
  "PySegment.version_uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.version_uids": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> list"
  },
  "PySegment.matte_mode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> str"
  },
  "PySegment.container_clip": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySegment)arg1) -> object"
  },
  "PySegment.create_effect": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_effect( (PySegment)arg1, (str)effect_type [, (str)after_effect_type='']) -> object :\n    Add an effect of effect_type on the Segment.\n    after_effect_type can be specified to insert the effect at a specific position."
  },
  "PySegment.create_marker": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_marker( (PySegment)arg1, (object)location) -> object :\n    Create a Marker at the specified location on the Segment."
  },
  "PySegment.create_connection": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_connection( (PySegment)arg1) -> None :\n    Create a connected segment connection."
  },
  "PySegment.remove_connection": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "remove_connection( (PySegment)arg1) -> None :\n    Remove the connected segment connection."
  },
  "PySegment.sync_connected_segments": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "sync_connected_segments( (PySegment)arg1) -> None :\n    Sync connected segments with the Timeline FXs of the current segment."
  },
  "PySegment.connected_segments": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "connected_segments( (PySegment)arg1 [, (str)scoping='all reels']) -> object :\n    Return a list of the connected segments.\n    Keywords argument:\n    scoping -- Scopes of the sequences to query (all reels, sequences reels, current reel, current sequence).\n     (Default:all reels)"
  },
  "PySegment.duplicate_source": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "duplicate_source( (PySegment)arg1) -> None :\n    Insure that the segment's source is not shared anymore."
  },
  "PySegment.shared_source_segments": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "shared_source_segments( (PySegment)arg1) -> object :\n    Return a list of the segments sharing this segment's source."
  },
  "PySegment.copy_to_media_panel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "copy_to_media_panel( (PySegment)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object :\n    Create a new clip with a copy of the PyObject.\n    "
  },
  "PySegment.trim_head": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "trim_head( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool :\n    Modify the amount of head of the PySegment.\n    Keywords argument:\n    offset -- Number of frames to add or remove from the head.\n    ripple -- Enable to prevent gaps from appearing when performing a trim.\n    sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.\n    keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop)"
  },
  "PySegment.trim_tail": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "trim_tail( (PySegment)arg1, (int)offset [, (bool)ripple=False [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]]) -> bool :\n    Modify the amount of tail of the PySegment.\n    Keywords argument:\n    offset -- Number of frames to add or remove from the tail.\n    ripple -- Enable to prevent gaps from appearing when performing a trim.\n    sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.\n    keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop)"
  },
  "PySegment.slip": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "slip( (PySegment)arg1, (int)offset [, (bool)sync=False [, (str)keyframes_move_mode='Shift']]) -> bool :\n    Slip the media of the PySegment.\n    Keywords argument:\n    offset -- Relative offset to slip the media.\n    sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.\n    keyframes_move_mode -- Select how the animation channels are affected ( Pin, Shift, Prop)"
  },
  "PySegment.slide_keyframes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "slide_keyframes( (PySegment)arg1, (int)offset [, (bool)sync=False]) -> bool :\n    Slide the keyframes the PySegment.\n    Keywords argument:\n    offset -- Relative offset to slide the keyframes.\n    sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.\n    "
  },
  "PySegment.set_gap_colour": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_gap_colour( (PySegment)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None :\n    Create a colour source segment for the duration of the gap, or set the colour of an existing colour source."
  },
  "PySegment.set_gap_bars": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_gap_bars( (PySegment)arg1 [, (str)type='smpte' [, (bool)full_luminance=False [, (float)softness=0.0]]]) -> object :\n    Create colour bars segment for the duration of the gap.\n    Returns a new PySegment on success.\n    Keywords argument:\n    type -- smpte or pal.\n    full_luminance -- bars created at 100 or 75 percent luminance.\n    softness -- softness to apply between the bars."
  },
  "PySegment.smart_replace": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "smart_replace( (PySegment)arg1, (PyClip)source_clip) -> None :\n    Replace the PySegment by the source_clip segment, including the Timeline FX."
  },
  "PySegment.smart_replace_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "smart_replace_media( (PySegment)arg1, (PyClip)source_clip) -> None :\n    Replace the media of PySegment by the source_clip segment, leaving the PySegment Timeline FX untouched"
  },
  "PySegment.match": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "match( (PySegment)arg1, (PyArchiveEntry)destination [, (bool)preserve_handle=False [, (bool)use_sequence_info=True [, (bool)include_nested_content=False [, (bool)include_timeline_fx=False]]]]) -> object :\n    Match out the media of the PySegment to the destination.\n    Returns a PyClip or a list of PyClip (with the included_nested_content option).\n    Keywords argument:\n    destination -- The PyObject that acts as the destination.\n    preserve_handle -- Prevent the unrolling of the media handles.\n    use_sequence_info -- Copy sequence segment information to the new matched clip.\n    include_nested_content -- Include all sources found inside a BFX or Matte Container.\n    include_timeline_fx -- Copy the Timeline FX present on the original clip to the new matched clip.\n    "
  },
  "PySegment.clear_colour": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_colour( (PySegment)arg1) -> None :\n    Clear the colour of the Segment."
  },
  "PySegment.set_rgb_channel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_rgb_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences']]]) -> bool :\n    Set the RGB channel of the source specified by channel_index or by channel_name\n    Keywords argument:\n    channel_name -- Name of the channel found in rgb_channels.\n    channel_index -- Index of the channel found in rgb_channels.\n    scope -- Scope of the changes ( Follow Preferences, No Sharing, Follow Source Sharing, Follow Connected Segments).\n    "
  },
  "PySegment.set_matte_channel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_matte_channel( (PySegment)arg1 [, (str)channel_name='' [, (int)channel_index=-1 [, (str)scope='Follow Preferences' [, (str)matte_mode='Custom Matte']]]]) -> bool :\n    Set the Matte channel of the source specified by channel_index or by channel_name if the matte_mode is set to Custom Matte.\n    Keywords argument:\n    channel_name -- Name of the channel found in matte_channels.\n    channel_index -- Index of the channel found in matte_channels.\n    scope -- Scope of the changes ( Follow Preferences, No Sharing, Follow Source Sharing, Follow Connected Segments).\n    matte_mode -- Matte origin (Follow RGB, No Matte, Custom Matte).\n    "
  },
  "PySegment.set_version_uid": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_version_uid( (PySegment)arg1, (str)version_uid [, (str)scope='Follow Source Sharing']) -> bool :\n    Set the current version unique ID of the source.\n    Keywords argument:\n    version_uid -- version unique ID.\n    scope -- Scope of the changes ( No Sharing, Follow Source Sharing, Follow Connected Segments).\n    "
  },
  "PySegment.get_colour_space": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_colour_space( (PySegment)arg1 [, (PyTime)time=None]) -> str :\n    Return the colour space at the requested time. Use record_in when no time is supplied."
  },
  "PySegment.create_unlinked_segment": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_unlinked_segment( (PySegment)arg1 [, (str)source_name='' [, (str)tape_name='' [, (object)start_time=0 [, (object)source_duration=0 [, (object)head=0 [, (str)file_path='' [, (int)source_audio_track=1 [, (int)width=0 [, (int)height=0 [, (float)ratio=0.0 [, (int)bit_depth=0 [, (str)scan_mode='Same As Sequence' [, (str)frame_rate='Same As Sequence' [, (object)timewarp_speed=None]]]]]]]]]]]]]]) -> None :\n    Replace the gap with an unlinked source media segment.\n    Keywords argument:\n    source_name -- Name of the source.\n    tape_name -- Tape name of the source.\n    start_time -- Start time of the source. Must be a PyTime or a frame number.\n    source_duration -- Length of the source. Must be a PyTime, a number of frames, or \"Infinite\".\n    head -- Amount of head media to set on the segment.\n    file_path -- File path to the media.\n    source_audio_track -- Audio track from the source.\n    width -- Width of the video media. (0 to use the sequence width)\n    height -- Height of the video media. (0 to use the sequence height)\n    ratio -- Frame ratio of the video media. (0.0 to use the sequence ratio)\n    bit_depth -- Bit depth of the video media. (0 to use the sequence bit depth)\n    scan_mode -- Scan mode of the video media. (P, F1, F2, or Same As Sequence)\n    frame_rate -- Frame rate. (60 fps, 59.54 NDF, 59.94 DF, 50 fps, 30 fps, 29.97 NDF, 29.97 DF, 25 fps, 24 fps, 23.976 fps, Same As Sequence)\n    timewarp_speed -- When defined, a timewarp is applied to the segment with the percentage of timewarp_speed. For audio segments, the speed must be greater than zero.\n    "
  },
  "PySegment.change_start_frame": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "change_start_frame( (PySegment)arg1, (int)start_frame [, (bool)use_segment_connections=True]) -> None :\n    Modify the start frame of the segment.\n    Keywords argument:\n    start_frame -- New start frame of the segment.\n    use_segment_connections -- Sync the start frame of connected segments.\n    "
  },
  "PySegment.get_metadata": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_metadata( (PySegment)arg1 [, (str)key='' [, (PyTime)time=None]]) -> object :\n    Return the metadata of the segment.\n    Keywords argument:\n    key -- Key of the requested metadata. All metadata is returned when not specified.\n    time -- Must be a PyTime. If not specified, the segment start time is used."
  },
  "PySequence": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Sequence.",
    "page": "classes/PySequence.md"
  },
  "PySequence.open": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "open( (PySequence)arg1) -> bool :\n    Open the Sequence."
  },
  "PySequence.create_container": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_container( (PySequence)arg1) -> object :\n    Create a container with the selected segments or between the in and out marks."
  },
  "PySequence.create_version": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_version( (PySequence)arg1 [, (bool)stereo=False]) -> object :\n    Add a Version to the Sequence."
  },
  "PySequence.create_audio": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_audio( (PySequence)arg1 [, (bool)stereo=False]) -> object :\n    Add an Audio Track to the Sequence."
  },
  "PySequence.create_subtitle": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_subtitle( (PySequence)arg1) -> object :\n    Add a Subtitle Track to the Sequence."
  },
  "PySequence.import_subtitles_file": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_subtitles_file( (PySequence)arg1, (str)file_name [, (object)file_type=None [, (bool)align_first_event_to_clip_start=False [, (object)convert_from_frame_rate=None]]]) -> object :\n    Import a subtitles file into a new Subtitles Track.\n    Return the new PySubtitleTrack.\n    Keyword arguments:\n    file_name -- The path and name of the file to import.\n    file_type -- The type of subtitle if it is not the file extension (srt or txt).\n    align_first_event_to_clip_start -- Force the first event to be aligned with the clip start.\n    convert_from_frame_rate -- frame rate of the imported file (for txt files only).\n    "
  },
  "PySequence.create_group": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_group( (PySequence)arg1, (str)name) -> object :\n    Creates a new PySequenceGroup.\n    The group name must be supplied as argument."
  },
  "PySequence.insert": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "insert( (PySequence)arg1, (PyClip)source_clip [, (PyTime)insert_time=None [, (PyTrack)destination_track=None]]) -> bool :\n    Creates a new PySequenceGroup.\n    The group name must be supplied as argument."
  },
  "PySequence.overwrite": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "overwrite( (PySequence)arg1, (PyClip)source_clip [, (PyTime)overwrite_time=None [, (PyTrack)destination_track=None]]) -> bool :\n    Creates a new PySequenceGroup.\n    The group name must be supplied as argument."
  },
  "PySequence.copy_selection_to_media_panel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "copy_selection_to_media_panel( (PySequence)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object :\n    Create a new clip by copying the currently selected segments.\n    Return the new PyClip.\n    Keyword arguments:\n    destination -- The PyObject that acts as the destination.\n    duplicate_action -- Action to take when an object with the same name already exists (add or replace).\n    "
  },
  "PySequence.extract_selection_to_media_panel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "extract_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object :\n    Extract the selection from the sequence.\n    Return the new PyClip created from the selection when a destination is supplied.\n    Keyword arguments:\n    destination -- The PyObject that acts as the destination.\n    duplicate_action -- Action to take when an object with the same name already exists (add or replace).\n    "
  },
  "PySequence.lift_selection_to_media_panel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "lift_selection_to_media_panel( (PySequence)arg1 [, (PyArchiveEntry)destination=None [, (str)duplicate_action='add']]) -> object :\n    Lift the selection from the sequence.\n    Return the new PyClip created from the selection when a destination is supplied.\n    Keyword arguments:\n    destination -- The PyObject that acts as the destination.\n    duplicate_action -- Action to take when an object with the same name already exists (add or replace)."
  },
  "PySequence.groups": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySequence)arg1) -> list"
  },
  "PySequenceGroup": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Group in a Sequence.",
    "page": "classes/PySequenceGroup.md"
  },
  "PySequenceGroup.segments": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PySequenceGroup)arg1) -> list"
  },
  "PySequenceGroup.add": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "add( (PySequenceGroup)arg1, (object)segments) -> None :\n    Adds a PySegment or list of PySegments to the Group."
  },
  "PySequenceGroup.remove": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "remove( (PySequenceGroup)arg1, (object)segments) -> None :\n    Remove a PySegment or list of PySegments from the Group."
  },
  "PySubtitleTrack": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Subtitle Track.",
    "page": "classes/PySubtitleTrack.md"
  },
  "PySubtitleTrack.export_as_srt_file": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "export_as_srt_file( (PySubtitleTrack)arg1, (str)file_name [, (bool)character_based_attributes=True [, (bool)export_colours=False [, (str)exclude_colour='' [, (bool)use_original_colours=False [, (bool)use_original_alignment=False [, (bool)export_alignments=False [, (str)alignment_type='an' [, (str)exclude_alignment='' [, (str)start_timecode='Same as Clip']]]]]]]]]) -> None :\n    Export the Subtitles Track as a SubRip (srt) file.Keyword arguments:\n    file_name -- The path and name of the file to write.\n    character_based_attributes -- Export the bold, italic, and underline attributes.\n    export_colours -- Export colours.\n    exclude_colour -- Specify a colour, in hexadecimal or CSS colour name, to ignore.\n    use_original_colours -- Reuse hexadecimal or CSS colour names from the imported file.\n    use_original_alignment -- Reuse alignment tokens from the imported file .\n    export_alignments -- Export alignments.\n    alignment_type -- Set to a or an alignment style tokens.\n    exclude_alignment -- Specify an alignment to ignore.\n    start_timecode -- Specify the timecode mode, Same as Clip or, Relative to Clip Start."
  },
  "PyTime": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a time unit\n\nPyTime(timecode, frame_rate)\nPyTime(relative_frame)\nPyTime(absolute_frame, frame_rate)",
    "page": "classes/PyTime.md"
  },
  "PyTime.frame": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTime)arg1) -> int"
  },
  "PyTime.relative_frame": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTime)arg1) -> int"
  },
  "PyTime.timecode": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTime)arg1) -> str"
  },
  "PyTime.frame_rate": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTime)arg1) -> object"
  },
  "PyTimeline": {
    "module": "flame",
    "type": "class",
    "doc": "This class represents the Timeline.",
    "page": "classes/PyTimeline.md"
  },
  "PyTimeline.clip": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTimeline)arg1) -> object"
  },
  "PyTimeline.current_segment": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTimeline)arg1) -> object"
  },
  "PyTimeline.current_marker": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTimeline)arg1) -> object"
  },
  "PyTimeline.current_effect": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTimeline)arg1) -> object"
  },
  "PyTimeline.current_transition": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTimeline)arg1) -> object"
  },
  "PyTimeline.type": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTimeline)arg1) -> str"
  },
  "PyTimelineFX": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Timeline FX.",
    "page": "classes/PyTimelineFX.md"
  },
  "PyTimelineFX.type": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTimelineFX)arg1) -> object"
  },
  "PyTimelineFX.has_maps_cache_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTimelineFX)arg1) -> bool"
  },
  "PyTimelineFX.load_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "load_setup( (PyTimelineFX)arg1, (str)file_name) -> bool :\n    Load a Node setup. A path and a file name must be defined as arguments."
  },
  "PyTimelineFX.save_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "save_setup( (PyTimelineFX)arg1, (str)file_name) -> bool :\n    Save a Node setup. A path and a file name must be defined as arguments."
  },
  "PyTimelineFX.flush_maps_cache_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "flush_maps_cache_media( (PyTimelineFX)arg1) -> bool :\n    Clear the Timeline FX Maps and ML cached media.(Deprecated: Use clear_maps_cache_media instead.)\n    "
  },
  "PyTimelineFX.clear_maps_cache_media": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "clear_maps_cache_media( (PyTimelineFX)arg1) -> bool :\n    Clear the Timeline FX Maps and ML cached media."
  },
  "PyTimelineFX.sync_connected_segments": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "sync_connected_segments( (PyTimelineFX)arg1) -> None :\n    Push the Timeline FX to connected segments."
  },
  "PyTimelineFX.slide_keyframes": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "slide_keyframes( (PyTimelineFX)arg1, (float)offset) -> None :\n    Slide the keyframes the PySegment.\n    Keywords argument:\n    offset -- Relative offset to slide the keyframes.\n    sync -- Enable to perform the same operation on the segments that belong to the same sync group as the current PySegment.\n    "
  },
  "PyTimelineFX.output_channel_as_metadata_key": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "output_channel_as_metadata_key( (PyTimelineFX)arg1, (str)channel_name [, (bool)enable=True]) -> None :\n    Enable/Disable the output as metadata of a channel.\n    Keyword arguments:\n    channel_name -- The name of the channel to output in the metadata; the Timeline FX name can be omitted.\n    enable -- True to output metadata, False to stop outputting."
  },
  "PyTimewarpNode": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Timewarp node.",
    "page": "classes/PyTimewarpNode.md"
  },
  "PyTimewarpNode.get_speed": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_speed( (PyTimewarpNode)arg1, (float)frame) -> float :\n    Return the speed attribute at the requested frame."
  },
  "PyTimewarpNode.set_speed": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_speed( (PyTimewarpNode)arg1, (float)frame, (float)new_speed) -> None :\n    Set the speed at the requested frame."
  },
  "PyTimewarpNode.set_timing": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_timing( (PyTimewarpNode)arg1, (float)frame, (float)new_timing) -> None :\n    Set the timing at the requested frame."
  },
  "PyTimewarpNode.get_timing": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_timing( (PyTimewarpNode)arg1, (float)frame) -> float :\n    Return the timing value at the requested frame."
  },
  "PyTimewarpNode.get_duration_timing": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_duration_timing( (PyTimewarpNode)arg1, (float)frame) -> float :\n    Return the timing value for the current frame while in the duration mode."
  },
  "PyTimewarpNode.get_speed_timing": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_speed_timing( (PyTimewarpNode)arg1, (float)frame) -> float :\n    The timing value for the current frame while in the speed mode."
  },
  "PyTimewarpTimelineFX": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Timewarp node.",
    "page": "classes/PyTimewarpTimelineFX.md"
  },
  "PyTimewarpTimelineFX.get_speed": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_speed( (PyTimewarpTimelineFX)arg1, (float)frame) -> float :\n    Return the speed attribute at the requested frame."
  },
  "PyTimewarpTimelineFX.set_speed": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_speed( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_speed) -> None :\n    Set the speed at the requested frame."
  },
  "PyTimewarpTimelineFX.set_timing": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_timing( (PyTimewarpTimelineFX)arg1, (float)frame, (float)new_timing) -> None :\n    Set the timing at the requested frame."
  },
  "PyTimewarpTimelineFX.get_timing": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float :\n    Return the timing value at the requested frame."
  },
  "PyTimewarpTimelineFX.get_duration_timing": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_duration_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float :\n    Return the timing value for the current frame while in the duration mode."
  },
  "PyTimewarpTimelineFX.get_speed_timing": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_speed_timing( (PyTimewarpTimelineFX)arg1, (float)frame) -> float :\n    The timing value for the current frame while in the speed mode."
  },
  "PyTrack": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Track.",
    "page": "classes/PyTrack.md"
  },
  "PyTrack.segments": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTrack)arg1) -> list"
  },
  "PyTrack.transitions": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTrack)arg1) -> list"
  },
  "PyTrack.copy_to_media_panel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "copy_to_media_panel( (PyTrack)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object :\n    Create a new clip with a copy of the PyObject.\n    "
  },
  "PyTrack.cut": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "cut( (PyTrack)arg1, (PyTime)cut_time [, (bool)sync=False]) -> None :\n    Cut the Track."
  },
  "PyTrack.insert_transition": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "insert_transition( (PyTrack)arg1, (PyTime)record_time, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0 [, (bool)sync=False]]]]) -> object :\n    Insert a Transition on the Track.\n    Returns the new PyTransition if successful.\n    Keywords argument:\n    record_time -- Time at which the Transition is inserted.\n    type -- Type of the new Transition.\n    duration -- Duration of the new Transition in frames.\n    alignment -- Alignment of the new Transition.\n    in_offset -- Number of frames on left side of the cut in custom alignment.\n    sync -- Perform the operation on all Tracks part of the sync group."
  },
  "PyTransition": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Transition.",
    "page": "classes/PyTransition.md"
  },
  "PyTransition.type": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTransition)arg1) -> str"
  },
  "PyTransition.record_time": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTransition)arg1) -> object"
  },
  "PyTransition.in_offset": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTransition)arg1) -> int"
  },
  "PyTransition.set_transition": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_transition( (PyTransition)arg1, (str)type [, (int)duration=10 [, (str)alignment='Centred' [, (int)in_offset=0]]]) -> object :\n    Replace the Transition with another type of Transition.\n    Returns the new PyTransition if successful.\n    Keywords argument:\n    type -- Type of the new Transition.\n    duration -- Duration of the new Transition in frames.\n    alignment -- Alignment of the new Transition.\n    in_offset -- Number of frames on left side of the cut in custom alignment."
  },
  "PyTransition.slide": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "slide( (PyTransition)arg1, (int)offset [, (bool)sync=False]) -> bool :\n    Slide the Transition.\n    Keywords argument:\n    offset -- Amount of frames to slide the Transition with.\n    sync -- Enable to perform the same operation on transitions that belong to the same sync group as the current PyTransition."
  },
  "PyTransition.set_dissolve_to_from_colour": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_dissolve_to_from_colour( (PyTransition)arg1 [, (float)r=0.0 [, (float)g=0.0 [, (float)b=0.0]]]) -> None :\n    Make a dissolve transition dissolve to/from a colour."
  },
  "PyTransition.set_fade_to_from_silence": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_fade_to_from_silence( (PyTransition)arg1) -> None :\n    Make a fade dip to/from silence."
  },
  "PyTypeFX": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Type Timeline FX.",
    "page": "classes/PyTypeFX.md"
  },
  "PyTypeFX.layers": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTypeFX)arg1) -> list"
  },
  "PyTypeFX.add_layer": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "add_layer( (PyTypeFX)arg1 [, (str)layer_type='Centre']) -> object :\n    Create a new layer.\n    Keyword argument:\n    layer_type -- Must be one of Left, Centre(default), Right, Roll, or Crawl."
  },
  "PyTypeFX.append_type_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "append_type_setup( (PyTypeFX)arg1, (str)file_name) -> bool :\n    Append a setup to the current Type setup."
  },
  "PyTypeLayer": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Type Layer.",
    "page": "classes/PyTypeLayer.md"
  },
  "PyTypeLayer.type": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTypeLayer)arg1) -> object"
  },
  "PyTypeNode": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Type node.",
    "page": "classes/PyTypeNode.md"
  },
  "PyTypeNode.layers": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyTypeNode)arg1) -> list"
  },
  "PyTypeNode.add_layer": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "add_layer( (PyTypeNode)arg1 [, (str)layer_type='Centre']) -> object :\n    Create a new layer.\n    Keyword argument:\n    layer_type -- Must be one of Left, Centre(default), Right, Roll, or Crawl."
  },
  "PyTypeNode.append_type_setup": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "append_type_setup( (PyTypeNode)arg1, (str)file_name) -> bool :\n    Append a setup to the current Type setup."
  },
  "PyUser": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a User.",
    "page": "classes/PyUser.md"
  },
  "PyUser.name": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyUser)arg1) -> str"
  },
  "PyUser.nickname": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyUser)arg1) -> str"
  },
  "PyUser.shortcuts_profile": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyUser)arg1) -> str"
  },
  "PyUsers": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing the User manager.",
    "page": "classes/PyUsers.md"
  },
  "PyUsers.current_user": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyUsers)arg1) -> object"
  },
  "PyVersion": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Version.",
    "page": "classes/PyVersion.md"
  },
  "PyVersion.tracks": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyVersion)arg1) -> list"
  },
  "PyVersion.stereo": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyVersion)arg1) -> bool"
  },
  "PyVersion.copy_to_media_panel": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "copy_to_media_panel( (PyVersion)arg1, (PyArchiveEntry)destination [, (str)duplicate_action='add']) -> object :\n    Create a new clip with a copy of the PyObject.\n    "
  },
  "PyVersion.create_track": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_track( (PyVersion)arg1 [, (int)track_index=-1 [, (bool)hdr=False]]) -> object :\n    Add a track to the Version.Keywords arguments:\n    track_index -- Index to insert the new track at, -1 to append at the top.\n    hdr -- Set to True to create an HDR track.\n    "
  },
  "PyVersion.import_DolbyVision_xml": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "import_DolbyVision_xml( (PyVersion)arg1, (str)file_name [, (str)mode='Include Frame Based Transitions Trims' [, (int)track_index=-1]]) -> object :\n    Add a track to the Version.Keywords arguments:\n    track_index -- Index to insert the new track at, -1 to append at the top.\n    hdr -- Set to True to create an HDR track.\n    "
  },
  "PyWorkspace": {
    "module": "flame",
    "type": "class",
    "doc": "Object representing a Workspace.",
    "page": "classes/PyWorkspace.md"
  },
  "PyWorkspace.desktop": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyWorkspace)arg1) -> object"
  },
  "PyWorkspace.libraries": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "None( (flame.PyWorkspace)arg1) -> list"
  },
  "PyWorkspace.create_library": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "create_library( (PyWorkspace)arg1, (str)name) -> object :\n    Create a new Library in a Workspace."
  },
  "PyWorkspace.replace_desktop": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "replace_desktop( (PyWorkspace)arg1, (PyDesktop)desktop) -> bool :\n    Replace the Workspace active Desktop with another one."
  },
  "PyWorkspace.set_desktop_reels": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_desktop_reels( (PyWorkspace)arg1 [, (object)group=None]) -> bool :\n    Set the Desktop Reels view mode."
  },
  "PyWorkspace.set_freeform": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "set_freeform( (PyWorkspace)arg1 [, (object)reel=None]) -> bool :\n    Set the Freeform view mode."
  },
  "PyWriteFileNode": {
    "module": "flame",
    "type": "class",
    "doc": "Class derived from PyRenderNode. This class represents a WriteFile node.",
    "page": "classes/PyWriteFileNode.md"
  },
  "PyWriteFileNode.get_resolved_media_path": {
    "module": "flame",
    "type": "method",
    "signature": "(...)",
    "doc": "get_resolved_media_path( (PyWriteFileNode)arg1 [, (bool)show_extension=True [, (bool)translate_path=True [, (object)frame=None]]]) -> object :\n    Return the resolved media path.\n    Keyword arguments:\n    show_extension -- Set True to display the extension.\n    translate_path -- Set True to apply the Media Location Path Translation.\n    frame -- Pass a frame number, between range_start and range_end, to get the path for that frame.\n    "
  },
  "batch": {
    "module": "flame",
    "type": "attribute",
    "page": "constants/batch.md"
  },
  "browser": {
    "module": "flame",
    "type": "attribute",
    "page": "constants/browser.md"
  },
  "media_panel": {
    "module": "flame",
    "type": "attribute",
    "page": "constants/media_panel.md"
  },
  "mediahub": {
    "module": "flame",
    "type": "attribute",
    "page": "constants/mediahub.md"
  },
  "messages": {
    "module": "flame",
    "type": "attribute",
    "page": "constants/messages.md"
  },
  "project": {
    "module": "flame",
    "type": "attribute",
    "page": "constants/project.md"
  },
  "projects": {
    "module": "flame",
    "type": "attribute",
    "page": "constants/projects.md"
  },
  "timeline": {
    "module": "flame",
    "type": "attribute",
    "page": "constants/timeline.md"
  },
  "users": {
    "module": "flame",
    "type": "attribute",
    "page": "constants/users.md"
  }
}