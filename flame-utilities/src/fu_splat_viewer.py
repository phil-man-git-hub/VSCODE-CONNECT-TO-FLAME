"""
FU_Splat_Viewer
---------------
Version: 1.0.0
SDK: fu_pybox_v3_13

A secure, sandboxed visualization handler for Gaussian Splatting data.
It allows Flame artists to inspect and clean up 3D reconstructions using 
local web-based tools (SuperSplat) or external applications (Blender).
"""

import sys
import os
import tempfile
import webbrowser
import threading
import http.server
import socketserver
from pathlib import Path
from typing import List, Dict, Any, Optional

# Add lib to path
REPO_ROOT = Path(__file__).parent.parent
sys.path.append(str(REPO_ROOT / "lib"))
import fu_pybox_v3_13 as pybox

class SplatViewer(pybox.BaseClass):
    """PyBox handler for secure splat visualization."""

    def initialize(self) -> None:
        """Phase 1: Define sockets and primary paths."""
        self.set_img_format("exr")
        img_ext = self.adsk_metadata.get("format", "exr")
        tmp_dir = Path(tempfile.gettempdir())
        
        # Standard input socket (unused by the viewer logic, but required by Flame)
        self.set_in_socket(0, "Front", tmp_dir / f"fu_viewer_in.{img_ext}")
        self.set_out_socket(0, "Result", tmp_dir / f"fu_viewer_out.{img_ext}")

        # Path to the Splat file generated by SHARP
        self.default_splat_path = tmp_dir / "fu_sharp_out_cloud.ply"

        self.set_state_id("setup_ui")
        self.setup_ui()

    def setup_ui(self) -> None:
        """Phase 2: Build the Visualization and Sync UI."""
        
        # --- Page 1: General Settings ---
        apps = ["SuperSplat (Browser)", "Blender (Future)"]
        app_sel = {
            "type": "Pup",
            "name": "Viewer App",
            "items": apps,
            "value": 0,
            "row": 0, "col": 0, "page": 0
        }

        path_field = pybox.create_text_field("Splat Path", value=str(self.default_splat_path), row=1, col=0, page=0)
        status_field = pybox.create_text_field("Status", value="Idle", row=1, col=1, page=0)
        launch_btn = pybox.create_toggle_button("Launch Viewer", value=False, row=0, col=1, page=0)

        # --- Page 2: Camera Sync (Flame 2027 Metadata / Expressions) ---
        # These fields are designed to be targets for Flame Expressions
        cam_pos = pybox.create_vector_numeric("Cam Position", size=3, row=0, col=0, page=1)
        cam_rot = pybox.create_vector_numeric("Cam Rotation", size=3, row=1, col=0, page=1)
        cam_fov = pybox.create_float_numeric("Cam FOV", value=75.0, min_val=1.0, max_val=170.0, row=0, col=1, page=1)
        
        live_sync_toggle = pybox.create_toggle_button("Live Sync", value=False, row=1, col=1, page=1)

        # --- Define Layout & Add Elements ---
        page_general = pybox.create_page("Splat Viewer") # Page 0
        page_sync = pybox.create_page("Camera Sync")    # Page 1
        self.set_ui_pages(page_general, page_sync)
        
        # Add to global pool (triggers python on change)
        self.add_global_elements(path_field, launch_btn, status_field, live_sync_toggle)
        
        # Add to render pool (updated during render pulls/playhead moves)
        self.add_render_elements(app_sel, cam_pos, cam_rot, cam_fov)

        self.set_state_id("execute")

    def execute(self) -> None:
        """Phase 3: Launch external viewer or handle live synchronization."""
        if not self.is_processing():
            return

        # 1. Check for explicit Launch trigger
        launch_active = self.dynamic_ui["global_elements"].get("Launch Viewer", {}).get("value", False)
        if launch_active:
            self._update_status("Launching Viewer...")
            self._launch_viewer()
            self.dynamic_ui["global_elements"]["Launch Viewer"]["value"] = False

        # 2. Check for Live Sync (Metadata/Expression flow)
        sync_enabled = self.dynamic_ui["global_elements"].get("Live Sync", {}).get("value", False)
        if sync_enabled:
            self._sync_camera_data()

    def _update_status(self, msg: str) -> None:
        self.dynamic_ui["global_elements"]["Status"]["value"] = msg

    def _sync_camera_data(self) -> None:
        """
        Processes incoming camera metadata from Flame expressions.
        In a full implementation, this would relay to fu_whisper via WebSocket.
        """
        pos = self.dynamic_ui["render_elements"]["Cam Position"]["values"]
        rot = self.dynamic_ui["render_elements"]["Cam Rotation"]["values"]
        fov = self.dynamic_ui["render_elements"]["Cam FOV"]["value"]
        
        # Log the sync event for debugging/verification
        # In Flame 2027, this happens every time the playhead moves if linked via expressions
        print(f"[LiveSync] POS: {pos} | ROT: {rot} | FOV: {fov}")
        self._update_status(f"Syncing: {fov:.1f} deg")

    def _launch_viewer(self) -> None:
        """Determines which viewer to launch and executes."""
        app_idx = self.dynamic_ui["render_elements"]["Viewer App"]["value"]
        app_name = self.dynamic_ui["render_elements"]["Viewer App"]["items"][app_idx]
        splat_path = Path(self.dynamic_ui["global_elements"]["Splat Path"]["value"])

        if not splat_path.exists():
            self.set_error_msg(f"Error: Splat file not found at {splat_path}")
            return

        if "SuperSplat" in app_name:
            self._launch_supersplat(splat_path)
        elif "Blender" in app_name:
            self.set_error_msg("Blender integration is coming soon.")
            self._update_status("App Unimplemented")

    def _launch_supersplat(self, splat_path: Path) -> None:
        """
        Launches a local sandboxed browser instance.
        In a full deployment, this would host a local copy of SuperSplat.
        For now, we use the public auditable URL with a pointer to local data.
        """
        # Logic: 
        # 1. Start a background thread to serve the file locally
        # 2. Open the browser to the SuperSplat editor
        
        # Note: Browsers usually prevent loading local files from remote URLs due to CORS.
        # Professional implementation would require a local 'WebView' or 'Electron' wrapper.
        
        url = f"https://playcanvas.com/supersplat/editor"
        webbrowser.open(url)
        self.set_error_msg(f"SuperSplat launched. Please drag and drop: {splat_path}")
        self._update_status("Launched (Browser)")

def _main(argv: list[str]) -> None:
    if not argv:
        sys.exit(1)

    handler = SplatViewer(argv[0])
    handler.dispatch()
    handler.write_to_disk()

if __name__ == "__main__":
    _main(sys.argv[1:])
